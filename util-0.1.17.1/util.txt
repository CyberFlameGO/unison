-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities
--   
--   Utilities
@package util
@version 0.1.17.1

module Util
(&=&) :: Applicative p => (a -> p b) -> (a -> p c) -> a -> p (b, c)
infixr 3 &=&
(*=*) :: Applicative p => (a1 -> p b1) -> (a2 -> p b2) -> (a1, a2) -> p (b1, b2)
infixr 3 *=*
tripleK :: Applicative p => (a1 -> p b1) -> (a2 -> p b2) -> (a3 -> p b3) -> (a1, a2, a3) -> p (b1, b2, b3)
(<||>) :: Applicative p => p Bool -> p Bool -> p Bool
infixr 2 <||>
(<&&>) :: Applicative p => p Bool -> p Bool -> p Bool
infixr 3 <&&>
liftA4 :: Applicative p => (a -> b -> c -> d -> e) -> p a -> p b -> p c -> p d -> p e
apMA :: Monad m => m (a -> m b) -> a -> m b
whileJust :: (Alternative f, Monad m) => m (Maybe a) -> (a -> m b) -> m (f b)
untilJust :: Monad m => m (Maybe a) -> m a
whenM :: Monad m => m Bool -> m () -> m ()
unlessM :: Monad m => m Bool -> m () -> m ()
list :: b -> (a -> [a] -> b) -> [a] -> b
list' :: b -> (NonEmpty a -> b) -> [a] -> b
(∘) :: Category p => p b c -> p a b -> p a c
infixr 9 ∘
(&) :: Category p => p a b -> p b c -> p a c
infixr 9 &
(∘∘) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
infixr 9 ∘∘
compose2 :: (a' -> b' -> c) -> (a -> a') -> (b -> b') -> a -> b -> c
compose3 :: (a' -> b' -> c' -> d) -> (a -> a') -> (b -> b') -> (c -> c') -> a -> b -> c -> d
onn :: (a -> a -> a -> b) -> (c -> a) -> c -> c -> c -> b
infixl 0 `onn`
onnn :: (a -> a -> a -> a -> b) -> (c -> a) -> c -> c -> c -> c -> b
infixl 0 `onnn`
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
þrd3 :: (a, b, c) -> c
(₪) :: a -> (a -> b) -> b
infixr 0 ₪
(<₪>) :: Functor f => f a -> (a -> b) -> f b
infixl 4 <₪>
replicate :: Alternative f => Natural -> a -> f a
replicateA :: (Applicative p, Alternative f) => Natural -> p a -> p (f a)
mtimesA :: (Applicative p, Semigroup a, Monoid a) => Natural -> p a -> p a
newtype Ap p a
Ap :: p a -> Ap p a
[unAp] :: Ap p a -> p a
(!!?) :: Foldable f => f a -> Natural -> Maybe a
intercalate :: Semigroup a => a -> NonEmpty a -> a
bind2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c
bind3 :: Monad m => (a -> b -> c -> m d) -> m a -> m b -> m c -> m d
traverse2 :: (Traversable t, Applicative t, Applicative p) => (a -> b -> p c) -> t a -> t b -> p (t c)
traverse3 :: (Traversable t, Applicative t, Applicative p) => (a -> b -> c -> p d) -> t a -> t b -> t c -> p (t d)
foldMap2 :: (Foldable t, Applicative t, Monoid z) => (a -> b -> z) -> t a -> t b -> z
foldMap3 :: (Foldable t, Applicative t, Monoid z) => (a -> b -> c -> z) -> t a -> t b -> t c -> z
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
uncurry4 :: (a -> b -> c -> d -> e) -> (a, b, c, d) -> e
curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e
(∈) :: (Eq a, Foldable f) => a -> f a -> Bool
infix 4 ∈
(∉) :: (Eq a, Foldable f) => a -> f a -> Bool
infix 4 ∉
maximumBy :: Foldable f => (a -> a -> Ordering) -> f a -> Maybe a
minimumBy :: Foldable f => (a -> a -> Ordering) -> f a -> Maybe a
foldMapA :: (Applicative p, Monoid b, Foldable f) => (a -> p b) -> f a -> p b
altMap :: (Alternative p, Foldable f) => (a -> p b) -> f a -> p b
iterateM :: Monad m => Natural -> (a -> m a) -> a -> m (NonEmpty a)
loopM :: MonadFix m => (a -> m (a, b)) -> m b
(<|) :: Alternative f => a -> f a -> f a
infixl 3 <|
(|>) :: Alternative f => f a -> a -> f a
infixl 3 |>
count :: (Traversable f, Enum n) => f a -> f (n, a)
countFrom :: (Traversable f, Enum n) => n -> f a -> f (n, a)
some :: Alternative p => p a -> p (NonEmpty a)
digit :: Char -> Maybe Word
instance Data.Functor.Classes.Show1 p => Data.Functor.Classes.Show1 (Util.Ap p)
instance Data.Functor.Classes.Read1 p => Data.Functor.Classes.Read1 (Util.Ap p)
instance Data.Functor.Classes.Ord1 p => Data.Functor.Classes.Ord1 (Util.Ap p)
instance Data.Functor.Classes.Eq1 p => Data.Functor.Classes.Eq1 (Util.Ap p)
instance GHC.Base.MonadPlus p => GHC.Base.MonadPlus (Util.Ap p)
instance GHC.Base.Alternative p => GHC.Base.Alternative (Util.Ap p)
instance GHC.Base.Monad p => GHC.Base.Monad (Util.Ap p)
instance GHC.Base.Applicative p => GHC.Base.Applicative (Util.Ap p)
instance GHC.Enum.Enum (p a) => GHC.Enum.Enum (Util.Ap p a)
instance GHC.Enum.Bounded (p a) => GHC.Enum.Bounded (Util.Ap p a)
instance GHC.Show.Show (p a) => GHC.Show.Show (Util.Ap p a)
instance GHC.Read.Read (p a) => GHC.Read.Read (Util.Ap p a)
instance GHC.Classes.Ord (p a) => GHC.Classes.Ord (Util.Ap p a)
instance GHC.Classes.Eq (p a) => GHC.Classes.Eq (Util.Ap p a)
instance Data.Traversable.Traversable p => Data.Traversable.Traversable (Util.Ap p)
instance GHC.Base.Functor p => GHC.Base.Functor (Util.Ap p)
instance Data.Foldable.Foldable p => Data.Foldable.Foldable (Util.Ap p)
instance (GHC.Base.Applicative p, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Util.Ap p a)
instance (GHC.Base.Applicative p, GHC.Base.Semigroup a, GHC.Base.Monoid a) => GHC.Base.Monoid (Util.Ap p a)

module Util.Bits
(.&¬) :: Bits a => a -> a -> a
setBits :: (Bits a, Integral n, Alternative f) => a -> f n
interleaveBits :: (Bits a, Bits b) => [a] -> b
fromListLE :: Bits a => [Bool] -> a
toListLE :: Bits a => a -> [Bool]
fromListBE :: Bits a => [Bool] -> a
toListBE :: FiniteBits a => a -> [Bool]

module Util.List
splitWhen :: (a -> Bool) -> [a] -> NonEmpty [a]
padLeft :: Natural -> a -> [a] -> [a]
zipWithRemaining :: (a -> b -> c) -> [a] -> [b] -> ([c], Maybe (Either (NonEmpty a) (NonEmpty b)))

module Util.Monad.ST.Unsafe
unsafeInterleaveWhileJust :: ST s (Maybe a) -> (a -> ST s ()) -> ST s [a]
