-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-util
@version 0.0.0

module U.Util.Alternative
whenM :: (Monad m, Alternative m) => m Bool -> a -> m a

module U.Util.Cache
data Cache k v
Cache :: (k -> IO (Maybe v)) -> (k -> v -> IO ()) -> Cache k v
[lookup_] :: Cache k v -> k -> IO (Maybe v)
[insert_] :: Cache k v -> k -> v -> IO ()
lookup :: MonadIO m => Cache k v -> k -> m (Maybe v)
insert :: MonadIO m => Cache k v -> k -> v -> m ()
cache :: (MonadIO m, Ord k) => m (Cache k v)
nullCache :: Cache k v
semispaceCache :: (MonadIO m, Ord k) => Word -> m (Cache k v)
apply :: MonadIO m => Cache k v -> (k -> m v) -> k -> m v
applyDefined :: (MonadIO m, Applicative g, Traversable g) => Cache k v -> (k -> m (g v)) -> k -> m (g v)

module U.Util.Components

-- | Order bindings by dependencies and group into components. Each
--   component consists of &gt; 1 bindings, each of which depends
--   transitively on all other bindings in the component.
--   
--   1-element components may or may not depend on themselves.
--   
--   The order is such that a component at index i will not depend on
--   components and indexes &gt; i. But a component at index i does not
--   _necessarily_ depend on any components at earlier indices.
--   
--   Example:
--   
--   let rec ping n = pong (n + 1); pong n = ping (n + 1); g = id 42; y =
--   id "hi" id x = x; in ping g
--   
--   <a>components</a> would produce `[[ping,pong], [id], [g], [y]]` Notice
--   that <a>id</a> comes before <tt>g</tt> and <tt>y</tt> in the output,
--   since both <tt>g</tt> and <tt>y</tt> depend on <a>id</a>.
--   
--   Uses Tarjan's algorithm:
--   <a>https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm</a>
components :: Ord v => (t -> Set v) -> [(v, t)] -> [[(v, t)]]

module U.Util.Lens
type Field1' s a = Field1 s s a a
type Field2' s a = Field2 s s a a
type Field3' s a = Field3 s s a a
type Field4' s a = Field4 s s a a

module U.Util.Monoid
intercalateMap :: (Foldable t, Monoid a) => a -> (b -> a) -> t b -> a
fromMaybe :: Monoid a => Maybe a -> a
whenM :: Monoid a => Bool -> a -> a
unlessM :: Monoid a => Bool -> a -> a
isEmpty :: (Eq a, Monoid a) => a -> Bool
nonEmpty :: (Eq a, Monoid a) => a -> Bool
foldMapM :: (Monad m, Foldable f, Monoid b) => (a -> m b) -> f a -> m b

module U.Util.Text

-- | remove however many spaces prefix all of the lines of the input e.g.
--   stripMargin [here| def foo: blah blah |] == [here| def foo: blah blah
--   |]T
stripMargin :: Text -> Text

module U.Util.String
stripMargin :: String -> String

module U.Util.Timing
time :: MonadIO m => String -> m a -> m a
unsafeTime :: Monad m => String -> m a -> m a
