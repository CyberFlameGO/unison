-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Massiv (Массив) is an Array Library.
--   
--   Multi-dimensional Arrays with fusion, stencils and parallel
--   computation.
@package massiv
@version 0.6.1.0


module Data.Massiv.Core.Index

-- | Zero-dimension, i.e. a scalar. Can't really be used directly as there
--   is no instance of <a>Index</a> for it, and is included for
--   completeness.
data Ix0
Ix0 :: Ix0

-- | A type synonym for 1-dimensional index, i.e. <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 :: Ix1
--   5
--   </pre>
type Ix1 = Int

-- | This is a very handy pattern synonym to indicate that any arbitrary
--   <a>Integral</a> literal is an <a>Int</a>, e.g. a 1-dimensional index:
--   <tt>(Ix1 5) == (5 :: Int)</tt>
--   
--   <pre>
--   &gt;&gt;&gt; Ix1 5
--   5
--   
--   &gt;&gt;&gt; :t Ix1 5
--   Ix1 5 :: Ix1
--   </pre>
pattern Ix1 :: Int -> Ix1

-- | 2-dimensional index. This is also a base index for higher dimensions.
data Ix2
(:.) :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Ix2

-- | 2-dimensional index constructor. Useful when infix notation is
--   inconvenient. <tt>(Ix2 i j) == (i :. j)</tt>
pattern Ix2 :: Int -> Int -> Ix2
infixr 5 :.

-- | n-dimensional index. Needs a base case, which is the <a>Ix2</a>.
data IxN (n :: Nat)
(:>) :: {-# UNPACK #-} !Int -> !Ix (n - 1) -> IxN (n :: Nat)

-- | 3-dimensional index constructor. <tt>(Ix3 i j k) == (i :&gt; j :.
--   k)</tt>
pattern Ix3 :: Int -> Int -> Int -> Ix3

-- | 4-dimensional index constructor. <tt>(Ix4 i j k l) == (i :&gt; j :&gt;
--   k :. l)</tt>
pattern Ix4 :: Int -> Int -> Int -> Int -> Ix4

-- | 5-dimensional index constructor. <tt>(Ix5 i j k l m) == (i :&gt; j
--   :&gt; k :&gt; l :. m)</tt>
pattern Ix5 :: Int -> Int -> Int -> Int -> Int -> Ix5
infixr 5 :>

-- | 3-dimensional type synonym. Useful as a alternative to enabling
--   <tt>DataKinds</tt> and using type level Nats.
type Ix3 = IxN 3

-- | 4-dimensional type synonym.
type Ix4 = IxN 4

-- | 5-dimensional type synonym.
type Ix5 = IxN 5

-- | Defines n-dimensional index by relating a general <a>IxN</a> with few
--   base cases.
type family Ix (n :: Nat) = r | r -> n

-- | 1-dimensional type synonym for size.
type Sz1 = Sz Ix1

-- | 2-dimensional size type synonym.
type Sz2 = Sz Ix2

-- | 3-dimensional size type synonym.
type Sz3 = Sz Ix3

-- | 4-dimensional size type synonym.
type Sz4 = Sz Ix4

-- | 5-dimensional size type synonym.
type Sz5 = Sz Ix5

-- | <a>Sz</a> provides type safety guarantees preventing mixup with index,
--   which is used for looking into array cells, from the size, that
--   describes total number of elements along each dimension in the array.
--   Moreover the <tt>Sz</tt> constructor will prevent creation of invalid
--   sizes with negative numbers.
data Sz ix

-- | A safe bidirectional pattern synonym for <a>Sz</a> construction that
--   will make sure that none of the size elements are negative.
pattern Sz :: Index ix => ix -> Sz ix

-- | 1-dimensional size constructor. Especially useful with literals:
--   <tt>(Sz1 5) == Sz (5 :: Int)</tt>.
pattern Sz1 :: Ix1 -> Sz1

-- | 2-dimensional size constructor. <tt>(Sz2 i j) == Sz (i :. j)</tt>
pattern Sz2 :: Int -> Int -> Sz2

-- | 3-dimensional size constructor. <tt>(Sz3 i j k) == Sz (i :&gt; j :.
--   k)</tt>
pattern Sz3 :: Int -> Int -> Int -> Sz3

-- | 4-dimensional size constructor. <tt>(Sz4 i j k l) == Sz (i :&gt; j
--   :&gt; k :. l)</tt>
pattern Sz4 :: Int -> Int -> Int -> Int -> Sz4

-- | 5-dimensional size constructor. <tt>(Sz5 i j k l m) == Sz (i :&gt; j
--   :&gt; k :&gt; l :. m)</tt>
pattern Sz5 :: Int -> Int -> Int -> Int -> Int -> Sz5

-- | Function for unwrapping <a>Sz</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; unSz $ Sz3 1 2 3
--   1 :&gt; 2 :. 3
--   </pre>
unSz :: Sz ix -> ix

-- | An empty size with all elements in size equal to <tt>0</tt>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; zeroSz :: Sz5
--   Sz (0 :&gt; 0 :&gt; 0 :&gt; 0 :. 0)
--   </pre>
zeroSz :: Index ix => Sz ix

-- | A singleton size with all elements in size equal to <tt>1</tt>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; oneSz :: Sz3
--   Sz (1 :&gt; 1 :. 1)
--   </pre>
oneSz :: Index ix => Sz ix

-- | Same as <a>liftIndex</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; liftSz succ (Sz2 2 3)
--   Sz (3 :. 4)
--   </pre>
liftSz :: Index ix => (Int -> Int) -> Sz ix -> Sz ix

-- | Same as <a>liftIndex2</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; liftSz2 (-) (Sz2 2 3) (Sz2 3 1)
--   Sz (0 :. 2)
--   </pre>
liftSz2 :: Index ix => (Int -> Int -> Int) -> Sz ix -> Sz ix -> Sz ix

-- | Same as <a>consDim</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; consSz (Sz1 1) (Sz2 2 3) :: Sz3
--   Sz (1 :&gt; 2 :. 3)
--   </pre>
consSz :: Index ix => Sz1 -> Sz (Lower ix) -> Sz ix

-- | Same as <a>unconsDim</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; unconsSz $ Sz3 1 2 3
--   (Sz1 1,Sz (2 :. 3))
--   </pre>
unconsSz :: Index ix => Sz ix -> (Sz1, Sz (Lower ix))

-- | Same as <a>snocDim</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; snocSz (Sz2 2 3) (Sz1 1) :: Sz3
--   Sz (2 :&gt; 3 :. 1)
--   </pre>
snocSz :: Index ix => Sz (Lower ix) -> Sz1 -> Sz ix

-- | Same as <a>unsnocDim</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; unsnocSz $ Sz3 1 2 3
--   (Sz (1 :. 2),Sz1 3)
--   </pre>
unsnocSz :: Index ix => Sz ix -> (Sz (Lower ix), Sz1)

-- | Same as <a>setDimM</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; setSzM (Sz2 2 3) 2 (Sz1 1) :: IO Sz2
--   Sz (1 :. 3)
--   
--   &gt;&gt;&gt; setSzM (Sz2 2 3) 3 (Sz1 1) :: IO Sz2
--   *** Exception: IndexDimensionException: (Dim 3) for (2 :. 3)
--   </pre>
setSzM :: (MonadThrow m, Index ix) => Sz ix -> Dim -> Sz Int -> m (Sz ix)

-- | Same as <a>insertDimM</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; insertSzM (Sz2 2 3) 3 (Sz1 1) :: IO Sz3
--   Sz (1 :&gt; 2 :. 3)
--   
--   &gt;&gt;&gt; insertSzM (Sz2 2 3) 4 (Sz1 1) :: IO Sz3
--   *** Exception: IndexDimensionException: (Dim 4) for (2 :. 3)
--   </pre>
insertSzM :: (MonadThrow m, Index ix) => Sz (Lower ix) -> Dim -> Sz Int -> m (Sz ix)

-- | Same as <tt>pullOutDim</tt>, but for <a>Sz</a>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; pullOutSzM (Sz3 1 2 3) 3
--   (Sz1 1,Sz (2 :. 3))
--   
--   &gt;&gt;&gt; pullOutSzM (Sz3 1 2 3) 0
--   *** Exception: IndexDimensionException: (Dim 0) for (1 :&gt; 2 :. 3)
--   </pre>
pullOutSzM :: (MonadThrow m, Index ix) => Sz ix -> Dim -> m (Sz Ix1, Sz (Lower ix))

-- | Convert a size to a linear size.
toLinearSz :: Index ix => Sz ix -> Sz1

-- | Construct size from index while checking its correctness. Throws
--   <a>SizeNegativeException</a> and <a>SizeOverflowException</a>.
mkSzM :: (Index ix, MonadThrow m) => ix -> m (Sz ix)

-- | A way to select Array dimension at a value level.
newtype Dim
Dim :: Int -> Dim
[unDim] :: Dim -> Int

-- | A way to select Array dimension at a type level.
data Dimension (n :: Nat)
[DimN] :: (1 <= n, KnownNat n) => Dimension n

-- | Construct 1st dimension
pattern Dim1 :: Dimension 1

-- | Construct 2nd dimension
pattern Dim2 :: Dimension 2

-- | Construct 3rd dimension
pattern Dim3 :: Dimension 3

-- | Construct 4th dimension
pattern Dim4 :: Dimension 4

-- | Construct 5th dimension
pattern Dim5 :: Dimension 5

-- | A type level constraint that ensures index is indeed valid and that
--   supplied dimension can be safely used with it.
type IsIndexDimension ix n = (1 <= n, n <= Dimensions ix, Index ix, KnownNat n)
type family IsDimValid ix n :: Bool
type family ReportInvalidDim (dims :: Nat) (n :: Nat) isNotZero isLess :: Bool

-- | Stride provides a way to ignore elements of an array if an index is
--   divisible by a corresponding value in a stride. So, for a <tt>Stride
--   (i :. j)</tt> only elements with indices will be kept around:
--   
--   <pre>
--   ( 0 :. 0) ( 0 :. j) ( 0 :. 2j) ( 0 :. 3j) ...
--   ( i :. 0) ( i :. j) ( i :. 2j) ( i :. 3j) ...
--   (2i :. 0) (2i :. j) (2i :. 2j) (2i :. 3j) ...
--   ...
--   </pre>
--   
--   Only positive strides make sense, so <a>Stride</a> pattern synonym
--   constructor will prevent a user from creating a stride with negative
--   or zero values, thus promoting safety of the library.
--   
--   <h4><b>Examples:</b></h4>
--   
--   <ul>
--   <li>Default and minimal stride of <tt><a>Stride</a> (<a>pureIndex</a>
--   1)</tt> will have no affect and all elements will kept.</li>
--   </ul>
--   
--   <ul>
--   <li>If stride is <tt><a>Stride</a> 2</tt>, then every 2nd element
--   (i.e. with index 1, 3, 5, ..) will be skipped and only elemnts with
--   indices divisible by 2 will be kept around.</li>
--   <li>In case of two dimensions, if what you want is to keep all rows
--   divisible by 5, but keep every column intact then you'd use <tt>Stride
--   (5 :. 1)</tt>.</li>
--   </ul>
data Stride ix

-- | A safe bidirectional pattern synonym for <a>Stride</a> construction
--   that will make sure stride elements are always positive.
pattern Stride :: Index ix => ix -> Stride ix

-- | Just a helper function for unwrapping <a>Stride</a>.
unStride :: Stride ix -> ix

-- | Compute linear index with stride using the original size and index
toLinearIndexStride :: Index ix => Stride ix -> Sz ix -> ix -> Int

-- | Adjust starting index according to the stride
strideStart :: Index ix => Stride ix -> ix -> ix

-- | Adjust size according to the stride.
strideSize :: Index ix => Stride ix -> Sz ix -> Sz ix

-- | A default stride of <tt>1</tt>, where all elements are kept
oneStride :: Index ix => Stride ix

-- | Approach to be used near the borders during various transformations.
--   Whenever a function needs information not only about an element of
--   interest, but also about it's neighbors, it will go out of bounds near
--   the array edges, hence is this set of approaches that specify how to
--   handle such situation.
data Border e

-- | Fill in a constant element.
--   
--   <pre>
--              outside |  Array  | outside
--   (<a>Fill</a> 0) : 0 0 0 0 | 1 2 3 4 | 0 0 0 0
--   </pre>
Fill :: e -> Border e

-- | Wrap around from the opposite border of the array.
--   
--   <pre>
--              outside |  Array  | outside
--   <a>Wrap</a> :     1 2 3 4 | 1 2 3 4 | 1 2 3 4
--   </pre>
Wrap :: Border e

-- | Replicate the element at the edge.
--   
--   <pre>
--              outside |  Array  | outside
--   <a>Edge</a> :     1 1 1 1 | 1 2 3 4 | 4 4 4 4
--   </pre>
Edge :: Border e

-- | Mirror like reflection.
--   
--   <pre>
--              outside |  Array  | outside
--   <a>Reflect</a> :  4 3 2 1 | 1 2 3 4 | 4 3 2 1
--   </pre>
Reflect :: Border e

-- | Also mirror like reflection, but without repeating the edge element.
--   
--   <pre>
--              outside |  Array  | outside
--   <a>Continue</a> : 1 4 3 2 | 1 2 3 4 | 3 2 1 4
--   </pre>
Continue :: Border e

-- | Apply a border resolution technique to an index
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; handleBorderIndex (Fill 100) (Sz (2 :. 3)) id (2 :. 3)
--   100 :. 100
--   
--   &gt;&gt;&gt; handleBorderIndex Wrap (Sz (2 :. 3)) id (2 :. 3)
--   0 :. 0
--   
--   &gt;&gt;&gt; handleBorderIndex Edge (Sz (2 :. 3)) id (2 :. 3)
--   1 :. 2
--   </pre>
handleBorderIndex :: Index ix => Border e -> Sz ix -> (ix -> e) -> ix -> e

-- | This type family will always point to a type for a dimension that is
--   one lower than the type argument.
type family Lower ix :: *

-- | This is bread and butter of multi-dimensional array indexing. It is
--   unlikely that any of the functions in this class will be useful to a
--   regular user, unless general algorithms are being implemented that do
--   span multiple dimensions.
class (Eq ix, Ord ix, Show ix, NFData ix, Eq (Lower ix), Ord (Lower ix), Show (Lower ix), NFData (Lower ix), KnownNat (Dimensions ix)) => Index ix where {
    
    -- | Type level information on how many dimensions this index has.
    type family Dimensions ix :: Nat;
}

-- | What is the dimensionality of this index.
dimensions :: Index ix => proxy ix -> Dim

-- | Total number of elements in an array of this size.
totalElem :: Index ix => Sz ix -> Int

-- | Prepend a dimension to the index
consDim :: Index ix => Int -> Lower ix -> ix

-- | Take a dimension from the index from the outside
unconsDim :: Index ix => ix -> (Int, Lower ix)

-- | Apppend a dimension to the index
snocDim :: Index ix => Lower ix -> Int -> ix

-- | Take a dimension from the index from the inside
unsnocDim :: Index ix => ix -> (Lower ix, Int)

-- | Pull out value at specified dimension from the index, thus also
--   lowering it dimensionality.
pullOutDimM :: (Index ix, MonadThrow m) => ix -> Dim -> m (Int, Lower ix)

-- | Insert a dimension into the index
insertDimM :: (Index ix, MonadThrow m) => Lower ix -> Dim -> Int -> m ix

-- | Extract the value index has at specified dimension.
getDimM :: (Index ix, MonadThrow m) => ix -> Dim -> m Int

-- | Set the value for an index at specified dimension.
setDimM :: (Index ix, MonadThrow m) => ix -> Dim -> Int -> m ix

-- | Update the value for an index at specified dimension and return the
--   old value as well as the updated index.
modifyDimM :: (Index ix, MonadThrow m) => ix -> Dim -> (Int -> Int) -> m (Int, ix)

-- | Lift an <a>Int</a> to any index by replicating the value as many times
--   as there are dimensions.
pureIndex :: Index ix => Int -> ix

-- | Zip together two indices with a function
liftIndex2 :: Index ix => (Int -> Int -> Int) -> ix -> ix -> ix

-- | Map a function over an index
liftIndex :: Index ix => (Int -> Int) -> ix -> ix

-- | Perform a left fold over the index
foldlIndex :: Index ix => (a -> Int -> a) -> a -> ix -> a

-- | Perform a left fold over the index
foldlIndex :: (Index ix, Index (Lower ix)) => (a -> Int -> a) -> a -> ix -> a

-- | Check whether index is positive and is within the size.
isSafeIndex :: Index ix => Sz ix -> ix -> Bool

-- | Check whether index is positive and is within the size.
isSafeIndex :: (Index ix, Index (Lower ix)) => Sz ix -> ix -> Bool

-- | Convert linear index from size and index
toLinearIndex :: Index ix => Sz ix -> ix -> Ix1

-- | Convert linear index from size and index
toLinearIndex :: (Index ix, Index (Lower ix)) => Sz ix -> ix -> Ix1

-- | Convert linear index from size and index with an accumulator.
--   Currently is useless and will likley be removed in future versions.
toLinearIndexAcc :: Index ix => Ix1 -> ix -> ix -> Ix1

-- | Convert linear index from size and index with an accumulator.
--   Currently is useless and will likley be removed in future versions.
toLinearIndexAcc :: (Index ix, Index (Lower ix)) => Ix1 -> ix -> ix -> Ix1

-- | Compute an index from size and linear index
fromLinearIndex :: Index ix => Sz ix -> Ix1 -> ix

-- | Compute an index from size and linear index
fromLinearIndex :: (Index ix, Index (Lower ix)) => Sz ix -> Ix1 -> ix

-- | Compute an index from size and linear index using an accumulator, thus
--   trying to optimize for tail recursion while getting the index
--   computed.
fromLinearIndexAcc :: Index ix => ix -> Ix1 -> (Int, ix)

-- | Compute an index from size and linear index using an accumulator, thus
--   trying to optimize for tail recursion while getting the index
--   computed.
fromLinearIndexAcc :: (Index ix, Index (Lower ix)) => ix -> Ix1 -> (Ix1, ix)

-- | A way to make sure index is withing the bounds for the supplied size.
--   Takes two functions that will be invoked whenever index (2nd arg) is
--   outsize the supplied size (1st arg)
repairIndex :: Index ix => Sz ix -> ix -> (Sz Int -> Int -> Int) -> (Sz Int -> Int -> Int) -> ix

-- | A way to make sure index is withing the bounds for the supplied size.
--   Takes two functions that will be invoked whenever index (2nd arg) is
--   outsize the supplied size (1st arg)
repairIndex :: (Index ix, Index (Lower ix)) => Sz ix -> ix -> (Sz Int -> Int -> Int) -> (Sz Int -> Int -> Int) -> ix

-- | This function is what makes it possible to iterate over an array of
--   any dimension.
iterM :: (Index ix, Monad m) => ix -> ix -> ix -> (Int -> Int -> Bool) -> a -> (ix -> a -> m a) -> m a

-- | This function is what makes it possible to iterate over an array of
--   any dimension.
iterM :: (Index ix, Index (Lower ix), Monad m) => ix -> ix -> ix -> (Int -> Int -> Bool) -> a -> (ix -> a -> m a) -> m a

-- | Same as <a>iterM</a>, but don't bother with accumulator and return
--   value.
iterM_ :: (Index ix, Monad m) => ix -> ix -> ix -> (Int -> Int -> Bool) -> (ix -> m a) -> m ()

-- | Same as <a>iterM</a>, but don't bother with accumulator and return
--   value.
iterM_ :: (Index ix, Index (Lower ix), Monad m) => ix -> ix -> ix -> (Int -> Int -> Bool) -> (ix -> m a) -> m ()

-- | Index with all zeros
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; zeroIndex :: Ix4
--   0 :&gt; 0 :&gt; 0 :. 0
--   </pre>
zeroIndex :: Index ix => ix

-- | Index with all ones
oneIndex :: Index ix => ix

-- | Checks whether array with this size can hold at least one element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isNonEmpty (Sz3 1 0 2)
--   False
--   </pre>
isNonEmpty :: Index ix => Sz ix -> Bool

-- | Get the outmost dimension of the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; headDim (2 :&gt; 3 :&gt; 4 :. 5)
--   2
--   </pre>
headDim :: Index ix => ix -> Int

-- | Drop the outmost dimension from the index
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; tailDim (2 :&gt; 3 :&gt; 4 :. 5)
--   3 :&gt; 4 :. 5
--   </pre>
tailDim :: Index ix => ix -> Lower ix

-- | Get the innermost dimension from the index
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; lastDim (2 :&gt; 3 :&gt; 4 :. 5)
--   5
--   </pre>
lastDim :: Index ix => ix -> Int

-- | Drop the innermost dimension from the index
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; initDim (2 :&gt; 3 :&gt; 4 :. 5)
--   2 :&gt; 3 :. 4
--   </pre>
initDim :: Index ix => ix -> Lower ix

-- | Change the value from a specific dimension within the index. Throws
--   <a>IndexException</a>. See <a>getDimM</a> for a safer version and
--   <a>getDimension</a> for a type safe version.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; getDim' (2 :&gt; 3 :&gt; 4 :. 5) 3
--   3
--   
--   &gt;&gt;&gt; getDim' (2 :&gt; 3 :&gt; 4 :. 5) 0
--   *** Exception: IndexDimensionException: (Dim 0) for (2 :&gt; 3 :&gt; 4 :. 5)
--   </pre>
getDim' :: Index ix => ix -> Dim -> Int

-- | Change the value of a specific dimension within the index. Throws
--   <a>IndexException</a>. See <a>setDimM</a> for a safer version and
--   <a>setDimension</a> for a type safe version.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; setDim' (2 :&gt; 3 :&gt; 4 :. 5) 3 10
--   2 :&gt; 10 :&gt; 4 :. 5
--   </pre>
setDim' :: Index ix => ix -> Dim -> Int -> ix

-- | Update the value of a specific dimension within the index. Throws
--   <a>IndexException</a>. See <a>modifyDimM</a> for a safer version and
--   <a>modifyDimension</a> for a type safe version.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; modifyDim' (2 :&gt; 3 :&gt; 4 :. 5) 2 (+ 10)
--   (4,2 :&gt; 3 :&gt; 14 :. 5)
--   </pre>
modifyDim' :: Index ix => ix -> Dim -> (Int -> Int) -> (Int, ix)

-- | Remove a dimension from the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   λ&gt; dropDimM (2 :&gt; 3 :&gt; 4 :. 5) 3 :: Maybe Ix3 Just (2 :&gt; 4
--   :. 5) λ&gt; dropDimM (2 :&gt; 3 :&gt; 4 :. 5) 6 :: Maybe Ix3 Nothing
dropDimM :: (MonadThrow m, Index ix) => ix -> Dim -> m (Lower ix)

-- | Remove a dimension from the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; dropDim' (2 :&gt; 3 :&gt; 4 :. 5) 3
--   2 :&gt; 4 :. 5
--   
--   &gt;&gt;&gt; dropDim' (2 :&gt; 3 :&gt; 4 :. 5) 6
--   *** Exception: IndexDimensionException: (Dim 6) for (2 :&gt; 3 :&gt; 4 :. 5)
--   </pre>
dropDim' :: Index ix => ix -> Dim -> Lower ix

-- | Lower the dimension of the index by pulling the specified dimension.
--   Throws <a>IndexException</a>. See <a>pullOutDimM</a> for a safer
--   version and <a>pullOutDimension</a> for a type safe version.
--   
--   <h4><b>Examples</b></h4>
--   
--   λ&gt; pullOutDim' (2 :&gt; 3 :&gt; 4 :. 5) 3 (3,2 :&gt; 4 :. 5)
pullOutDim' :: Index ix => ix -> Dim -> (Int, Lower ix)

-- | Raise the dimension of the index by inserting one in the specified
--   dimension. Throws <a>IndexException</a>. See <a>insertDimM</a> for a
--   safer version and <a>insertDimension</a> for a type safe version.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; insertDim' (2 :&gt; 3 :&gt; 4 :. 5) 3 10 :: Ix5
--   2 :&gt; 3 :&gt; 10 :&gt; 4 :. 5
--   
--   &gt;&gt;&gt; insertDim' (2 :&gt; 3 :&gt; 4 :. 5) 11 10 :: Ix5
--   *** Exception: IndexDimensionException: (Dim 11) for (2 :&gt; 3 :&gt; 4 :. 5)
--   </pre>
insertDim' :: Index ix => Lower ix -> Dim -> Int -> ix

-- | Get the value level <a>Dim</a> from the type level equivalent.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fromDimension Dim4
--   (Dim 4)
--   
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; fromDimension (DimN :: Dimension 10)
--   (Dim 10)
--   </pre>
fromDimension :: KnownNat n => Dimension n -> Dim

-- | Type safe way to extract value of index at a particular dimension.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; getDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim2
--   4
--   </pre>
getDimension :: IsIndexDimension ix n => ix -> Dimension n -> Int

-- | Type safe way to set value of index at a particular dimension.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; setDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim4 10
--   10 :&gt; 3 :&gt; 4 :. 5
--   </pre>
setDimension :: IsIndexDimension ix n => ix -> Dimension n -> Int -> ix

-- | Type safe way to set value of index at a particular dimension.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; modifyDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim3 (+ 2)
--   (3,2 :&gt; 5 :&gt; 4 :. 5)
--   </pre>
modifyDimension :: IsIndexDimension ix n => ix -> Dimension n -> (Int -> Int) -> (Int, ix)

-- | Type safe way of dropping a particular dimension, thus lowering index
--   dimensionality.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; dropDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim2
--   2 :&gt; 3 :. 5
--   </pre>
dropDimension :: IsIndexDimension ix n => ix -> Dimension n -> Lower ix

-- | Type safe way of pulling out a particular dimension, thus lowering
--   index dimensionality and returning the value at specified dimension.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; pullOutDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim2
--   (4,2 :&gt; 3 :. 5)
--   </pre>
pullOutDimension :: IsIndexDimension ix n => ix -> Dimension n -> (Int, Lower ix)

-- | Type safe way of inserting a particular dimension, thus raising index
--   dimensionality.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; insertDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim5 10 :: Ix5
--   10 :&gt; 2 :&gt; 3 :&gt; 4 :. 5
--   
--   &gt;&gt;&gt; insertDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim4 10 :: Ix5
--   2 :&gt; 10 :&gt; 3 :&gt; 4 :. 5
--   
--   &gt;&gt;&gt; insertDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim3 10 :: Ix5
--   2 :&gt; 3 :&gt; 10 :&gt; 4 :. 5
--   
--   &gt;&gt;&gt; insertDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim2 10 :: Ix5
--   2 :&gt; 3 :&gt; 4 :&gt; 10 :. 5
--   
--   &gt;&gt;&gt; insertDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim1 10 :: Ix5
--   2 :&gt; 3 :&gt; 4 :&gt; 5 :. 10
--   </pre>
insertDimension :: IsIndexDimension ix n => Lower ix -> Dimension n -> Int -> ix

-- | Row-major iterator for the index. Same as <a>iterM</a>, but pure.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; iter (Ix1 0) 1000 1 (&lt;) 0 (+)
--   499500
--   
--   &gt;&gt;&gt; iter (0 :. 0) (2 :. 3) oneIndex (&lt;) 100 $ \ (i :. j) acc -&gt; (acc + i) * (j + 1)
--   3615
--   </pre>
iter :: Index ix => ix -> ix -> ix -> (Int -> Int -> Bool) -> a -> (ix -> a -> a) -> a

-- | Iterate over N-dimensional space linearly from start to end in
--   row-major fashion with an accumulator
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sz = Sz2 3 4
--   
--   &gt;&gt;&gt; iterLinearM sz 0 3 1 (&lt;) 100 $ \ k ix acc -&gt; print (fromLinearIndex sz k == ix) &gt;&gt; pure (acc + k)
--   True
--   True
--   True
--   103
--   </pre>
iterLinearM :: (Index ix, Monad m) => Sz ix -> Int -> Int -> Int -> (Int -> Int -> Bool) -> a -> (Int -> ix -> a -> m a) -> m a

-- | Same as <a>iterLinearM</a>, except without an accumulator.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sz = Sz2 3 4
--   
--   &gt;&gt;&gt; iterLinearM_ sz 0 3 1 (&lt;) $ \ k ix -&gt; print (toLinearIndex sz ix == k)
--   True
--   True
--   True
--   </pre>
iterLinearM_ :: (Index ix, Monad m) => Sz ix -> Int -> Int -> Int -> (Int -> Int -> Bool) -> (Int -> ix -> m ()) -> m ()

-- | Efficient loop with an accumulator
loop :: Int -> (Int -> Bool) -> (Int -> Int) -> a -> (Int -> a -> a) -> a

-- | Efficient Applicative loop. Result of each iteration is discarded.
loopA_ :: Applicative f => Int -> (Int -> Bool) -> (Int -> Int) -> (Int -> f a) -> f ()

-- | Efficient monadic loop with an accumulator
--   
--   <pre>
--   &gt;&gt;&gt; loopM 1 (&lt; 20) (+ 2) [] (\i a -&gt; Just (i:a))
--   Just [19,17,15,13,11,9,7,5,3,1]
--   </pre>
loopM :: Monad m => Int -> (Int -> Bool) -> (Int -> Int) -> a -> (Int -> a -> m a) -> m a

-- | Efficient monadic loop. Result of each iteration is discarded.
loopM_ :: Monad m => Int -> (Int -> Bool) -> (Int -> Int) -> (Int -> m a) -> m ()

-- | Similar to <a>loopM</a>, but slightly less efficient monadic loop with
--   an accumulator that reverses the direction of action application. eg:
--   
--   <pre>
--   &gt;&gt;&gt; loopDeepM 1 (&lt; 20) (+ 2) [] (\i a -&gt; Just (i:a))
--   Just [1,3,5,7,9,11,13,15,17,19]
--   </pre>
--   
--   Equivalent to:
--   
--   <pre>
--   &gt;&gt;&gt; loopM 19 (&gt;= 1) (subtract 2) [] (\i a -&gt; Just (i:a))
--   Just [1,3,5,7,9,11,13,15,17,19]
--   </pre>
loopDeepM :: Monad m => Int -> (Int -> Bool) -> (Int -> Int) -> a -> (Int -> a -> m a) -> m a

-- | Divide length in chunks and apply a function to the computed results
splitLinearly :: Int -> Int -> (Int -> Int -> a) -> a

-- | Iterator that expects an action that accepts starting linear index as
--   well as the ending
splitLinearlyM_ :: Monad m => Scheduler m () -> Int -> (Int -> Int -> m ()) -> m ()

-- | Interator that can be used to split computation amongst different
--   workers. For monadic generator see <a>splitLinearlyWithM_</a>.
splitLinearlyWith_ :: Monad m => Scheduler m () -> Int -> (Int -> b) -> (Int -> b -> m ()) -> m ()

-- | Interator that can be used to split computation jobs
splitLinearlyWithM_ :: Monad m => Scheduler m () -> Int -> (Int -> m b) -> (Int -> b -> m c) -> m ()

-- | Interator that can be used to split computation jobs
splitLinearlyWithStartAtM_ :: Monad m => Scheduler m () -> Int -> Int -> (Int -> m b) -> (Int -> b -> m c) -> m ()

-- | Interator that can be used to split computation jobs, while using a
--   stateful scheduler.
splitLinearlyWithStatefulM_ :: Monad m => SchedulerWS s m () -> Int -> (Int -> s -> m b) -> (Int -> b -> m c) -> m ()

-- | Another 1-dimensional index type synonym for <a>Int</a>, same as
--   <a>Ix1</a> and is here just for consistency.
type Ix1T = Int

-- | 2-dimensional index as tuple of <a>Int</a>s.
type Ix2T = (Int, Int)

-- | Convert an <a>Int</a> tuple to <a>Ix2</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; toIx2 (2, 3)
--   2 :. 3
--   </pre>
toIx2 :: Ix2T -> Ix2

-- | Convert an <a>Ix2</a> to <a>Int</a> tuple
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fromIx2 (2 :. 3)
--   (2,3)
--   </pre>
fromIx2 :: Ix2 -> Ix2T

-- | 3-dimensional index as 3-tuple of <a>Int</a>s.
type Ix3T = (Int, Int, Int)

-- | Convert a <a>Int</a> 3-tuple to <a>Ix3</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; toIx3 (1, 2, 3)
--   1 :&gt; 2 :. 3
--   </pre>
toIx3 :: Ix3T -> Ix3

-- | Convert an <a>Ix3</a> to <a>Int</a> 3-tuple
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fromIx3 (1 :&gt;  2 :. 3)
--   (1,2,3)
--   </pre>
fromIx3 :: Ix3 -> Ix3T

-- | 4-dimensional index as 4-tuple of <a>Int</a>s.
type Ix4T = (Int, Int, Int, Int)

-- | Convert a <a>Int</a> 4-tuple to <a>Ix4</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; toIx4 (1, 2, 3, 4)
--   1 :&gt; 2 :&gt; 3 :. 4
--   </pre>
toIx4 :: Ix4T -> Ix4

-- | Convert an <a>Ix4</a> to <a>Int</a> 4-tuple
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fromIx4 (1 :&gt; 2 :&gt; 3 :. 4)
--   (1,2,3,4)
--   </pre>
fromIx4 :: Ix4 -> Ix4T

-- | 5-dimensional index as 5-tuple of <a>Int</a>s.
type Ix5T = (Int, Int, Int, Int, Int)

-- | Convert a <a>Int</a> 5-tuple to <a>Ix5</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; toIx5 (1, 2, 3, 4, 5)
--   1 :&gt; 2 :&gt; 3 :&gt; 4 :. 5
--   </pre>
toIx5 :: Ix5T -> Ix5

-- | Convert an <a>Ix5</a> to <a>Int</a> 5-tuple
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fromIx5 (1 :&gt; 2 :&gt; 3 :&gt; 4 :. 5)
--   (1,2,3,4,5)
--   </pre>
fromIx5 :: Ix5 -> Ix5T

-- | Exceptions that get thrown when there is a problem with an index, size
--   or dimension.
data IndexException

-- | Index contains a zero value along one of the dimensions.
[IndexZeroException] :: Index ix => !ix -> IndexException

-- | Dimension is out of reach.
[IndexDimensionException] :: (NFData ix, Show ix, Typeable ix) => !ix -> !Dim -> IndexException

-- | Index is out of bounds.
[IndexOutOfBoundsException] :: Index ix => !Sz ix -> !ix -> IndexException

-- | Exception that indicates an issue with an array size.
data SizeException

-- | Two sizes are expected to be equal along some or all dimensions, but
--   they are not.
[SizeMismatchException] :: Index ix => !Sz ix -> !Sz ix -> SizeException

-- | Total number of elements does not match between the two sizes.
[SizeElementsMismatchException] :: (Index ix, Index ix') => !Sz ix -> !Sz ix' -> SizeException

-- | Described subregion is too big for the specified size.
[SizeSubregionException] :: Index ix => !Sz ix -> !ix -> !Sz ix -> SizeException

-- | An array with the size cannot contain any elements.
[SizeEmptyException] :: Index ix => !Sz ix -> SizeException

-- | Total number of elements is too large resulting in overflow.
[SizeOverflowException] :: Index ix => !Sz ix -> SizeException

-- | At least one dimensions contain a negative value.
[SizeNegativeException] :: Index ix => !Sz ix -> SizeException

-- | Exception that can happen upon conversion of a ragged type array into
--   the rectangular kind. Which means conversion from lists is susceptible
--   to this exception.
data ShapeException
DimTooShortException :: !Sz1 -> !Sz1 -> ShapeException
DimTooLongException :: ShapeException

-- | Throw <a>SizeElementsMismatchException</a> whenever number of elements
--   in both sizes do not match.
guardNumberOfElements :: (MonadThrow m, Index ix, Index ix') => Sz ix -> Sz ix' -> m ()

-- | This is used by <tt>INDEX_CHECK</tt> macro and thus used whenever the
--   <tt>unsafe-checks</tt> cabal flag is on.
indexWith :: Index ix => String -> Int -> String -> (arr -> Sz ix) -> (arr -> ix -> e) -> arr -> ix -> e
instance GHC.Show.Show e => GHC.Show.Show (Data.Massiv.Core.Index.Border e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Data.Massiv.Core.Index.Border e)
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData (Data.Massiv.Core.Index.Border e)


module Data.Massiv.Array.Mutable

-- | Get the size of a mutable array.
msize :: Mutable r ix e => MArray s r ix e -> Sz ix

-- | <i>O(1)</i> - Lookup an element in the mutable array. Returns
--   <a>Nothing</a> when index is out of bounds.
read :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> m (Maybe e)

-- | <i>O(1)</i> - Same as <a>read</a>, but throws
--   <a>IndexOutOfBoundsException</a> on an invalid index.
readM :: (Mutable r ix e, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> ix -> m e

-- | <i>O(1)</i> - Same as <a>read</a>, but throws
--   <a>IndexOutOfBoundsException</a> on an invalid index.

-- | <i>Deprecated: In favor of more general <a>readM</a></i>
read' :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> m e

-- | <i>O(1)</i> - Write an element into the cell of a mutable array.
--   Returns <a>False</a> when index is out of bounds.
write :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> e -> m Bool

-- | <i>O(1)</i> - Write an element into the cell of a mutable array. Same
--   as <a>write</a> function in case of an out of bounds index it is noop,
--   but unlike <a>write</a>, there is no information is returned about was
--   the writing of element successful or not. In other words, just like
--   <a>writeM</a>, but doesn't throw an exception.
write_ :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> e -> m ()

-- | <i>O(1)</i> - Same as <a>write</a>, but throws
--   <a>IndexOutOfBoundsException</a> on an invalid index.
writeM :: (Mutable r ix e, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> ix -> e -> m ()

-- | <i>O(1)</i> - Same as <a>write</a>, but lives in IO and throws
--   <a>IndexOutOfBoundsException</a> on invalid index.

-- | <i>Deprecated: In favor of more general <a>writeM</a></i>
write' :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> e -> m ()

-- | <i>O(1)</i> - Modify an element in the cell of a mutable array with a
--   supplied action. Returns the previous value, if index was not out of
--   bounds.
modify :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> ix -> m (Maybe e)

-- | <i>O(1)</i> - Same as <a>modify</a>, except that neither the previous
--   value, nor any information on whether the modification was successful
--   are returned. In other words, just like <a>modifyM_</a>, but doesn't
--   throw an exception.
modify_ :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> ix -> m ()

-- | <i>O(1)</i> - Modify an element in the cell of a mutable array with a
--   supplied action. Throws an <a>IndexOutOfBoundsException</a> exception
--   for invalid index and returns the previous value otherwise.
modifyM :: (Mutable r ix e, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> (e -> m e) -> ix -> m e

-- | <i>O(1)</i> - Same as <a>modifyM</a>, but discard the returned element
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Control.Monad.ST
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; runST $ newMArray' @P @Ix1 @Int (Sz1 3) &gt;&gt;= (\ma -&gt; modifyM_ ma (pure . (+10)) 1 &gt;&gt; freezeS ma)
--   Array P Seq (Sz1 3)
--     [ 0, 10, 0 ]
--   </pre>
modifyM_ :: (Mutable r ix e, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> (e -> m e) -> ix -> m ()

-- | <i>O(1)</i> - Same as <a>modify</a>, but throws an error if index is
--   out of bounds.

-- | <i>Deprecated: In favor of more general <a>modifyM</a></i>
modify' :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> e) -> ix -> m ()

-- | <i>O(1)</i> - Same as <a>swapM</a>, but instead of throwing an
--   exception returns <a>Nothing</a> when either one of the indices is out
--   of bounds and <a>Just</a> elements under those indices otherwise.
swap :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> ix -> m (Maybe (e, e))

-- | <i>O(1)</i> - Same as <a>swap</a>, but instead of returning
--   <a>Nothing</a> it does nothing. In other words, it is similar to
--   <a>swapM_</a>, but does not throw any exceptions.
swap_ :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> ix -> m ()

-- | <i>O(1)</i> - Swap two elements in a mutable array under the supplied
--   indices. Throws an <a>IndexOutOfBoundsException</a> when either one of
--   the indices is out of bounds and elements under those indices
--   otherwise.
swapM :: (Mutable r ix e, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> ix -> ix -> m (e, e)

-- | <i>O(1)</i> - Same as <a>swapM</a>, but discard the returned elements
swapM_ :: (Mutable r ix e, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> ix -> ix -> m ()

-- | <i>O(1)</i> - Same as <a>swap</a>, but throws an
--   <a>IndexOutOfBoundsException</a> on invalid indices.

-- | <i>Deprecated: In favor of more general <a>swapM</a></i>
swap' :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> ix -> m ()

-- | <i>O(n)</i> - Make a mutable copy of a pure array. Keep in mind that
--   both <a>freeze</a> and <a>thaw</a> trigger a copy of the full array.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; arr &lt;- fromListsM @U @Ix2 @Double Par [[12,21],[13,31]]
--   
--   &gt;&gt;&gt; marr &lt;- thaw arr
--   
--   &gt;&gt;&gt; modify marr (pure . (+ 10)) (1 :. 0)
--   Just 13.0
--   
--   &gt;&gt;&gt; freeze Par marr
--   Array U Par (Sz (2 :. 2))
--     [ [ 12.0, 21.0 ]
--     , [ 23.0, 31.0 ]
--     ]
--   </pre>
thaw :: forall r ix e m. (Mutable r ix e, MonadIO m) => Array r ix e -> m (MArray RealWorld r ix e)

-- | Same as <a>thaw</a>, but restrict computation to sequential only.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; thawS @P @Ix1 @Double [1..10]
--   
--   &gt;&gt;&gt; marr &lt;- thawS @P @Ix1 @Double [1..10]
--   
--   &gt;&gt;&gt; writeM marr 5 100
--   
--   &gt;&gt;&gt; freezeS marr
--   Array P Seq (Sz1 10)
--     [ 1.0, 2.0, 3.0, 4.0, 5.0, 100.0, 7.0, 8.0, 9.0, 10.0 ]
--   </pre>
thawS :: forall r ix e m. (Mutable r ix e, PrimMonad m) => Array r ix e -> m (MArray (PrimState m) r ix e)

-- | <i>O(n)</i> - Yield an immutable copy of the mutable array. Note that
--   mutable representations have to be the same.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; marr &lt;- newMArray @P @_ @Int (Sz2 2 6) 0
--   
--   &gt;&gt;&gt; forM_ (range Seq 0 (Ix2 1 4)) $ \ix -&gt; write marr ix 9
--   
--   &gt;&gt;&gt; freeze Seq marr
--   Array P Seq (Sz (2 :. 6))
--     [ [ 9, 9, 9, 9, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     ]
--   </pre>
freeze :: forall r ix e m. (Mutable r ix e, MonadIO m) => Comp -> MArray RealWorld r ix e -> m (Array r ix e)

-- | Same as <a>freeze</a>, but do the copy of supplied muable array
--   sequentially. Also, unlike <a>freeze</a> that has to be done in
--   <a>IO</a>, <a>freezeS</a> can be used with <a>ST</a>.
freezeS :: forall r ix e m. (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> m (Array r ix e)

-- | <i>O(n)</i> - Initialize a new mutable array. All elements will be set
--   to some default value. For boxed arrays in will be a thunk with
--   <a>Uninitialized</a> exception, while for others it will be simply
--   zeros.

-- | <i>Deprecated: In favor of a more robust and safer <a>newMArray</a> or
--   a more consistently named <a>newMArray</a>`</i>
new :: forall r ix e m. (Mutable r ix e, PrimMonad m) => Sz ix -> m (MArray (PrimState m) r ix e)

-- | Create new mutable array while initializing all elements to the
--   specified value.
newMArray :: (Mutable r ix e, PrimMonad m) => Sz ix -> e -> m (MArray (PrimState m) r ix e)

-- | <i>O(n)</i> - Initialize a new mutable array. All elements will be set
--   to some default value. For boxed arrays in will be a thunk with
--   <a>Uninitialized</a> exception, while for others it will be simply
--   zeros. This is a partial function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; marr &lt;- newMArray' (Sz2 2 6) :: IO (MArray RealWorld P Ix2 Int)
--   
--   &gt;&gt;&gt; freeze Seq marr
--   Array P Seq (Sz (2 :. 6))
--     [ [ 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     ]
--   </pre>
--   
--   Or using <tt>TypeApplications</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; newMArray' @P @Ix2 @Int (Sz2 2 6) &gt;&gt;= freezeS
--   Array P Seq (Sz (2 :. 6))
--     [ [ 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     ]
--   
--   &gt;&gt;&gt; newMArray' @B @_ @Int (Sz2 2 6) &gt;&gt;= (`readM` 1)
--   *** Exception: Uninitialized
--   </pre>
newMArray' :: forall r ix e m. (Mutable r ix e, PrimMonad m) => Sz ix -> m (MArray (PrimState m) r ix e)

-- | Just like <a>makeMArrayS</a>, but also accepts computation strategy
--   and runs in <a>IO</a>.
makeMArray :: forall r ix e m. (PrimMonad m, MonadUnliftIO m, Mutable r ix e) => Comp -> Sz ix -> (ix -> m e) -> m (MArray (PrimState m) r ix e)

-- | Just like <a>makeMArrayLinearS</a>, but also accepts computation
--   strategy and runs in <a>IO</a>.
makeMArrayLinear :: forall r ix e m. (PrimMonad m, MonadUnliftIO m, Mutable r ix e) => Comp -> Sz ix -> (Int -> m e) -> m (MArray (PrimState m) r ix e)

-- | Create a mutable array using an index aware generating action.
makeMArrayS :: forall r ix e m. (Mutable r ix e, PrimMonad m) => Sz ix -> (ix -> m e) -> m (MArray (PrimState m) r ix e)

-- | Same as <a>makeMArrayS</a>, but index supplied to the action is
--   row-major linear index.
makeMArrayLinearS :: forall r ix e m. (Mutable r ix e, PrimMonad m) => Sz ix -> (Int -> m e) -> m (MArray (PrimState m) r ix e)

-- | Create a new array by supplying an action that will fill the new blank
--   mutable array. Use <a>createArray</a> if you'd like to keep the result
--   of the filling function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; createArray_ @P @_ @Int Seq (Sz1 2) (\ s marr -&gt; scheduleWork s (writeM marr 0 10) &gt;&gt; scheduleWork s (writeM marr 1 11))
--   Array P Seq (Sz1 2)
--     [ 10, 11 ]
--   </pre>
createArray_ :: forall r ix e a m. (Mutable r ix e, PrimMonad m, MonadUnliftIO m) => Comp -> Sz ix -> (Scheduler m () -> MArray (PrimState m) r ix e -> m a) -> m (Array r ix e)

-- | Just like <a>createArray_</a>, but together with <a>Array</a> it
--   returns results of scheduled filling actions.
createArray :: forall r ix e a m b. (Mutable r ix e, PrimMonad m, MonadUnliftIO m) => Comp -> Sz ix -> (Scheduler m a -> MArray (PrimState m) r ix e -> m b) -> m ([a], Array r ix e)

-- | Create a new array by supplying an action that will fill the new blank
--   mutable array. Use <a>createArrayS</a> if you'd like to keep the
--   result of the filling function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; createArrayS_ @P @_ @Int (Sz1 2) (\ marr -&gt; write marr 0 10 &gt;&gt; write marr 1 12)
--   Array P Seq (Sz1 2)
--     [ 10, 12 ]
--   </pre>
createArrayS_ :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (MArray (PrimState m) r ix e -> m a) -> m (Array r ix e)

-- | Just like <a>createArray_</a>, but together with <a>Array</a> it
--   returns the result of the filling action.
createArrayS :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (MArray (PrimState m) r ix e -> m a) -> m (a, Array r ix e)

-- | Just like <a>createArrayS_</a>, but restricted to <a>ST</a>.
createArrayST_ :: forall r ix e a. Mutable r ix e => Sz ix -> (forall s. MArray s r ix e -> ST s a) -> Array r ix e

-- | Just like <a>createArrayS</a>, but restricted to <a>ST</a>.
createArrayST :: forall r ix e a. Mutable r ix e => Sz ix -> (forall s. MArray s r ix e -> ST s a) -> (a, Array r ix e)

-- | Just like <a>generateArrayS</a>, except this generator <b>will</b>
--   respect the supplied computation strategy, and for that reason it is
--   restricted to <a>IO</a>.
generateArray :: forall r ix e m. (MonadUnliftIO m, PrimMonad m, Mutable r ix e) => Comp -> Sz ix -> (ix -> m e) -> m (Array r ix e)

-- | Just like <a>generateArray</a>, except generating action will receive
--   a row-major linear index.
generateArrayLinear :: forall r ix e m. (MonadUnliftIO m, PrimMonad m, Mutable r ix e) => Comp -> Sz ix -> (Int -> m e) -> m (Array r ix e)

-- | Sequentially generate a pure array. Much like <a>makeArray</a> creates
--   a pure array this function will use <a>Mutable</a> interface to
--   generate a pure <a>Array</a> in the end, except that computation
--   strategy is set to <a>Seq</a>. Element producing function no longer
--   has to be pure but is a stateful action, becuase it is restricted to
--   <a>PrimMonad</a> thus allows for sharing the state between computation
--   of each element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; ref &lt;- newIORef (0 :: Int)
--   
--   &gt;&gt;&gt; generateArrayS (Sz1 6) (\ i -&gt; modifyIORef' ref (+i) &gt;&gt; print i &gt;&gt; pure i) :: IO (Array U Ix1 Int)
--   0
--   1
--   2
--   3
--   4
--   5
--   Array U Seq (Sz1 6)
--     [ 0, 1, 2, 3, 4, 5 ]
--   
--   &gt;&gt;&gt; readIORef ref
--   15
--   </pre>
generateArrayS :: forall r ix e m. (Mutable r ix e, PrimMonad m) => Sz ix -> (ix -> m e) -> m (Array r ix e)

-- | Same as <a>generateArray</a> but with action that accepts row-major
--   linear index.
generateArrayLinearS :: forall r ix e m. (Mutable r ix e, PrimMonad m) => Sz ix -> (Int -> m e) -> m (Array r ix e)

-- | Use per worker thread state while generating elements of the array.
--   Very useful for things that are not thread safe.
generateArrayWS :: forall r ix e s m. (Mutable r ix e, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> Sz ix -> (ix -> s -> m e) -> m (Array r ix e)

-- | Same as <a>generateArrayWS</a>, but use linear indexing instead.
generateArrayLinearWS :: forall r ix e s m. (Mutable r ix e, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> Sz ix -> (Int -> s -> m e) -> m (Array r ix e)

-- | Sequentially unfold an array from the left.
--   
--   <h4><b>Examples</b></h4>
--   
--   Create an array with Fibonacci numbers while performing and <a>IO</a>
--   action on the accumulator for each element of the array.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; unfoldrPrimM_ (Sz1 10) (\a@(f0, f1) -&gt; let fn = f0 + f1 in print a &gt;&gt; return (f0, (f1, fn))) (0, 1) :: IO (Array P Ix1 Int)
--   (0,1)
--   (1,1)
--   (1,2)
--   (2,3)
--   (3,5)
--   (5,8)
--   (8,13)
--   (13,21)
--   (21,34)
--   (34,55)
--   Array P Seq (Sz1 10)
--     [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ]
--   </pre>
unfoldrPrimM_ :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (a -> m (e, a)) -> a -> m (Array r ix e)

-- | Same as <a>unfoldrPrimM_</a> but do the unfolding with index aware
--   function.
iunfoldrPrimM_ :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (a -> ix -> m (e, a)) -> a -> m (Array r ix e)

-- | Just like <a>iunfoldrPrimM</a>, but do the unfolding with index aware
--   function.
unfoldrPrimM :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (a -> m (e, a)) -> a -> m (a, Array r ix e)

-- | Just like <a>iunfoldrPrimM_</a>, but also returns the final value of
--   the accumulator.
iunfoldrPrimM :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (a -> ix -> m (e, a)) -> a -> m (a, Array r ix e)

-- | Sequentially unfold an array from the left.
--   
--   <h4><b>Examples</b></h4>
--   
--   Create an array with Fibonacci numbers starting at the end while
--   performing and <a>IO</a> action on the accumulator for each element of
--   the array.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; unfoldlPrimM_ (Sz1 10) (\a@(f0, f1) -&gt; let fn = f0 + f1 in print a &gt;&gt; return ((f1, fn), f0)) (0, 1) :: IO (Array P Ix1 Int)
--   (0,1)
--   (1,1)
--   (1,2)
--   (2,3)
--   (3,5)
--   (5,8)
--   (8,13)
--   (13,21)
--   (21,34)
--   (34,55)
--   Array P Seq (Sz1 10)
--     [ 34, 21, 13, 8, 5, 3, 2, 1, 1, 0 ]
--   </pre>
unfoldlPrimM_ :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (a -> m (a, e)) -> a -> m (Array r ix e)

-- | Same as <a>unfoldlPrimM_</a> but do the unfolding with index aware
--   function.
iunfoldlPrimM_ :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (a -> ix -> m (a, e)) -> a -> m (Array r ix e)

-- | Just like <a>iunfoldlPrimM</a>, but do the unfolding with index aware
--   function.
unfoldlPrimM :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (a -> m (a, e)) -> a -> m (a, Array r ix e)

-- | Just like <a>iunfoldlPrimM_</a>, but also returns the final value of
--   the accumulator.
iunfoldlPrimM :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (a -> ix -> m (a, e)) -> a -> m (a, Array r ix e)

-- | Sequentially loop over a mutable array while modifying each element
--   with an action.
forPrimM :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> m ()

-- | Sequentially loop over a mutable array while reading each element and
--   applying an action to it. There is no mutation to the array, unless
--   the action itself modifies it.
forPrimM_ :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m ()) -> m ()

-- | Sequentially loop over a mutable array while modifying each element
--   with an index aware action.
iforPrimM :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (ix -> e -> m e) -> m ()

-- | Sequentially loop over a mutable array while reading each element and
--   applying an index aware action to it. There is no mutation to the
--   array, unless the action itself modifies it.
iforPrimM_ :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (ix -> e -> m ()) -> m ()

-- | Sequentially loop over a mutable array while modifying each element
--   with an index aware action.
iforLinearPrimM :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (Int -> e -> m e) -> m ()

-- | Sequentially loop over a mutable array while reading each element and
--   applying a linear index aware action to it. There is no mutation to
--   the array, unless the action itself modifies it.
iforLinearPrimM_ :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (Int -> e -> m ()) -> m ()

-- | Same as <a>withMArray_</a>, but allows to keep artifacts of scheduled
--   tasks.
withMArray :: (Mutable r ix e, MonadUnliftIO m) => Array r ix e -> (Scheduler m a -> MArray RealWorld r ix e -> m b) -> m ([a], Array r ix e)

-- | Create a copy of a pure array, mutate it in place and return its
--   frozen version. The big difference between <a>withMArrayS</a> is that
--   it's not only gonna respect the computation strategy supplied to it
--   while making a copy, but it will also pass extra argumens to the
--   action that suppose to modify the mutable copy of the source array.
--   These two extra arguments are:
--   
--   <ul>
--   <li>Number of capabilities derived from the <a>Comp</a>utation
--   strategy of the array.</li>
--   <li>An action that can be used to schedule arbitrary number of jobs
--   that will be executed in parallel.</li>
--   <li>And, of course, the mutable array itself.</li>
--   </ul>
withMArray_ :: (Mutable r ix e, MonadUnliftIO m) => Array r ix e -> (Scheduler m () -> MArray RealWorld r ix e -> m a) -> m (Array r ix e)

-- | Same as <a>withMArray_</a>, but the array supplied to this function
--   can be any loadable array. For that reason it will be faster if
--   supplied array is delayed.
withLoadMArray_ :: forall r ix e r' m b. (Load r' ix e, Mutable r ix e, MonadUnliftIO m) => Array r' ix e -> (Scheduler m () -> MArray RealWorld r ix e -> m b) -> m (Array r ix e)

-- | Create a copy of a pure array, mutate it in place and return its
--   frozen version. The important benefit over doing a manual <a>thawS</a>
--   followed by a <a>freezeS</a> is that an array will only be copied
--   once.
withMArrayS :: (Mutable r ix e, PrimMonad m) => Array r ix e -> (MArray (PrimState m) r ix e -> m a) -> m (a, Array r ix e)

-- | Same as <a>withMArrayS</a>, but will work with any loadable array.
withLoadMArrayS :: forall r ix e r' m a. (Load r' ix e, Mutable r ix e, PrimMonad m) => Array r' ix e -> (MArray (PrimState m) r ix e -> m a) -> m (a, Array r ix e)

-- | Same as <a>withMArrayS</a>, except it discards the value produced by
--   the supplied action
withMArrayS_ :: (Mutable r ix e, PrimMonad m) => Array r ix e -> (MArray (PrimState m) r ix e -> m a) -> m (Array r ix e)

-- | Same as <a>withMArrayS_</a>, but will work with any loadable array.
withLoadMArrayS_ :: forall r ix e r' m a. (Load r' ix e, Mutable r ix e, PrimMonad m) => Array r' ix e -> (MArray (PrimState m) r ix e -> m a) -> m (Array r ix e)

-- | Same as <a>withMArrayS</a> but in <a>ST</a>. This is not only pure,
--   but also the safest way to do mutation to the array.
withMArrayST :: Mutable r ix e => Array r ix e -> (forall s. MArray s r ix e -> ST s a) -> (a, Array r ix e)

-- | Same as <a>withMArrayST</a>, but works with any loadable array.
withLoadMArrayST :: forall r ix e r' a. (Load r' ix e, Mutable r ix e) => Array r' ix e -> (forall s. MArray s r ix e -> ST s a) -> (a, Array r ix e)

-- | Same as <a>withMArrayS</a> but in <a>ST</a>. This is not only pure,
--   but also the safest way to do mutation to the array.
withMArrayST_ :: Mutable r ix e => Array r ix e -> (forall s. MArray s r ix e -> ST s a) -> Array r ix e

-- | Same as <a>withMArrayST_</a>, but works with any loadable array.
withLoadMArrayST_ :: forall r ix e r' a. (Load r' ix e, Mutable r ix e) => Array r' ix e -> (forall s. MArray s r ix e -> ST s a) -> Array r ix e

-- | Initialize mutable array to some default value.
initialize :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> m ()

-- | Create new mutable array while initializing all elements to some
--   default value.
initializeNew :: (Mutable r ix e, PrimMonad m) => Maybe e -> Sz ix -> m (MArray (PrimState m) r ix e)
class (Construct r ix e, Manifest r ix e) => Mutable r ix e
data family MArray s r ix e :: *

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld

-- | Compute an Array while loading the results into the supplied mutable
--   target array. Number of elements for arrays must agree, otherwise
--   <a>SizeElementsMismatchException</a> exception is thrown.
computeInto :: (Load r' ix' e, Mutable r ix e, MonadIO m) => MArray RealWorld r ix e -> Array r' ix' e -> m ()

-- | Load a pure array into the newly created mutable array, while
--   respecting computation startegy.
loadArray :: forall r ix e r' m. (Load r' ix e, Mutable r ix e, MonadIO m) => Array r' ix e -> m (MArray RealWorld r ix e)

-- | Load sequentially a pure array into the newly created mutable array.
loadArrayS :: forall r ix e r' m. (Load r' ix e, Mutable r ix e, PrimMonad m) => Array r' ix e -> m (MArray (PrimState m) r ix e)


module Data.Massiv.Core.Operations
class Num e => FoldNumeric r e

-- | Compute sum of all elements in the array
sumArray :: (FoldNumeric r e, Index ix) => Array r ix e -> e

-- | Compute product of all elements in the array
productArray :: (FoldNumeric r e, Index ix) => Array r ix e -> e

-- | Raise each element in the array to some non-negative power and sum the
--   results
powerSumArray :: (FoldNumeric r e, Index ix) => Array r ix e -> Int -> e

-- | Compute dot product without any extraneous checks
unsafeDotProduct :: (FoldNumeric r e, Index ix) => Array r ix e -> Array r ix e -> e

-- | Fold over an array
foldArray :: (FoldNumeric r e, Index ix) => (e -> e -> e) -> e -> Array r ix e -> e
defaultPowerSumArray :: (Source r ix e, Num e) => Array r ix e -> Int -> e
defaultUnsafeDotProduct :: (Num e, Source r ix e) => Array r ix e -> Array r ix e -> e
defaultFoldArray :: Source r ix e => (e -> e -> e) -> e -> Array r ix e -> e
class FoldNumeric r e => Numeric r e
plusScalar :: (Numeric r e, Index ix) => Array r ix e -> e -> Array r ix e
minusScalar :: (Numeric r e, Index ix) => Array r ix e -> e -> Array r ix e
scalarMinus :: (Numeric r e, Index ix) => e -> Array r ix e -> Array r ix e
multiplyScalar :: (Numeric r e, Index ix) => Array r ix e -> e -> Array r ix e
absPointwise :: (Numeric r e, Index ix) => Array r ix e -> Array r ix e
additionPointwise :: (Numeric r e, Index ix) => Array r ix e -> Array r ix e -> Array r ix e
subtractionPointwise :: (Numeric r e, Index ix) => Array r ix e -> Array r ix e -> Array r ix e
multiplicationPointwise :: (Numeric r e, Index ix) => Array r ix e -> Array r ix e -> Array r ix e

-- | Raise each element of the array to the power
powerPointwise :: (Numeric r e, Index ix) => Array r ix e -> Int -> Array r ix e
unsafeLiftArray :: (Numeric r e, Index ix) => (e -> e) -> Array r ix e -> Array r ix e
unsafeLiftArray2 :: (Numeric r e, Index ix) => (e -> e -> e) -> Array r ix e -> Array r ix e -> Array r ix e
defaultUnsafeLiftArray :: (Construct r ix e, Source r ix e) => (e -> e) -> Array r ix e -> Array r ix e
defaultUnsafeLiftArray2 :: (Construct r ix e, Source r ix e) => (e -> e -> e) -> Array r ix e -> Array r ix e -> Array r ix e
class (Numeric r e, Floating e) => NumericFloat r e
divideScalar :: (NumericFloat r e, Index ix) => Array r ix e -> e -> Array r ix e
scalarDivide :: (NumericFloat r e, Index ix) => e -> Array r ix e -> Array r ix e
divisionPointwise :: (NumericFloat r e, Index ix) => Array r ix e -> Array r ix e -> Array r ix e
recipPointwise :: (NumericFloat r e, Index ix) => Array r ix e -> Array r ix e
sqrtPointwise :: (NumericFloat r e, Index ix) => Array r ix e -> Array r ix e


module Data.Massiv.Core.List
data LN
data L
L :: L

-- | The array family. Representations <tt>r</tt> describe how data is
--   arranged or computed. All arrays have a common property that each
--   index <tt>ix</tt> always maps to the same unique element, even if that
--   element does not yet exist in memory and the arry has to be computed
--   in order to get access to that element. Data is always arranged in a
--   nested row-major fashion, depth of which is controlled by
--   <tt><tt>Rank</tt> ix</tt>.
data family Array r ix e :: *

-- | Construct an array backed by linked lists from any source array
toListArray :: (Construct L ix e, Source r ix e) => Array r ix e -> Array L ix e

-- | Helper function for declaring <a>Show</a> instances for arrays
showsArrayPrec :: forall r r' ix ix' e. (Ragged L ix' e, Load r ix e, Source r' ix' e, Show e) => (Array r ix e -> Array r' ix' e) -> Int -> Array r ix e -> ShowS

-- | Helper function for declaring <a>Show</a> instances for arrays
showArrayList :: Show arr => [arr] -> String -> String
type family ListItem ix e :: *
instance Data.Massiv.Core.Common.Nested Data.Massiv.Core.List.L ix e
instance Data.Massiv.Core.Common.Nested Data.Massiv.Core.List.LN ix e => GHC.Exts.IsList (Data.Massiv.Core.Common.Array Data.Massiv.Core.List.L ix e)
instance Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L Data.Massiv.Core.Index.Internal.Ix1 e
instance (Data.Massiv.Core.Index.Internal.Index ix, Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L ix e) => Data.Massiv.Core.Common.Load Data.Massiv.Core.List.L ix e
instance (Data.Massiv.Core.Index.Internal.Index ix, Data.Massiv.Core.Common.Load Data.Massiv.Core.List.L ix e, Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L ix e) => Data.Massiv.Core.Common.Load Data.Massiv.Core.List.LN ix e
instance (Data.Massiv.Core.Index.Internal.Index ix, Data.Massiv.Core.Index.Internal.Index (Data.Massiv.Core.Index.Internal.Lower ix), Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L (Data.Massiv.Core.Index.Internal.Lower ix) e, Data.Massiv.Core.Common.Elt Data.Massiv.Core.List.L ix e GHC.Types.~ Data.Massiv.Core.Common.Array Data.Massiv.Core.List.L (Data.Massiv.Core.Index.Internal.Lower ix) e, Data.Massiv.Core.Common.Elt Data.Massiv.Core.List.LN ix e GHC.Types.~ Data.Massiv.Core.Common.Array Data.Massiv.Core.List.LN (Data.Massiv.Core.Index.Internal.Lower ix) e, GHC.Types.Coercible (Data.Massiv.Core.Common.Elt Data.Massiv.Core.List.LN ix e) [Data.Massiv.Core.Common.Elt Data.Massiv.Core.List.LN (Data.Massiv.Core.Index.Internal.Lower ix) e]) => Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L ix e
instance Data.Massiv.Core.Common.Construct Data.Massiv.Core.List.L Data.Massiv.Core.Index.Internal.Ix1 e
instance (Data.Massiv.Core.Index.Internal.Index ix, Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L ix e, Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L (Data.Massiv.Core.Index.Internal.Lower ix) e, Data.Massiv.Core.Common.Elt Data.Massiv.Core.List.L ix e GHC.Types.~ Data.Massiv.Core.Common.Array Data.Massiv.Core.List.L (Data.Massiv.Core.Index.Internal.Lower ix) e) => Data.Massiv.Core.Common.Construct Data.Massiv.Core.List.L ix e
instance (Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L ix e, GHC.Show.Show e) => GHC.Show.Show (Data.Massiv.Core.Common.Array Data.Massiv.Core.List.L ix e)
instance (Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L ix e, GHC.Show.Show e) => GHC.Show.Show (Data.Massiv.Core.Common.Array Data.Massiv.Core.List.LN ix e)
instance Data.Massiv.Core.Common.OuterSlice Data.Massiv.Core.List.L Data.Massiv.Core.Index.Internal.Ix1 e
instance Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L ix e => Data.Massiv.Core.Common.OuterSlice Data.Massiv.Core.List.L ix e
instance Data.Massiv.Core.Common.Stream Data.Massiv.Core.List.L Data.Massiv.Core.Index.Internal.Ix1 e
instance (Data.Massiv.Core.Common.Elt Data.Massiv.Core.List.LN ix e GHC.Types.~ Data.Massiv.Core.Common.Array Data.Massiv.Core.List.LN (Data.Massiv.Core.Index.Internal.Lower ix) e, Data.Massiv.Core.List.ListItem ix e GHC.Types.~ [Data.Massiv.Core.List.ListItem (Data.Massiv.Core.Index.Internal.Lower ix) e], GHC.Types.Coercible (Data.Massiv.Core.Common.Elt Data.Massiv.Core.List.LN ix e) (Data.Massiv.Core.List.ListItem ix e)) => Data.Massiv.Core.Common.Nested Data.Massiv.Core.List.LN ix e
instance Data.Massiv.Core.Common.Nested Data.Massiv.Core.List.LN ix e => GHC.Exts.IsList (Data.Massiv.Core.Common.Array Data.Massiv.Core.List.LN ix e)
instance Data.Massiv.Core.Common.Construct Data.Massiv.Core.List.LN Data.Massiv.Core.Index.Internal.Ix1 e
instance Data.Massiv.Core.Common.Nested Data.Massiv.Core.List.LN Data.Massiv.Core.Index.Internal.Ix1 e
instance Data.Massiv.Core.Common.Stream Data.Massiv.Core.List.LN Data.Massiv.Core.Index.Internal.Ix1 e


module Data.Massiv.Core

-- | The array family. Representations <tt>r</tt> describe how data is
--   arranged or computed. All arrays have a common property that each
--   index <tt>ix</tt> always maps to the same unique element, even if that
--   element does not yet exist in memory and the arry has to be computed
--   in order to get access to that element. Data is always arranged in a
--   nested row-major fashion, depth of which is controlled by
--   <tt><tt>Rank</tt> ix</tt>.
data family Array r ix e :: *

-- | Type synonym for a single dimension array, or simply a flat vector.
type Vector r e = Array r Ix1 e

-- | Type synonym for a single dimension mutable array, or simply a flat
--   mutable vector.
type MVector s r e = MArray s r Ix1 e

-- | Type synonym for a two-dimentsional array, or simply a matrix.
type Matrix r e = Array r Ix2 e

-- | Type synonym for a two-dimentsional mutable array, or simply a mutable
--   matrix.
type MMatrix s r e = MArray s r Ix2 e
type family Elt r ix e :: *

-- | Array types that can be constructed.
class (Typeable r, Index ix) => Construct r ix e

-- | Any array that can be computed and loaded into memory
class (Typeable r, Index ix) => Load r ix e where {
    type family R r :: *;
    type R r = r;
}

-- | Load an array into memory.
loadArrayM :: (Load r ix e, Monad m) => Scheduler m () -> Array r ix e -> (Int -> e -> m ()) -> m ()

-- | Load an array into memory, just like <a>loadArrayM</a>. Except it also
--   accepts a function that is potentially optimized for setting many
--   cells in a region to the same value
loadArrayWithSetM :: (Load r ix e, Monad m) => Scheduler m () -> Array r ix e -> (Ix1 -> e -> m ()) -> (Ix1 -> Sz1 -> e -> m ()) -> m ()
class Load r ix e => Stream r ix e
toStream :: Stream r ix e => Array r ix e -> Steps Id e
toStreamIx :: Stream r ix e => Array r ix e -> Steps Id (ix, e)

-- | Arrays that can be used as source to practically any manipulation
--   function.
class (Resize r ix, Load r ix e) => Source r ix e
class Index ix => Resize r ix
class Load r ix e => Extract r ix e
class Load r ix e => StrideLoad r ix e

-- | Load an array into memory with stride. Default implementation requires
--   an instance of <a>Source</a>.
loadArrayWithStrideM :: (StrideLoad r ix e, Monad m) => Scheduler m () -> Stride ix -> Sz ix -> Array r ix e -> (Int -> e -> m ()) -> m ()

-- | Load an array into memory with stride. Default implementation requires
--   an instance of <a>Source</a>.
loadArrayWithStrideM :: (StrideLoad r ix e, Source r ix e, Monad m) => Scheduler m () -> Stride ix -> Sz ix -> Array r ix e -> (Int -> e -> m ()) -> m ()
class Load r ix e => Slice r ix e
class Load r ix e => OuterSlice r ix e
class Load r ix e => InnerSlice r ix e

-- | Manifest arrays are backed by actual memory and values are looked up
--   versus computed as it is with delayed arrays. Because of this fact
--   indexing functions <tt>(<a>!</a>)</tt>, <tt>(<a>!?</a>)</tt>, etc. are
--   constrained to manifest arrays only.
class Source r ix e => Manifest r ix e
class (Construct r ix e, Manifest r ix e) => Mutable r ix e
class Construct r ix e => Ragged r ix e
class Nested r ix e
fromNested :: Nested r ix e => NestedStruct r ix e -> Array r ix e
toNested :: Nested r ix e => Array r ix e -> NestedStruct r ix e
type family NestedStruct r ix e :: *
data L
L :: L
data LN
type family ListItem ix e :: *

-- | Main type for scheduling work. See <a>withScheduler</a> or
--   <a>withScheduler_</a> for ways to construct and use this data type.
data Scheduler (m :: Type -> Type) a

-- | This is a wrapper around <a>Scheduler</a>, but it also keeps a
--   separate state for each individual worker. See <a>withSchedulerWS</a>
--   or <a>withSchedulerWS_</a> for ways to construct and use this data
--   type.
data SchedulerWS s (m :: Type -> Type) a

-- | Computation strategy to use when scheduling work.
data Comp

-- | Sequential computation
Seq :: Comp

-- | Schedule workers to run on specific capabilities. Specifying an empty
--   list <tt><a>ParOn</a> []</tt> or using <a>Par</a> will result in
--   utilization of all available capabilities.
ParOn :: ![Int] -> Comp

-- | Specify the number of workers that will be handling all the jobs.
--   Difference from <a>ParOn</a> is that workers can jump between cores.
--   Using <tt><a>ParN</a> 0</tt> will result in using all available
--   capabilities.
ParN :: {-# UNPACK #-} !Word16 -> Comp

-- | Parallel computation using all available cores. Same as
--   <tt><a>ParOn</a> []</tt>
pattern Par :: Comp

-- | Parallel computation using all available cores. Same as
--   <tt><a>ParN</a> 0</tt>
pattern Par' :: Comp

-- | Append computation strategy using <a>Comp</a>'s <a>Monoid</a>
--   instance.
appComp :: (Construct r ix e, Load r ix e) => Comp -> Array r ix e -> Array r ix e

-- | Each worker is capable of keeping it's own state, that can be share
--   for different schedulers, but not at the same time. In other words
--   using the same <a>WorkerStates</a> on <a>withSchedulerS</a>
--   concurrently will result in an error. Can be initialized with
--   <a>initWorkerStates</a>
data WorkerStates s

-- | Initialize a separate state for each worker.
initWorkerStates :: MonadIO m => Comp -> (WorkerId -> m s) -> m (WorkerStates s)
class Num e => FoldNumeric r e
class FoldNumeric r e => Numeric r e
class (Numeric r e, Floating e) => NumericFloat r e

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow (m :: Type -> Type)

-- | Throw an exception. Note that this throws when this action is run in
--   the monad <tt>m</tt>, not when it is applied. It is a generalization
--   of <a>Control.Exception</a>'s <a>throwIO</a>.
--   
--   Should satisfy the law:
--   
--   <pre>
--   throwM e &gt;&gt; f = throwM e
--   </pre>
throwM :: (MonadThrow m, Exception e) => e -> m a

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
throw :: forall (r :: RuntimeRep) (a :: TYPE r) e. Exception e => e -> a

-- | Exceptions that get thrown when there is a problem with an index, size
--   or dimension.
data IndexException

-- | Index contains a zero value along one of the dimensions.
[IndexZeroException] :: Index ix => !ix -> IndexException

-- | Dimension is out of reach.
[IndexDimensionException] :: (NFData ix, Show ix, Typeable ix) => !ix -> !Dim -> IndexException

-- | Index is out of bounds.
[IndexOutOfBoundsException] :: Index ix => !Sz ix -> !ix -> IndexException

-- | Exception that indicates an issue with an array size.
data SizeException

-- | Two sizes are expected to be equal along some or all dimensions, but
--   they are not.
[SizeMismatchException] :: Index ix => !Sz ix -> !Sz ix -> SizeException

-- | Total number of elements does not match between the two sizes.
[SizeElementsMismatchException] :: (Index ix, Index ix') => !Sz ix -> !Sz ix' -> SizeException

-- | Described subregion is too big for the specified size.
[SizeSubregionException] :: Index ix => !Sz ix -> !ix -> !Sz ix -> SizeException

-- | An array with the size cannot contain any elements.
[SizeEmptyException] :: Index ix => !Sz ix -> SizeException

-- | Total number of elements is too large resulting in overflow.
[SizeOverflowException] :: Index ix => !Sz ix -> SizeException

-- | At least one dimensions contain a negative value.
[SizeNegativeException] :: Index ix => !Sz ix -> SizeException

-- | Exception that can happen upon conversion of a ragged type array into
--   the rectangular kind. Which means conversion from lists is susceptible
--   to this exception.
data ShapeException
DimTooShortException :: !Sz1 -> !Sz1 -> ShapeException
DimTooLongException :: ShapeException
newtype ImpossibleException
ImpossibleException :: SomeException -> ImpossibleException
throwImpossible :: Exception e => e -> a
throwEither :: Either SomeException a -> a

-- | An error that gets thrown when an unitialized element of a boxed array
--   gets accessed. Can only happen when array was constructed with
--   <tt>unsafeNew</tt>.
data Uninitialized
Uninitialized :: Uninitialized

-- | Throw <a>SizeElementsMismatchException</a> whenever number of elements
--   in both sizes do not match.
guardNumberOfElements :: (MonadThrow m, Index ix, Index ix') => Sz ix -> Sz ix' -> m ()

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException

-- | Monads which allow their actions to be run in <a>IO</a>.
--   
--   While <a>MonadIO</a> allows an <a>IO</a> action to be lifted into
--   another monad, this class captures the opposite concept: allowing you
--   to capture the monadic context. Note that, in order to meet the laws
--   given below, the intuition is that a monad must have no monadic state,
--   but may have monadic context. This essentially limits
--   <a>MonadUnliftIO</a> to <a>ReaderT</a> and <a>IdentityT</a>
--   transformers on top of <a>IO</a>.
--   
--   Laws. For any value <tt>u</tt> returned by <a>askUnliftIO</a>, it must
--   meet the monad transformer laws as reformulated for
--   <tt>MonadUnliftIO</tt>:
--   
--   <ul>
--   <li><pre>unliftIO u . return = return</pre></li>
--   <li><pre>unliftIO u (m &gt;&gt;= f) = unliftIO u m &gt;&gt;= unliftIO
--   u . f</pre></li>
--   </ul>
--   
--   Instances of <tt>MonadUnliftIO</tt> must also satisfy the idempotency
--   law:
--   
--   <ul>
--   <li><pre>askUnliftIO &gt;&gt;= \u -&gt; (liftIO . unliftIO u) m =
--   m</pre></li>
--   </ul>
--   
--   This law showcases two properties. First, <a>askUnliftIO</a> doesn't
--   change the monadic context, and second, <tt>liftIO . unliftIO u</tt>
--   is equivalent to <tt>id</tt> IF called in the same monadic context as
--   <a>askUnliftIO</a>.
class MonadIO m => MonadUnliftIO (m :: Type -> Type)

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Class of monads which can perform primitive state-transformer actions
class Monad m => PrimMonad (m :: Type -> Type) where {
    
    -- | State token type
    type family PrimState (m :: Type -> Type);
}


module Data.Massiv.Array.Mutable.Atomic

-- | Atomically read an <a>Int</a> element from the array
atomicReadIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> m (Maybe Int)

-- | Atomically write an <a>Int</a> element int the array. Returns
--   <a>True</a> if supplied index was correct and write was successfull.
atomicWriteIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Bool

-- | Atomically modify an <a>Int</a> element of the array. Returns the old
--   value, unless the supplied index was out of bounds.
atomicModifyIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> (Int -> Int) -> m (Maybe Int)

-- | Atomically add to an <a>Int</a> element in the array. Returns the old
--   value.
atomicAddIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically subtract from an <a>Int</a> element in the array. Returns
--   the old value.
atomicSubIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically AND an <a>Int</a> element in the array. Returns the old
--   value.
atomicAndIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically NAND an <a>Int</a> element in the array. Returns the old
--   value.
atomicNandIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically OR an <a>Int</a> element in the array. Returns the old
--   value.
atomicOrIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically XOR an <a>Int</a> element in the array. Returns the old
--   value.
atomicXorIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically CAS (Compare-and-Swap) an <a>Int</a> in the array. Returns
--   the old value.
casIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> Int -> m (Maybe Int)


module Data.Massiv.Array.Manifest.Vector

-- | In case when resulting array representation matches the one of
--   vector's it will do a <i>O(1)</i> - conversion using
--   <a>castFromVector</a>, otherwise Vector elements will be copied into a
--   new array. Will throw an error if length of resulting array doesn't
--   match the source vector length.
fromVectorM :: (MonadThrow m, Typeable v, Vector v a, Mutable (ARepr v) ix a, Mutable r ix a) => Comp -> Sz ix -> v a -> m (Array r ix a)

-- | Just like <a>fromVectorM</a>, but will throw an exception on a
--   mismatched size.
fromVector' :: (Typeable v, Vector v a, Mutable (ARepr v) ix a, Mutable r ix a) => Comp -> Sz ix -> v a -> Array r ix a

-- | <i>O(1)</i> - conversion from vector to an array with a corresponding
--   representation. Will return <a>Nothing</a> if there is a size mismatch
--   or if some non-standard vector type is supplied. Is suppplied is the
--   boxed <a>Vector</a> then it's all elements will be evaluated toWHNF,
--   therefore complexity will be <i>O(n)</i>
castFromVector :: forall v r ix e. (Vector v e, Typeable v, Mutable r ix e, ARepr v ~ r) => Comp -> Sz ix -> v e -> Maybe (Array r ix e)

-- | Convert an array into a vector. Will perform a cast if resulting
--   vector is of compatible representation, otherwise memory copy will
--   occur.
--   
--   <h4><b>Examples</b></h4>
--   
--   In this example a <a>S</a>torable Array is created and then casted
--   into a Storable <a>Vector</a> in costant time:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; toVector (makeArrayR S Par (Sz2 5 6) (\(i :. j) -&gt; i + j)) :: VS.Vector Int
--   [0,1,2,3,4,5,1,2,3,4,5,6,2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9]
--   </pre>
--   
--   While in this example <a>S</a>torable Array will first be converted
--   into <a>U</a>nboxed representation in <a>Par</a>allel and only after
--   that will be coverted into Unboxed <a>Vector</a> in constant time.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; toVector (makeArrayR S Par (Sz2 5 6) (\(i :. j) -&gt; i + j)) :: VU.Vector Int
--   [0,1,2,3,4,5,1,2,3,4,5,6,2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9]
--   </pre>
toVector :: forall r ix e v. (Manifest r ix e, Mutable (ARepr v) ix e, Vector v e, VRepr (ARepr v) ~ v) => Array r ix e -> v e

-- | <i>O(1)</i> - conversion from <a>Mutable</a> array to a corresponding
--   vector. Will return <a>Nothing</a> only if source array representation
--   was not one of <a>B</a>, <a>N</a>, <a>P</a>, <a>S</a> or <a>U</a>.
castToVector :: forall v r ix e. (Mutable r ix e, VRepr r ~ v) => Array r ix e -> Maybe (v e)

-- | Match vector type to array representation
type family ARepr (v :: * -> *) :: *

-- | Match array representation to a vector type
type family VRepr r :: * -> *


module Data.Massiv.Array.Manifest

-- | Manifest arrays are backed by actual memory and values are looked up
--   versus computed as it is with delayed arrays. Because of this fact
--   indexing functions <tt>(<a>!</a>)</tt>, <tt>(<a>!?</a>)</tt>, etc. are
--   constrained to manifest arrays only.
class Source r ix e => Manifest r ix e

-- | <i>O(1)</i> - Conversion of <a>Manifest</a> arrays to <a>M</a>
--   representation.
toManifest :: Manifest r ix e => Array r ix e -> Array M ix e

-- | General Manifest representation
data M

-- | Array representation for Boxed elements. This structure is element and
--   spine strict, but elements are strict to Weak Head Normal Form (WHNF)
--   only.
data B
B :: B

-- | Array representation for Boxed elements. This data structure is lazy
--   with respect to its elements, but is strict with respect to the spine.
data BL
BL :: BL

-- | Array representation for Boxed elements. This structure is element and
--   spine strict, and elements are always in Normal Form (NF), therefore
--   <a>NFData</a> instance is required.
data BN
BN :: BN

-- | Type and pattern <a>N</a> have been added for backwards compatibility
--   and will be replaced in the future in favor of <a>BN</a>
type N = BN
pattern N :: N

-- | An error that gets thrown when an unitialized element of a boxed array
--   gets accessed. Can only happen when array was constructed with
--   <tt>unsafeNew</tt>.
data Uninitialized
Uninitialized :: Uninitialized

-- | <i>O(n)</i> - Perform a row-major search starting at <tt>0</tt> for an
--   element. Returns the index of the first occurance of an element or
--   <a>Nothing</a> if a predicate could not be satisifed after it was
--   applyied to all elements of the array.
findIndex :: Manifest r ix e => (e -> Bool) -> Array r ix e -> Maybe ix

-- | <i>O(1)</i> - Cast a strict boxed array into a lazy boxed array.
toLazyArray :: Array B ix e -> Array BL ix e

-- | <i>O(n)</i> - Evaluate all elements of a boxed lazy array to weak head
--   normal form
evalLazyArray :: Index ix => Array BL ix e -> Array B ix e

-- | <i>O(n)</i> - Evaluate all elements of a boxed lazy array to normal
--   form
forceLazyArray :: (NFData e, Index ix) => Array BL ix e -> Array N ix e

-- | <i>O(1)</i> - Converts array from <a>N</a> to <a>B</a> representation.
unwrapNormalForm :: Array N ix e -> Array B ix e

-- | <i>O(n)</i> - Compute all elements of a boxed array to NF (normal
--   form)
evalNormalForm :: (Index ix, NFData e) => Array B ix e -> Array N ix e

-- | <i>O(1)</i> - Unwrap boxed array. This will discard any possible
--   slicing that has been applied to the array.
unwrapLazyArray :: Array BL ix e -> Array e

-- | <i>O(1)</i> - Wrap a boxed array.
wrapLazyArray :: Array e -> Vector BL e

-- | <i>O(1)</i> - Unwrap boxed array. This will discard any possible
--   slicing that has been applied to the array.
unwrapArray :: Array B ix e -> Array e

-- | <i>O(n)</i> - Wrap a boxed array and evaluate all elements to a WHNF.
evalArray :: Comp -> Array e -> Vector B e

-- | <i>O(1)</i> - Unwrap mutable boxed array. This will discard any
--   possible slicing that has been applied to the array.
unwrapMutableArray :: MArray s B ix e -> MutableArray s e

-- | <i>O(1)</i> - Unwrap mutable boxed lazy array. This will discard any
--   possible slicing that has been applied to the array.
unwrapMutableLazyArray :: MArray s BL ix e -> MutableArray s e

-- | <i>O(n)</i> - Wrap mutable boxed array and evaluate all elements to
--   WHNF.
evalMutableArray :: PrimMonad m => MutableArray (PrimState m) e -> m (MArray (PrimState m) B Ix1 e)

-- | <i>O(1)</i> - Unwrap a fully evaluated boxed array. This will discard
--   any possible slicing that has been applied to the array.
unwrapNormalFormArray :: Array N ix e -> Array e

-- | <i>O(n)</i> - Wrap a boxed array and evaluate all elements to a Normal
--   Form (NF).
evalNormalFormArray :: NFData e => Comp -> Array e -> Array N Ix1 e

-- | <i>O(1)</i> - Unwrap a fully evaluated mutable boxed array. This will
--   discard any possible slicing that has been applied to the array.
unwrapNormalFormMutableArray :: MArray s N ix e -> MutableArray s e

-- | <i>O(n)</i> - Wrap mutable boxed array and evaluate all elements to
--   NF.
evalNormalFormMutableArray :: (PrimMonad m, NFData e) => MutableArray (PrimState m) e -> m (MArray (PrimState m) N Ix1 e)

-- | <i>O(1)</i> - Converts a boxed <a>Array</a> into a <a>Vector</a>.
toBoxedVector :: Index ix => Array BL ix a -> Vector a

-- | <i>O(1)</i> - Converts a boxed <a>MArray</a> into a <a>MVector</a>.
toBoxedMVector :: Index ix => MArray s BL ix a -> MVector s a

-- | <i>O(1)</i> - Cast a boxed vector without touching any elements.
fromBoxedVector :: Vector a -> Vector BL a

-- | <i>O(1)</i> - Convert mutable boxed vector to a lazy mutable boxed
--   array. Both keep pointing to the same memory
fromBoxedMVector :: MVector s a -> MArray s BL Ix1 a

-- | <i>O(n)</i> - Convert a boxed vector and evaluate all elements to
--   WHNF. Computation strategy will be respected during evaluation
evalBoxedVector :: Comp -> Vector a -> Array B Ix1 a

-- | <i>O(n)</i> - Convert mutable boxed vector and evaluate all elements
--   to WHNF sequentially. Both keep pointing to the same memory
evalBoxedMVector :: PrimMonad m => MVector (PrimState m) a -> m (MArray (PrimState m) B Ix1 a)

-- | Representation for <a>Prim</a>itive elements
data P
P :: P

-- | Class of types supporting primitive array operations. This includes
--   interfacing with GC-managed memory (functions suffixed with
--   <tt>ByteArray#</tt>) and interfacing with unmanaged memory (functions
--   suffixed with <tt>Addr#</tt>). Endianness is platform-dependent.
class Prim a

-- | <i>O(n)</i> - Ensure that the size matches the internal
--   <a>ByteArray</a>. If not make a copy of the slice and return it as
--   <a>ByteArray</a>
toByteArray :: (Index ix, Prim e) => Array P ix e -> ByteArray

-- | <i>O(1)</i> - Unwrap Ensure that the size matches the internal
--   <a>ByteArray</a>.
toByteArrayM :: (Prim e, Index ix, MonadThrow m) => Array P ix e -> m ByteArray

-- | <i>O(1)</i> - Extract the internal <a>ByteArray</a>. This will ignore
--   any possible slicing that has been applied to the array. Use
--   <a>toByteArray</a> in order to preserve slicing or
--   <a>unwrapByteArrayOffset</a> to get ahold of the offset
unwrapByteArray :: Array P ix e -> ByteArray

-- | <i>O(1)</i> - Extract potential linear offset into the underlying
--   <a>ByteArray</a>, which can also be extracted with
--   <a>unwrapByteArray</a>.
unwrapByteArrayOffset :: Array P ix e -> Int

-- | <i>O(1)</i> - Construct a flat Array from <a>ByteArray</a>
fromByteArray :: forall e. Prim e => Comp -> ByteArray -> Array P Ix1 e

-- | <i>O(1)</i> - Construct a primitive array from the <a>ByteArray</a>.
--   Will return <a>Nothing</a> if number of elements doesn't match.
fromByteArrayM :: (MonadThrow m, Index ix, Prim e) => Comp -> Sz ix -> ByteArray -> m (Array P ix e)

-- | <i>O(1)</i> - Construct a primitive array from the <a>ByteArray</a>.
--   Will return <a>Nothing</a> if number of elements doesn't match.
fromByteArrayOffsetM :: (MonadThrow m, Index ix, Prim e) => Comp -> Sz ix -> Int -> ByteArray -> m (Array P ix e)

-- | <i>O(n)</i> - Try to cast a mutable array to <a>MutableByteArray</a>,
--   if sizes do not match make a copy. Returns <a>True</a> if an array was
--   converted without a copy, in which case it means that the source at
--   the resulting array are still pointing to the same location in memory.
toMutableByteArray :: forall ix e m. (Prim e, Index ix, PrimMonad m) => MArray (PrimState m) P ix e -> m (Bool, MutableByteArray (PrimState m))

-- | <i>O(1)</i> - Extract the internal <a>MutableByteArray</a>. This will
--   discard any possible slicing that has been applied to the array.
unwrapMutableByteArray :: MArray s P ix e -> MutableByteArray s

-- | <i>O(1)</i> - Extract the linear offset into underlying
--   <a>MutableByteArray</a>, which can aslo be extracted with
--   <a>unwrapMutableByteArray</a>.
unwrapMutableByteArrayOffset :: MArray s P ix e -> Int

-- | <i>O(1)</i> - Construct a flat Array from <a>MutableByteArray</a>
fromMutableByteArray :: forall e s. Prim e => MutableByteArray s -> MArray s P Ix1 e

-- | <i>O(1)</i> - Construct a primitive mutable array from the
--   <a>MutableByteArray</a>. Will throw
--   <a>SizeElementsMismatchException</a> if number of elements doesn't
--   match.
fromMutableByteArrayM :: (MonadThrow m, Index ix, Prim e) => Sz ix -> MutableByteArray s -> m (MArray s P ix e)

-- | <i>O(1)</i> - Construct a primitive mutable array from the
--   <a>MutableByteArray</a>. Will throw
--   <a>SizeElementsMismatchException</a> if number of elements doesn't
--   match.
fromMutableByteArrayOffsetM :: (MonadThrow m, Index ix, Prim e) => Sz ix -> Ix1 -> MutableByteArray s -> m (MArray s P ix e)

-- | <i>O(1)</i> - Cast a primitive array to a primitive vector.
toPrimitiveVector :: Index ix => Array P ix e -> Vector e

-- | <i>O(1)</i> - Cast a mutable primitive array to a mutable primitive
--   vector.
toPrimitiveMVector :: Index ix => MArray s P ix e -> MVector s e

-- | <i>O(1)</i> - Cast a primitive vector to a primitive array.
fromPrimitiveVector :: Vector e -> Array P Ix1 e

-- | <i>O(1)</i> - Cast a mutable primitive vector to a mutable primitive
--   array.
fromPrimitiveMVector :: MVector s e -> MArray s P Ix1 e

-- | Representation for <a>Storable</a> elements
data S
S :: S

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class Storable a

-- | Very similar to <tt><a>computeAs</a> <a>S</a></tt> except load the
--   source array into memory allocated with <tt>malloc</tt> on C heap. It
--   can potentially be useful when iteroperating with some C programs.
mallocCompute :: forall r ix e. (Source r ix e, Storable e) => Array r ix e -> IO (Array S ix e)

-- | Allocate memory on C heap with <tt>malloc</tt> and copy the source
--   array over.
mallocCopy :: forall ix e. (Index ix, Storable e) => Array S ix e -> IO (Array S ix e)

-- | <i>O(1)</i> - Unwrap storable array and pull out the underlying
--   storable vector.
toStorableVector :: Array S ix e -> Vector e

-- | <i>O(1)</i> - Unwrap storable mutable array and pull out the
--   underlying storable mutable vector.
toStorableMVector :: MArray s S ix e -> MVector s e

-- | <i>O(1)</i> - Cast a storable vector to a storable array.
fromStorableVector :: Storable e => Comp -> Vector e -> Array S Ix1 e

-- | <i>O(1)</i> - Cast a mutable storable vector to a mutable storable
--   array.
fromStorableMVector :: MVector s e -> MArray s S Ix1 e

-- | A pointer to the beginning of the mutable array.
withPtr :: (MonadUnliftIO m, Storable a) => MArray RealWorld S ix a -> (Ptr a -> m b) -> m b

-- | Representation for <tt>Unbox</tt>ed elements
data U
U :: U
class (Vector Vector a, MVector MVector a) => Unbox a

-- | <i>O(1)</i> - Unwrap unboxed array and pull out the underlying unboxed
--   vector.
toUnboxedVector :: Array U ix e -> Vector e

-- | <i>O(1)</i> - Unwrap unboxed mutable array and pull out the underlying
--   unboxed mutable vector.
toUnboxedMVector :: MArray s U ix e -> MVector s e

-- | <i>O(1)</i> - Wrap an unboxed vector and produce an unboxed flat
--   array.
fromUnboxedVector :: Unbox e => Comp -> Vector e -> Array U Ix1 e

-- | <i>O(1)</i> - Wrap an unboxed mutable vector and produce a mutable
--   unboxed flat array.
fromUnboxedMVector :: Unbox e => MVector s e -> MArray s U Ix1 e

-- | <i>O(1)</i> - Convert a strict ByteString into a manifest array. Will
--   return <a>Nothing</a> if length doesn't match the total number of
--   elements of new array.
fromByteString :: Comp -> ByteString -> Array M Ix1 Word8

-- | <i>O(1)</i> - Cast a strict <a>ByteString</a> into a <a>S</a>torable
--   array
castFromByteString :: Comp -> ByteString -> Array S Ix1 Word8

-- | <i>O(n)</i> - Convert any source array into a strict
--   <a>ByteString</a>. In case when the source array is actually storable,
--   no memory copy will occur.
toByteString :: Load r ix Word8 => Array r ix Word8 -> ByteString

-- | <i>O(1)</i> - Cast a <a>S</a>torable array into a strict
--   <a>ByteString</a>
castToByteString :: Array S ix Word8 -> ByteString

-- | <i>O(n)</i> - Conversion of array monoidally into a ByteString
--   <a>Builder</a>.
toBuilder :: Source r ix e => (e -> Builder) -> Array r ix e -> Builder

-- | <i>O(1)</i> - Cast a storable array of <a>Word8</a> to ByteString
--   <a>Builder</a>.
castToBuilder :: Array S ix Word8 -> Builder


module Data.Massiv.Array.Numeric
class FoldNumeric r e => Numeric r e
class (Numeric r e, Floating e) => NumericFloat r e

-- | Add a scalar to each element of the array. Array is on the left.
(.+) :: (Index ix, Numeric r e) => Array r ix e -> e -> Array r ix e
infixl 6 .+

-- | Add a scalar to each element of the array. Array is on the right.
(+.) :: (Index ix, Numeric r e) => e -> Array r ix e -> Array r ix e
infixl 6 +.

-- | Add two arrays together pointwise. Same as <a>!+!</a> but produces
--   monadic computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   array sizes do not match.
(.+.) :: (Load r ix e, Numeric r e, MonadThrow m) => Array r ix e -> Array r ix e -> m (Array r ix e)
infixl 6 .+.

-- | Add two arrays together pointwise. Prefer to use monadic version of
--   this function <a>.+.</a> whenever possible, because it is better to
--   avoid partial functions.
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let a1 = Ix1 0 ... 10
--   
--   &gt;&gt;&gt; let a2 = Ix1 20 ... 30
--   
--   &gt;&gt;&gt; a1 !+! a2
--   Array D Seq (Sz1 11)
--     [ 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40 ]
--   </pre>
(!+!) :: (Load r ix e, Numeric r e) => Array r ix e -> Array r ix e -> Array r ix e
infixl 6 !+!

-- | Subtract a scalar from each element of the array. Array is on the
--   left.
(.-) :: (Index ix, Numeric r e) => Array r ix e -> e -> Array r ix e
infixl 6 .-

-- | Subtract each element of the array from a scalar. Array is on the
--   right.
(-.) :: (Index ix, Numeric r e) => e -> Array r ix e -> Array r ix e
infixl 6 -.

-- | Subtract two arrays pointwise. Same as <a>!-!</a> but produces monadic
--   computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   array sizes do not match.
(.-.) :: (Load r ix e, Numeric r e, MonadThrow m) => Array r ix e -> Array r ix e -> m (Array r ix e)
infixl 6 .-.

-- | Subtract one array from another pointwise. Prefer to use monadic
--   version of this function <a>.-.</a> whenever possible, because it is
--   better to avoid partial functions.
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let a1 = Ix1 0 ... 10
--   
--   &gt;&gt;&gt; let a2 = Ix1 20 ... 30
--   
--   &gt;&gt;&gt; a1 !-! a2
--   Array D Seq (Sz1 11)
--     [ -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20 ]
--   </pre>
(!-!) :: (Load r ix e, Numeric r e) => Array r ix e -> Array r ix e -> Array r ix e
infixl 6 !-!

-- | Multiply each element of the array by a scalar value. Scalar is on the
--   right.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr = Ix1 20 ..: 25
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz1 5)
--     [ 20, 21, 22, 23, 24 ]
--   
--   &gt;&gt;&gt; arr .* 10
--   Array D Seq (Sz1 5)
--     [ 200, 210, 220, 230, 240 ]
--   </pre>
(.*) :: (Index ix, Numeric r e) => Array r ix e -> e -> Array r ix e
infixl 7 .*

-- | Multiply each element of the array by a scalar value. Scalar is on the
--   left.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr = Ix1 20 ..: 25
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz1 5)
--     [ 20, 21, 22, 23, 24 ]
--   
--   &gt;&gt;&gt; 10 *. arr
--   Array D Seq (Sz1 5)
--     [ 200, 210, 220, 230, 240 ]
--   </pre>
(*.) :: (Index ix, Numeric r e) => e -> Array r ix e -> Array r ix e
infixl 7 *.

-- | Multiply two arrays together pointwise. Same as <a>!*!</a> but
--   produces monadic computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   array sizes do not match.
(.*.) :: (Load r ix e, Numeric r e, MonadThrow m) => Array r ix e -> Array r ix e -> m (Array r ix e)
infixl 7 .*.

-- | Multiplication of two arrays pointwise, i.e. <a>Hadamard product</a>.
--   Prefer to use monadic version of this function <a>.*.</a> whenever
--   possible, because it is better to avoid partial functions.
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let a1 = Ix1 0 ... 10
--   
--   &gt;&gt;&gt; let a2 = Ix1 20 ... 30
--   
--   &gt;&gt;&gt; a1 !*! a2
--   Array D Seq (Sz1 11)
--     [ 0, 21, 44, 69, 96, 125, 156, 189, 224, 261, 300 ]
--   </pre>
(!*!) :: (Load r ix e, Numeric r e) => Array r ix e -> Array r ix e -> Array r ix e
infixl 7 !*!

-- | Raise each element of the array to a power.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr = Ix1 20 ..: 25
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz1 5)
--     [ 20, 21, 22, 23, 24 ]
--   
--   &gt;&gt;&gt; arr .^ 3
--   Array D Seq (Sz1 5)
--     [ 8000, 9261, 10648, 12167, 13824 ]
--   </pre>
(.^) :: (Index ix, Numeric r e) => Array r ix e -> Int -> Array r ix e
infixr 8 .^

-- | Dot product of two vectors.
--   
--   <ul>
--   <li><i>Partial</i> Throws an impure exception when lengths of vectors
--   do not match</li>
--   </ul>
(!.!) :: (Numeric r e, Source r Ix1 e) => Vector r e -> Vector r e -> e

-- | Dot product of two vectors.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   lengths of vectors do not match
dotM :: (FoldNumeric r e, Source r Ix1 e, MonadThrow m) => Vector r e -> Vector r e -> m e

-- | Multiply a matrix by a column vector. Same as <a>!&gt;&lt;</a> but
--   produces monadic computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   inner dimensions of arrays do not match.
(.><) :: (MonadThrow m, FoldNumeric r e, Source r Ix1 e, Source r Ix2 e) => Matrix r e -> Vector r e -> m (Vector D e)

-- | Multiply a matrix by a column vector
--   
--   <ul>
--   <li><i>Partial</i> Throws impure exception when inner dimensions do
--   not agree</li>
--   </ul>
(!><) :: (Numeric r e, Source r Ix1 e, Source r Ix2 e) => Matrix r e -> Vector r e -> Vector D e

-- | Multiply matrix by a column vector. Same as <a>.&gt;&lt;</a> but
--   returns computed version of a vector
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   inner dimensions of arrays do not match.
multiplyMatrixByVector :: (MonadThrow m, Numeric r e, Mutable r Ix1 e, Mutable r Ix2 e) => Matrix r e -> Vector r e -> m (Vector r e)

-- | Multiply a row vector by a matrix. Same as <a>&gt;&lt;!</a> but
--   produces monadic computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   inner dimensions of arrays do not match.
(><.) :: (MonadThrow m, Numeric r e, Mutable r Ix1 e, Mutable r Ix2 e) => Vector r e -> Matrix r e -> m (Vector r e)

-- | Multiply a row vector by a matrix.
--   
--   <ul>
--   <li><i>Partial</i> Throws impure exception when inner dimensions do
--   not agree</li>
--   </ul>
(><!) :: (Numeric r e, Mutable r Ix1 e, Mutable r Ix2 e) => Vector r e -> Matrix r e -> Vector r e

-- | Multiply a row vector by a matrix. Same as <a>&gt;&lt;.</a> but
--   returns computed vector instead of a delayed one.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   inner dimensions of arrays do not match.
multiplyVectorByMatrix :: (MonadThrow m, Numeric r e, Mutable r Ix1 e, Mutable r Ix2 e) => Vector r e -> Matrix r e -> m (Vector r e)

-- | Matrix multiplication. Same as <a>!&gt;&lt;!</a> but produces monadic
--   computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   inner dimensions of arrays do not match.
(.><.) :: (Numeric r e, Mutable r Ix2 e, MonadThrow m) => Matrix r e -> Matrix r e -> m (Matrix r e)

-- | Multiply two matrices together.
--   
--   <ul>
--   <li><i>Partial</i> Inner dimension must agree</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; a1 = makeArrayR P Seq (Sz2 5 6) $ \(i :. j) -&gt; i + j
--   
--   &gt;&gt;&gt; a2 = makeArrayR P Seq (Sz2 6 5) $ \(i :. j) -&gt; i - j
--   
--   &gt;&gt;&gt; a1 !&gt;&lt;! a2
--   Array P Seq (Sz (5 :. 5))
--     [ [ 55, 40, 25, 10, -5 ]
--     , [ 70, 49, 28, 7, -14 ]
--     , [ 85, 58, 31, 4, -23 ]
--     , [ 100, 67, 34, 1, -32 ]
--     , [ 115, 76, 37, -2, -41 ]
--     ]
--   </pre>
(!><!) :: (Numeric r e, Mutable r Ix2 e) => Matrix r e -> Matrix r e -> Matrix r e

-- | Synonym for <a>.&gt;&lt;.</a>
multiplyMatrices :: (Numeric r e, Mutable r Ix2 e, MonadThrow m) => Matrix r e -> Matrix r e -> m (Matrix r e)

-- | Computes the matrix-matrix multiplication where second matrix is
--   transposed (i.e. M x N')
--   
--   <pre>
--   m1 .&gt;&lt;. transpose m2 == multiplyMatricesTransposed m1 m2
--   </pre>
multiplyMatricesTransposed :: (Numeric r e, Manifest r Ix2 e, MonadThrow m) => Matrix r e -> Matrix r e -> m (Matrix D e)

-- | Compute L2 norm of an array.
normL2 :: (Floating e, FoldNumeric r e, Source r ix e) => Array r ix e -> e

-- | Create an indentity matrix.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; identityMatrix 5
--   Array DL Seq (Sz (5 :. 5))
--     [ [ 1, 0, 0, 0, 0 ]
--     , [ 0, 1, 0, 0, 0 ]
--     , [ 0, 0, 1, 0, 0 ]
--     , [ 0, 0, 0, 1, 0 ]
--     , [ 0, 0, 0, 0, 1 ]
--     ]
--   </pre>
identityMatrix :: Num e => Sz1 -> Matrix DL e

-- | Create a lower triangular (L in LU decomposition) matrix of size
--   <tt>NxN</tt>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; lowerTriangular Seq 5 (\(i :. j) -&gt; i + j)
--   Array DL Seq (Sz (5 :. 5))
--     [ [ 0, 0, 0, 0, 0 ]
--     , [ 1, 2, 0, 0, 0 ]
--     , [ 2, 3, 4, 0, 0 ]
--     , [ 3, 4, 5, 6, 0 ]
--     , [ 4, 5, 6, 7, 8 ]
--     ]
--   </pre>
lowerTriangular :: Num e => Comp -> Sz1 -> (Ix2 -> e) -> Matrix DL e

-- | Create an upper triangular (U in LU decomposition) matrix of size
--   <tt>NxN</tt>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; upperTriangular Par 5 (\(i :. j) -&gt; i + j)
--   Array DL Par (Sz (5 :. 5))
--     [ [ 0, 1, 2, 3, 4 ]
--     , [ 0, 2, 3, 4, 5 ]
--     , [ 0, 0, 4, 5, 6 ]
--     , [ 0, 0, 0, 6, 7 ]
--     , [ 0, 0, 0, 0, 8 ]
--     ]
--   </pre>
upperTriangular :: Num e => Comp -> Sz1 -> (Ix2 -> e) -> Matrix DL e

-- | Negate each element of the array
negateA :: (Index ix, Numeric r e) => Array r ix e -> Array r ix e

-- | Apply <a>abs</a> to each element of the array
absA :: (Index ix, Numeric r e) => Array r ix e -> Array r ix e

-- | Apply <a>signum</a> to each element of the array
signumA :: (Index ix, Numeric r e) => Array r ix e -> Array r ix e

-- | Perform a pointwise quotient where first array contains numerators and
--   the second one denominators
--   
--   <pre>
--   quotA arr1 arr2 == zipWith quot arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
quotA :: (Source r1 ix e, Source r2 ix e, Integral e) => Array r1 ix e -> Array r2 ix e -> Array D ix e
infixl 7 `quotA`

-- | Perform a pointwise remainder computation
--   
--   <pre>
--   remA arr1 arr2 == zipWith rem arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
remA :: (Source r1 ix e, Source r2 ix e, Integral e) => Array r1 ix e -> Array r2 ix e -> Array D ix e
infixl 7 `remA`

-- | Perform a pointwise integer division where first array contains
--   numerators and the second one denominators
--   
--   <pre>
--   divA arr1 arr2 == zipWith div arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
divA :: (Source r1 ix e, Source r2 ix e, Integral e) => Array r1 ix e -> Array r2 ix e -> Array D ix e
infixl 7 `divA`

-- | Perform a pointwise modulo computation
--   
--   <pre>
--   modA arr1 arr2 == zipWith mod arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
modA :: (Source r1 ix e, Source r2 ix e, Integral e) => Array r1 ix e -> Array r2 ix e -> Array D ix e
infixl 7 `modA`

-- | Perform a pointwise quotient with remainder where first array contains
--   numerators and the second one denominators
--   
--   <pre>
--   quotRemA arr1 arr2 == zipWith quotRem arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
quotRemA :: (Source r1 ix e, Source r2 ix e, Integral e) => Array r1 ix e -> Array r2 ix e -> (Array D ix e, Array D ix e)

-- | Perform a pointwise integer division with modulo where first array
--   contains numerators and the second one denominators
--   
--   <pre>
--   divModA arr1 arr2 == zipWith divMod arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
divModA :: (Source r1 ix e, Source r2 ix e, Integral e) => Array r1 ix e -> Array r2 ix e -> (Array D ix e, Array D ix e)

-- | Divide each element of the array by a scalar value.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr = fromIntegral &lt;$&gt; (Ix1 20 ..: 25) :: Array D Ix1 Float
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz1 5)
--     [ 20.0, 21.0, 22.0, 23.0, 24.0 ]
--   
--   &gt;&gt;&gt; arr ./ 100
--   Array D Seq (Sz1 5)
--     [ 0.2, 0.21, 0.22, 0.23, 0.24 ]
--   </pre>
(./) :: (Index ix, NumericFloat r e) => Array r ix e -> e -> Array r ix e
infixl 7 ./

-- | Divide a scalar value by each element of the array.
--   
--   <pre>
--   e /. arr == e *. recipA arr
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr = fromIntegral &lt;$&gt; (Ix1 20 ..: 25) :: Array D Ix1 Float
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz1 5)
--     [ 20.0, 21.0, 22.0, 23.0, 24.0 ]
--   
--   &gt;&gt;&gt; 100 /. arr
--   Array D Seq (Sz1 5)
--     [ 5.0, 4.7619047, 4.5454545, 4.347826, 4.1666665 ]
--   </pre>
(/.) :: (Index ix, NumericFloat r e) => e -> Array r ix e -> Array r ix e
infixl 7 /.

-- | Divide each element of one array by another pointwise. Same as
--   <a>!/!</a> but produces monadic computation that allows for handling
--   failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   array sizes do not match.
(./.) :: (Load r ix e, NumericFloat r e, MonadThrow m) => Array r ix e -> Array r ix e -> m (Array r ix e)
infixl 7 ./.

-- | Divide two arrays pointwise. Prefer to use monadic version of this
--   function <a>./.</a> whenever possible, because it is better to avoid
--   partial functions.
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr1 = fromIntegral &lt;$&gt; (Ix1 20 ..: 25) :: Array D Ix1 Float
--   
--   &gt;&gt;&gt; let arr2 = fromIntegral &lt;$&gt; (Ix1 100 ..: 105) :: Array D Ix1 Float
--   
--   &gt;&gt;&gt; arr1 !/! arr2
--   Array D Seq (Sz1 5)
--     [ 0.2, 0.20792079, 0.21568628, 0.22330096, 0.23076923 ]
--   </pre>
(!/!) :: (Load r ix e, NumericFloat r e) => Array r ix e -> Array r ix e -> Array r ix e
infixl 7 !/!
(.^^) :: (Index ix, Numeric r e, Fractional e, Integral b) => Array r ix e -> b -> Array r ix e
infixr 8 .^^

-- | Apply reciprocal to each element of the array.
--   
--   <pre>
--   recipA arr == 1 /. arr
--   </pre>
recipA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply exponent to each element of the array.
--   
--   <pre>
--   expA arr == map exp arr
--   </pre>
expA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply logarithm to each element of the array.
--   
--   <pre>
--   logA arr == map log arr
--   </pre>
logA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply square root to each element of the array.
--   
--   <pre>
--   sqrtA arr == map sqrt arr
--   </pre>
sqrtA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply power to each element of the array where the power value is in
--   the same cell in the second array.
--   
--   <pre>
--   arr1 .** arr2 == zipWith (**) arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Throws an error when arrays do not have matching
--   sizes</li>
--   </ul>
(.**) :: (Source r1 ix e, Source r2 ix e, Floating e) => Array r1 ix e -> Array r2 ix e -> Array D ix e

-- | Apply logarithm to each element of the array where the base is in the
--   same cell in the second array.
--   
--   <pre>
--   logBaseA arr1 arr2 == zipWith logBase arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Throws an error when arrays do not have matching
--   sizes</li>
--   </ul>
logBaseA :: (Source r1 ix e, Source r2 ix e, Floating e) => Array r1 ix e -> Array r2 ix e -> Array D ix e

-- | Apply sine function to each element of the array.
--   
--   <pre>
--   sinA arr == map sin arr
--   </pre>
sinA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply cosine function to each element of the array.
--   
--   <pre>
--   cosA arr == map cos arr
--   </pre>
cosA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply tangent function to each element of the array.
--   
--   <pre>
--   tanA arr == map tan arr
--   </pre>
tanA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply arcsine function to each element of the array.
--   
--   <pre>
--   asinA arr == map asin arr
--   </pre>
asinA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply arccosine function to each element of the array.
--   
--   <pre>
--   acosA arr == map acos arr
--   </pre>
acosA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply arctangent function to each element of the array.
--   
--   <pre>
--   atanA arr == map atan arr
--   </pre>
atanA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply hyperbolic sine function to each element of the array.
--   
--   <pre>
--   sinhA arr == map sinh arr
--   </pre>
sinhA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply hyperbolic cosine function to each element of the array.
--   
--   <pre>
--   coshA arr == map cosh arr
--   </pre>
coshA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply hyperbolic tangent function to each element of the array.
--   
--   <pre>
--   tanhA arr == map tanh arr
--   </pre>
tanhA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply inverse hyperbolic sine function to each element of the array.
--   
--   <pre>
--   asinhA arr == map asinh arr
--   </pre>
asinhA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply inverse hyperbolic cosine function to each element of the array.
--   
--   <pre>
--   acoshA arr == map acosh arr
--   </pre>
acoshA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply inverse hyperbolic tangent function to each element of the
--   array.
--   
--   <pre>
--   atanhA arr == map atanh arr
--   </pre>
atanhA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Truncate each element of the array.
--   
--   <pre>
--   truncateA arr == map truncate arr
--   </pre>
truncateA :: (Source r ix a, RealFrac a, Integral e) => Array r ix a -> Array D ix e

-- | Round each element of the array.
--   
--   <pre>
--   truncateA arr == map truncate arr
--   </pre>
roundA :: (Source r ix a, RealFrac a, Integral e) => Array r ix a -> Array D ix e

-- | Ceiling of each element of the array.
--   
--   <pre>
--   truncateA arr == map truncate arr
--   </pre>
ceilingA :: (Source r ix a, RealFrac a, Integral e) => Array r ix a -> Array D ix e

-- | Floor each element of the array.
--   
--   <pre>
--   truncateA arr == map truncate arr
--   </pre>
floorA :: (Source r ix a, RealFrac a, Integral e) => Array r ix a -> Array D ix e

-- | Perform atan2 pointwise
--   
--   <pre>
--   atan2A arr1 arr2 == zipWith atan2 arr1 arr2
--   </pre>
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   array sizes do not match.
atan2A :: (Load r ix e, Numeric r e, RealFloat e, MonadThrow m) => Array r ix e -> Array r ix e -> m (Array r ix e)


module Data.Massiv.Array.Stencil

-- | Stencil is abstract description of how to handle elements in the
--   neighborhood of every array cell in order to compute a value for the
--   cells in the new array. Use <a>makeStencil</a> and
--   <a>makeConvolutionStencil</a> in order to create a stencil.
data Stencil ix e a

-- | Construct a stencil from a function, which describes how to calculate
--   the value at a point while having access to neighboring elements with
--   a function that accepts idices relative to the center of stencil.
--   Trying to index outside the stencil box will result in a runtime error
--   upon stencil creation.
--   
--   <i>Note</i> - Once correctness of stencil is verified then switching
--   to <a>makeUnsafeStencil</a> is recommended in order to get the most
--   performance out of the <a>Stencil</a>
--   
--   <h4><b>Example</b></h4>
--   
--   Below is an example of creating a <a>Stencil</a>, which, when mapped
--   over a 2-dimensional array, will compute an average of all elements in
--   a 3x3 square for each element in that array.
--   
--   <i>Note</i> - Make sure to add an <tt>INLINE</tt> pragma, otherwise
--   performance will be terrible.
--   
--   <pre>
--   average3x3Stencil :: Fractional a =&gt; Stencil Ix2 a a
--   average3x3Stencil = makeStencil (Sz (3 :. 3)) (1 :. 1) $ \ get -&gt;
--     (  get (-1 :. -1) + get (-1 :. 0) + get (-1 :. 1) +
--        get ( 0 :. -1) + get ( 0 :. 0) + get ( 0 :. 1) +
--        get ( 1 :. -1) + get ( 1 :. 0) + get ( 1 :. 1)   ) / 9
--   {-# INLINE average3x3Stencil #-}
--   </pre>
makeStencil :: Index ix => Sz ix -> ix -> ((ix -> e) -> a) -> Stencil ix e a

-- | Same as <a>makeStencil</a>, but with ability to specify default value
--   for stencil validation.

-- | <i>Deprecated: In favor of <a>makeStencil</a>. Validation is no longer
--   possible</i>
makeStencilDef :: Index ix => e -> Sz ix -> ix -> ((ix -> e) -> a) -> Stencil ix e a

-- | Get the size of the stencil
getStencilSize :: Stencil ix e a -> Sz ix

-- | Get the index of the stencil's center
getStencilCenter :: Stencil ix e a -> ix

-- | Padding of the source array before stencil application.
--   
--   <h4><b>Examples</b></h4>
--   
--   In order to see the affect of padding we can simply apply an identity
--   stencil to an array:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ resize' (Sz2 2 3) (Ix1 1 ... 6)
--   
--   &gt;&gt;&gt; applyStencil noPadding idStencil a
--   Array DW Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 1 2) (Sz2 3 4) (Fill 0)) idStencil a
--   Array DW Seq (Sz (6 :. 9))
--     [ [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 1, 2, 3, 0, 0, 0, 0 ]
--     , [ 0, 0, 4, 5, 6, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     ]
--   </pre>
--   
--   It is also a nice technique to see the border resolution strategy in
--   action:
--   
--   <pre>
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 2 3) (Sz2 2 3) Wrap) idStencil a
--   Array DW Seq (Sz (6 :. 9))
--     [ [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
--     , [ 4, 5, 6, 4, 5, 6, 4, 5, 6 ]
--     , [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
--     , [ 4, 5, 6, 4, 5, 6, 4, 5, 6 ]
--     , [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
--     , [ 4, 5, 6, 4, 5, 6, 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 2 3) (Sz2 2 3) Edge) idStencil a
--   Array DW Seq (Sz (6 :. 9))
--     [ [ 1, 1, 1, 1, 2, 3, 3, 3, 3 ]
--     , [ 1, 1, 1, 1, 2, 3, 3, 3, 3 ]
--     , [ 1, 1, 1, 1, 2, 3, 3, 3, 3 ]
--     , [ 4, 4, 4, 4, 5, 6, 6, 6, 6 ]
--     , [ 4, 4, 4, 4, 5, 6, 6, 6, 6 ]
--     , [ 4, 4, 4, 4, 5, 6, 6, 6, 6 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 2 3) (Sz2 2 3) Reflect) idStencil a
--   Array DW Seq (Sz (6 :. 9))
--     [ [ 6, 5, 4, 4, 5, 6, 6, 5, 4 ]
--     , [ 3, 2, 1, 1, 2, 3, 3, 2, 1 ]
--     , [ 3, 2, 1, 1, 2, 3, 3, 2, 1 ]
--     , [ 6, 5, 4, 4, 5, 6, 6, 5, 4 ]
--     , [ 6, 5, 4, 4, 5, 6, 6, 5, 4 ]
--     , [ 3, 2, 1, 1, 2, 3, 3, 2, 1 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 2 3) (Sz2 2 3) Continue) idStencil a
--   Array DW Seq (Sz (6 :. 9))
--     [ [ 1, 3, 2, 1, 2, 3, 2, 1, 3 ]
--     , [ 4, 6, 5, 4, 5, 6, 5, 4, 6 ]
--     , [ 1, 3, 2, 1, 2, 3, 2, 1, 3 ]
--     , [ 4, 6, 5, 4, 5, 6, 5, 4, 6 ]
--     , [ 1, 3, 2, 1, 2, 3, 2, 1, 3 ]
--     , [ 4, 6, 5, 4, 5, 6, 5, 4, 6 ]
--     ]
--   </pre>
data Padding ix e
Padding :: !Sz ix -> !Sz ix -> !Border e -> Padding ix e
[paddingFromOrigin] :: Padding ix e -> !Sz ix
[paddingFromBottom] :: Padding ix e -> !Sz ix

-- | Element to do padding with
[paddingWithElement] :: Padding ix e -> !Border e

-- | Also known as "valid" padding. When stencil is applied to an array,
--   that array will shrink, unless the stencil is of size 1.
noPadding :: Index ix => Padding ix e

-- | Padding that matches the size of the stencil, which is known as "same"
--   padding, because when a stencil is applied to an array with such
--   matching padding, the resulting array will be of the same size as the
--   source array. This is exactly the behavior of <a>mapStencil</a>
samePadding :: Index ix => Stencil ix e a -> Border e -> Padding ix e

-- | Map a constructed stencil over an array. Resulting array must be
--   <a>compute</a>d in order to be useful.
mapStencil :: (Source r ix e, Manifest r ix e) => Border e -> Stencil ix e a -> Array r ix e -> Array DW ix a

-- | Apply a constructed stencil over an array. Resulting array must be
--   <a>compute</a>d in order to be useful. Unlike <a>mapStencil</a>, the
--   size of the resulting array will not necesserally be the same as the
--   source array, which will depend on the padding.
applyStencil :: (Source r ix e, Manifest r ix e) => Padding ix e -> Stencil ix e a -> Array r ix e -> Array DW ix a

-- | Identity stencil that does not change the elements of the source
--   array.
idStencil :: Index ix => Stencil ix e e

-- | Sum all elements in the stencil region
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ iterateN (Sz2 2 5) (* 2) (1 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (2 :. 5))
--     [ [ 2, 4, 8, 16, 32 ]
--     , [ 64, 128, 256, 512, 1024 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil noPadding (sumStencil (Sz2 1 2)) a
--   Array DW Seq (Sz (2 :. 4))
--     [ [ 6, 12, 24, 48 ]
--     , [ 192, 384, 768, 1536 ]
--     ]
--   
--   &gt;&gt;&gt; [2 + 4, 4 + 8, 8 + 16, 16 + 32] :: [Int]
--   [6,12,24,48]
--   </pre>
sumStencil :: (Num e, Index ix) => Sz ix -> Stencil ix e e

-- | Multiply all elements in the stencil region
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ iterateN (Sz2 2 2) (+1) (0 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (2 :. 2))
--     [ [ 1, 2 ]
--     , [ 3, 4 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding 0 2 (Fill 0)) (productStencil 2) a
--   Array DW Seq (Sz (3 :. 3))
--     [ [ 24, 0, 0 ]
--     , [ 0, 0, 0 ]
--     , [ 0, 0, 0 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding 0 2 Reflect) (productStencil 2) a
--   Array DW Seq (Sz (3 :. 3))
--     [ [ 24, 64, 24 ]
--     , [ 144, 256, 144 ]
--     , [ 24, 64, 24 ]
--     ]
--   </pre>
productStencil :: (Num e, Index ix) => Sz ix -> Stencil ix e e

-- | Find the average value of all elements in the stencil region
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ iterateN (Sz2 3 4) (+1) (10 :: Double)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (3 :. 4))
--     [ [ 11.0, 12.0, 13.0, 14.0 ]
--     , [ 15.0, 16.0, 17.0, 18.0 ]
--     , [ 19.0, 20.0, 21.0, 22.0 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil noPadding (avgStencil (Sz2 2 3)) a
--   Array DW Seq (Sz (2 :. 2))
--     [ [ 14.0, 15.0 ]
--     , [ 18.0, 19.0 ]
--     ]
--   
--   &gt;&gt;&gt; Prelude.sum [11.0, 12.0, 13.0, 15.0, 16.0, 17.0] / 6 :: Double
--   14.0
--   </pre>
avgStencil :: (Fractional e, Index ix) => Sz ix -> Stencil ix e e

-- | Create a stencil centered at 0 that will extract the maximum value in
--   the region of supplied size.
--   
--   <h4><b>Example</b></h4>
--   
--   Here is a sample implementation of max pooling.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a &lt;- computeAs P &lt;$&gt; resizeM (Sz2 9 9) (Ix1 10 ..: 91)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (9 :. 9))
--     [ [ 10, 11, 12, 13, 14, 15, 16, 17, 18 ]
--     , [ 19, 20, 21, 22, 23, 24, 25, 26, 27 ]
--     , [ 28, 29, 30, 31, 32, 33, 34, 35, 36 ]
--     , [ 37, 38, 39, 40, 41, 42, 43, 44, 45 ]
--     , [ 46, 47, 48, 49, 50, 51, 52, 53, 54 ]
--     , [ 55, 56, 57, 58, 59, 60, 61, 62, 63 ]
--     , [ 64, 65, 66, 67, 68, 69, 70, 71, 72 ]
--     , [ 73, 74, 75, 76, 77, 78, 79, 80, 81 ]
--     , [ 82, 83, 84, 85, 86, 87, 88, 89, 90 ]
--     ]
--   
--   &gt;&gt;&gt; computeWithStrideAs P (Stride 3) $ mapStencil Edge (maxStencil (Sz 3)) a
--   Array P Seq (Sz (3 :. 3))
--     [ [ 30, 33, 36 ]
--     , [ 57, 60, 63 ]
--     , [ 84, 87, 90 ]
--     ]
--   </pre>
maxStencil :: (Bounded e, Ord e, Index ix) => Sz ix -> Stencil ix e e

-- | Create a stencil centered at 0 that will extract the maximum value in
--   the region of supplied size.
--   
--   <h4><b>Example</b></h4>
--   
--   Here is a sample implementation of min pooling.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a &lt;- computeAs P &lt;$&gt; resizeM (Sz2 9 9) (Ix1 10 ..: 91)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (9 :. 9))
--     [ [ 10, 11, 12, 13, 14, 15, 16, 17, 18 ]
--     , [ 19, 20, 21, 22, 23, 24, 25, 26, 27 ]
--     , [ 28, 29, 30, 31, 32, 33, 34, 35, 36 ]
--     , [ 37, 38, 39, 40, 41, 42, 43, 44, 45 ]
--     , [ 46, 47, 48, 49, 50, 51, 52, 53, 54 ]
--     , [ 55, 56, 57, 58, 59, 60, 61, 62, 63 ]
--     , [ 64, 65, 66, 67, 68, 69, 70, 71, 72 ]
--     , [ 73, 74, 75, 76, 77, 78, 79, 80, 81 ]
--     , [ 82, 83, 84, 85, 86, 87, 88, 89, 90 ]
--     ]
--   
--   &gt;&gt;&gt; computeWithStrideAs P (Stride 3) $ mapStencil Edge (minStencil (Sz 3)) a
--   Array P Seq (Sz (3 :. 3))
--     [ [ 10, 13, 16 ]
--     , [ 37, 40, 43 ]
--     , [ 64, 67, 70 ]
--     ]
--   </pre>
minStencil :: (Bounded e, Ord e, Index ix) => Sz ix -> Stencil ix e e

-- | Stencil that does a left fold in a row-major order. Regardless of the
--   supplied size resulting stencil will be centered at zero, although by
--   using <a>Padding</a> it is possible to overcome this limitation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ iterateN (Sz2 3 4) (+1) (10 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (3 :. 4))
--     [ [ 11, 12, 13, 14 ]
--     , [ 15, 16, 17, 18 ]
--     , [ 19, 20, 21, 22 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil noPadding (foldlStencil (flip (:)) [] (Sz2 3 2)) a
--   Array DW Seq (Sz (1 :. 3))
--     [ [ [20,19,16,15,12,11], [21,20,17,16,13,12], [22,21,18,17,14,13] ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 1 0) 0 (Fill 10)) (foldlStencil (flip (:)) [] (Sz2 3 2)) a
--   Array DW Seq (Sz (2 :. 3))
--     [ [ [16,15,12,11,10,10], [17,16,13,12,10,10], [18,17,14,13,10,10] ]
--     , [ [20,19,16,15,12,11], [21,20,17,16,13,12], [22,21,18,17,14,13] ]
--     ]
--   </pre>
foldlStencil :: Index ix => (a -> e -> a) -> a -> Sz ix -> Stencil ix e a

-- | Stencil that does a right fold in a row-major order. Regardless of the
--   supplied size resulting stencil will be centered at zero, although by
--   using <a>Padding</a> it is possible to overcome this limitation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ iterateN (Sz2 3 4) (+1) (10 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (3 :. 4))
--     [ [ 11, 12, 13, 14 ]
--     , [ 15, 16, 17, 18 ]
--     , [ 19, 20, 21, 22 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil noPadding (foldrStencil (:) [] (Sz2 2 3)) a
--   Array DW Seq (Sz (2 :. 2))
--     [ [ [11,12,13,15,16,17], [12,13,14,16,17,18] ]
--     , [ [15,16,17,19,20,21], [16,17,18,20,21,22] ]
--     ]
--   </pre>
foldrStencil :: Index ix => (e -> a -> a) -> a -> Sz ix -> Stencil ix e a

-- | Create a stencil that will fold all elements in the region monoidally.
foldStencil :: (Monoid e, Index ix) => Sz ix -> Stencil ix e e

-- | A Profunctor dimap. Same caviat applies as in <a>lmapStencil</a>
dimapStencil :: (c -> d) -> (a -> b) -> Stencil ix d a -> Stencil ix c b

-- | A contravariant map of a second type parameter. In other words map a
--   function over each element of the array, that the stencil will be
--   applied to.
--   
--   <b>Note</b>: This map can be very inefficient, since for stencils
--   larger than 1 element in size, the supllied function will be
--   repeatedly applied to the same element. It is better to simply map
--   that function over the source array instead.
lmapStencil :: (c -> d) -> Stencil ix d a -> Stencil ix c a

-- | A covariant map over the right most type argument. In other words the
--   usual <a>fmap</a> from <a>Functor</a>:
--   
--   <pre>
--   fmap == rmapStencil
--   </pre>
rmapStencil :: (a -> b) -> Stencil ix e a -> Stencil ix e b

-- | Create a convolution stencil by specifying border resolution technique
--   and an accumulator function.
--   
--   <i>Note</i> - Using <a>makeUnsafeConvolutionStencil</a> will be much
--   faster, therefore it is recommended to switch from this function,
--   after manual verification that the created stencil behaves as
--   expected.
--   
--   <h4><b>Examples</b></h4>
--   
--   Here is how to create a 2D horizontal Sobel Stencil:
--   
--   <pre>
--   sobelX :: Num e =&gt; Stencil Ix2 e e
--   sobelX = makeConvolutionStencil (Sz2 3 3) (1 :. 1) $
--              \f -&gt; f (-1 :. -1) (-1) . f (-1 :. 1) 1 .
--                    f ( 0 :. -1) (-2) . f ( 0 :. 1) 2 .
--                    f ( 1 :. -1) (-1) . f ( 1 :. 1) 1
--   {-# INLINE sobelX #-}
--   </pre>
makeConvolutionStencil :: (Index ix, Num e) => Sz ix -> ix -> ((ix -> e -> e -> e) -> e -> e) -> Stencil ix e e

-- | Make a stencil out of a Kernel Array. This <a>Stencil</a> will be
--   slower than if <a>makeConvolutionStencil</a> is used, but sometimes we
--   just really don't know the kernel at compile time.
makeConvolutionStencilFromKernel :: (Manifest r ix e, Num e) => Array r ix e -> Stencil ix e e

-- | Make a <a>cross-correlation</a> stencil
--   
--   <i>Note</i> - Using <a>makeUnsafeCorrelationStencil</a> will be much
--   faster, therefore it is recommended to switch from this function,
--   after manual verification that the created stencil behaves as
--   expected.
makeCorrelationStencil :: (Index ix, Num e) => Sz ix -> ix -> ((ix -> e -> e -> e) -> e -> e) -> Stencil ix e e

-- | Make a <a>cross-correlation</a> stencil out of a Kernel Array. This
--   <a>Stencil</a> will be slower than if <a>makeCorrelationStencil</a> is
--   used, but sometimes we just really don't know the kernel at compile
--   time.
makeCorrelationStencilFromKernel :: (Manifest r ix e, Num e) => Array r ix e -> Stencil ix e e
instance (Data.Massiv.Core.Index.Internal.Index ix, GHC.Show.Show e) => GHC.Show.Show (Data.Massiv.Array.Stencil.Padding ix e)
instance (GHC.Classes.Eq ix, GHC.Classes.Eq e) => GHC.Classes.Eq (Data.Massiv.Array.Stencil.Padding ix e)


module Data.Massiv.Array.Delayed

-- | Delayed representation.
data D
D :: D

-- | <i>O(1)</i> Conversion from a source array to <a>D</a> representation.
delay :: Source r ix e => Array r ix e -> Array D ix e

-- | Delayed load representation. Also known as Push array.
data DL
DL :: DL

-- | Convert any <a>Load</a>able array into <a>DL</a> representation.
toLoadArray :: forall r ix e. Load r ix e => Array r ix e -> Array DL ix e

-- | Describe how an array should be loaded into memory sequentially. For
--   parallelizable version see <a>makeLoadArray</a>.
makeLoadArrayS :: forall ix e. Index ix => Sz ix -> e -> (forall m. Monad m => (ix -> e -> m Bool) -> m ()) -> Array DL ix e

-- | Specify how an array should be loaded into memory. Unlike
--   <a>makeLoadArrayS</a>, loading function accepts a scheduler, thus can
--   be parallelized. If you need an unsafe version of this function see
--   <a>unsafeMakeLoadArray</a>.
makeLoadArray :: forall ix e. Index ix => Comp -> Sz ix -> e -> (forall m. Monad m => Scheduler m () -> (ix -> e -> m Bool) -> m ()) -> Array DL ix e

-- | Convert an array that can be loaded with stride into <a>DL</a>
--   representation.
fromStrideLoad :: forall r ix e. StrideLoad r ix e => Stride ix -> Array r ix e -> Array DL ix e

-- | Delayed stream array that represents a sequence of values that can be
--   loaded sequentially. Important distinction from other arrays is that
--   its size might no be known until it is computed.
data DS
DS :: DS

-- | Flatten an array into a stream of values.
toStreamArray :: Source r ix e => Array r ix e -> Array DS Ix1 e

-- | <i>O(1)</i> - Convert delayed stream array into <a>Steps</a>.
toSteps :: Array DS Ix1 e -> Steps Id e

-- | <i>O(1)</i> - Convert <a>Steps</a> into delayed stream array
fromSteps :: Steps Id e -> Array DS Ix1 e

-- | Delayed array that will be loaded in an interleaved fashion during
--   parallel computation.
data DI
DI :: DI

-- | Convert a source array into an array that, when computed, will have
--   its elemets evaluated out of order (interleaved amongst cores), hence
--   making unbalanced computation better parallelizable.
toInterleaved :: Source r ix e => Array r ix e -> Array DI ix e

-- | <i>O(1)</i> - Unwrap the interleved array.
fromInterleaved :: Array DI ix e -> Array D ix e

-- | Delayed Windowed Array representation.
data DW
DW :: DW
data Window ix e
Window :: !ix -> !Sz ix -> (ix -> e) -> !Maybe Int -> Window ix e

-- | Index of where window will start at.
[windowStart] :: Window ix e -> !ix

-- | Size of the window
[windowSize] :: Window ix e -> !Sz ix

-- | Indexing function for the window
[windowIndex] :: Window ix e -> ix -> e

-- | Setting this value during stencil application improves cache
--   utilization by unrolling the loop for Ix2 and higher dimensions. Has
--   no affect on arrays with one dimension.
[windowUnrollIx2] :: Window ix e -> !Maybe Int

-- | Inserts a <a>Window</a> into a delayed array while scaling the window
--   down if it doesn't fit inside that array.
insertWindow :: Source D ix e => Array D ix e -> Window ix e -> Array DW ix e

-- | Get the <a>Window</a> from a windowed array.
getWindow :: Array DW ix e -> Maybe (Window ix e)

-- | Drop the <a>Window</a> from a windowed array.
dropWindow :: Array DW ix e -> Array D ix e

-- | Construct a delayed windowed array by supply a separate element
--   producing function for the interior of an array. This is very usful
--   for stencil mapping, where interior function does not perform boundary
--   checks, thus significantly speeding up computation process.
makeWindowedArray :: Source r ix e => Array r ix e -> ix -> Sz ix -> (ix -> e) -> Array DW ix e


module Data.Massiv.Vector

-- | Type synonym for a single dimension array, or simply a flat vector.
type Vector r e = Array r Ix1 e

-- | Type synonym for a single dimension mutable array, or simply a flat
--   mutable vector.
type MVector s r e = MArray s r Ix1 e

-- | <i>O(1)</i> - Get the length of a <a>Stream</a> array, but only if it
--   is known exactly in constant time without looking at any of the
--   elements in the array.
--   
--   <i>Related</i>: <a>maxSize</a>, <a>size</a>, <a>elemsCount</a> and
--   <a>totalElem</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; slength $ sfromList []
--   Nothing
--   
--   &gt;&gt;&gt; slength $ sreplicate 5 ()
--   Just (Sz1 5)
--   
--   &gt;&gt;&gt; slength $ makeArrayLinearR D Seq (Sz1 5) id
--   Just (Sz1 5)
--   
--   &gt;&gt;&gt; slength $ sunfoldr (\x -&gt; Just (x, x)) (0 :: Int)
--   Nothing
--   
--   &gt;&gt;&gt; slength $ sunfoldrN 10 (\x -&gt; Just (x, x)) (0 :: Int)
--   Nothing
--   
--   &gt;&gt;&gt; slength $ sunfoldrExactN 10 (\x -&gt; (x, x)) (0 :: Int)
--   Just (Sz1 10)
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.Foldable.<a>length</a></tt></i> For some data
--   structures, like a list for example, it is an <i>O(n)</i> operation,
--   because there is a need to evaluate the full spine and possibly even
--   the elements in order to get the full length. With <a>Stream</a>
--   vectors that is rarely the case.</li>
--   <li><i><tt>Data.Vector.Generic.<a>length</a></tt></i> In the vector
--   package this function will always break fusion, unless it is the only
--   operation that is applied to the vector.</li>
--   </ul>
slength :: Stream r ix e => Array r ix e -> Maybe Sz1

-- | <i>O(1)</i> - Get the possible maximum size of an immutabe array. If
--   the lookup of size in constant time is not possible, <a>Nothing</a>
--   will be returned. This value will be used as the initial size of the
--   mutable array into which the loading will happen.
maxSize :: Load r ix e => Array r ix e -> Maybe (Sz ix)

-- | Get the exact size of an immutabe array. Most of the time will produce
--   the size in constant time, except for <tt>DS</tt> representation,
--   which could result in evaluation of the whole stream. See
--   <a>maxSize</a> and <a>slength</a> for more info.
size :: Load r ix e => Array r ix e -> Sz ix

-- | <i>O(1)</i> - Check whether a <a>Stream</a> array is empty or not. It
--   only looks at the exact size (i.e. <a>slength</a>), if it is
--   available, otherwise checks if there is at least one element in a
--   stream.
--   
--   <i>Related</i>: <a>isEmpty</a>, <a>isNotEmpty</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; snull sempty
--   True
--   
--   &gt;&gt;&gt; snull (empty :: Array D Ix5 Int)
--   True
--   
--   &gt;&gt;&gt; snull $ ssingleton "A Vector with a single String element"
--   False
--   
--   &gt;&gt;&gt; snull $ sfromList []
--   True
--   
--   &gt;&gt;&gt; snull $ sfromList [1 :: Int ..]
--   False
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.Foldable.<a>null</a></tt></i> List fusion is also
--   broken with a check for emptiness, unless there are no other consumers
--   of the list.</li>
--   <li><i><tt>Data.Vector.Generic.<a>null</a></tt></i> Same as with
--   <a>length</a>, unless it is the only operation applied to the vector
--   it will break fusion and will result in the vector being fully
--   materialized in memory.</li>
--   </ul>
snull :: Load r ix e => Array r ix e -> Bool

-- | <i>O(1)</i> - Infix version of <a>indexM</a>.
--   
--   <i><b>Exceptions</b></i>: <a>IndexOutOfBoundsException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; a &lt;- fromListsM @U @Ix2 @Int Seq [[1,2,3],[4,5,6]]
--   
--   &gt;&gt;&gt; a
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; a !? 0 :. 2
--   3
--   
--   &gt;&gt;&gt; a !? 0 :. 3
--   *** Exception: IndexOutOfBoundsException: (0 :. 3) is not safe for (Sz (2 :. 3))
--   
--   &gt;&gt;&gt; a !? 0 :. 3 :: Maybe Int
--   Nothing
--   </pre>
(!?) :: (Manifest r ix e, MonadThrow m) => Array r ix e -> ix -> m e
infixl 4 !?

-- | <i>O(1)</i> - Infix version of <a>index</a>`.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs U $ iterateN (Sz (2 :. 3)) succ (0 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; a ! 0 :. 2
--   3
--   
--   &gt;&gt;&gt; a ! 0 :. 3
--   *** Exception: IndexOutOfBoundsException: (0 :. 3) is not safe for (Sz (2 :. 3))
--   </pre>
(!) :: Manifest r ix e => Array r ix e -> ix -> e
infixl 4 !

-- | <i>O(1)</i> - Lookup an element in the array. Returns <a>Nothing</a>,
--   when index is out of bounds and returns the element at the supplied
--   index otherwise. Use <a>indexM</a> instead, since it is more general
--   and it can just as well be used with <a>Maybe</a>.
index :: Manifest r ix e => Array r ix e -> ix -> Maybe e

-- | <i>O(1)</i> - Lookup an element in the array. This is a partial
--   function and it can throw <a>IndexOutOfBoundsException</a> inside pure
--   code. It is safer to use <a>index</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; xs = [0..100] :: Array U Ix1 Int
--   
--   &gt;&gt;&gt; index' xs 50
--   50
--   
--   &gt;&gt;&gt; index' xs 150
--   *** Exception: IndexOutOfBoundsException: 150 is not safe for (Sz1 101)
--   </pre>
index' :: Manifest r ix e => Array r ix e -> ix -> e

-- | <i>O(1)</i> - Get the first element of a <a>Source</a> vector. Throws
--   an error on empty.
--   
--   <i>Related</i>: <tt>shead</tt>`, <a>headM</a>, <a>sheadM</a>,
--   <a>unconsM</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; head' (Ix1 10 ..: 10000000000000)
--   10
--   
--   &gt;&gt;&gt; head' (Ix1 10 ..: 10)
--   *** Exception: SizeEmptyException: (Sz1 0) corresponds to an empty array
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.List.<a>head</a></tt></i> Also constant time and
--   partial. Fusion is broken if there other consumers of the list.</li>
--   <li><i><tt>Data.Vector.Generic.<a>head</a></tt></i> Also constant time
--   and partial. Will cause materialization of the full vector if any
--   other function is applied to the vector.</li>
--   </ul>
head' :: Source r Ix1 e => Vector r e -> e

-- | <i>O(1)</i> - Get the first element of a <a>Stream</a> vector. Throws
--   an error on empty.
--   
--   <i>Related</i>: <a>head</a>`, <a>headM</a>, <a>sheadM</a>,
--   <a>unconsM</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; shead' $ sunfoldr (\x -&gt; Just (x, x)) (0 :: Int)
--   0
--   
--   &gt;&gt;&gt; x = shead' $ sunfoldr (\_ -&gt; Nothing) (0 :: Int)
--   
--   &gt;&gt;&gt; print x
--   *** Exception: SizeEmptyException: (Sz1 0) corresponds to an empty array
--   </pre>
shead' :: Stream r Ix1 e => Vector r e -> e

-- | <i>O(1)</i> - Get the last element of a <a>Source</a> vector. Throws
--   an error on empty.
--   
--   <i>Related</i>: <a>lastM</a>, <a>unsnocM</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; last' (Ix1 10 ... 10000000000000)
--   10000000000000
--   
--   &gt;&gt;&gt; last' (fromList Seq [] :: Array P Ix1 Int)
--   *** Exception: SizeEmptyException: (Sz1 0) corresponds to an empty array
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.List.<a>last</a></tt></i> Also partial, but it has
--   <i>O(n)</i> complixity. Fusion is broken if there other consumers of
--   the list.</li>
--   <li><i><tt>Data.Vector.Generic.<a>last</a></tt></i> Also constant time
--   and partial. Will cause materialization of the full vector if any
--   other function is applied to the vector.</li>
--   </ul>
last' :: Source r Ix1 e => Vector r e -> e

-- | <i>O(1)</i> - Lookup an element in the array.
--   
--   <i><b>Exceptions</b></i>: <a>IndexOutOfBoundsException</a>
indexM :: (Manifest r ix e, MonadThrow m) => Array r ix e -> ix -> m e

-- | <i>O(1)</i> - Get the first element of a <a>Source</a> vector.
--   
--   <i>Related</i>: <a>head</a>`, <tt>shead</tt>`, <a>sheadM</a>,
--   <a>unconsM</a>.
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a> when array
--   is empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; headM (Ix1 10 ..: 10000000000000)
--   10
--   
--   &gt;&gt;&gt; headM (Ix1 10 ..: 10000000000000) :: Maybe Int
--   Just 10
--   
--   &gt;&gt;&gt; headM (empty :: Array D Ix1 Int) :: Maybe Int
--   Nothing
--   
--   &gt;&gt;&gt; either show (const "") $ headM (Ix1 10 ..: 10)
--   "SizeEmptyException: (Sz1 0) corresponds to an empty array"
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.Maybe.<a>listToMaybe</a></tt></i> It also a safe way
--   to get the head of the list, except it is restricted to
--   <a>Maybe</a></li>
--   </ul>
headM :: (Source r Ix1 e, MonadThrow m) => Vector r e -> m e

-- | <i>O(1)</i> - Get the first element of a <a>Stream</a> vector.
--   
--   <i>Related</i>: <a>head</a>`, <tt>shead</tt>`, <a>headM</a>,
--   <a>unconsM</a>.
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; maybe 101 id $ sheadM (empty :: Vector D Int)
--   101
--   
--   &gt;&gt;&gt; maybe 101 id $ sheadM (singleton 202 :: Vector D Int)
--   202
--   
--   &gt;&gt;&gt; sheadM $ sunfoldr (\x -&gt; Just (x, x)) (0 :: Int)
--   0
--   
--   &gt;&gt;&gt; x &lt;- sheadM $ sunfoldr (\_ -&gt; Nothing) (0 :: Int)
--   *** Exception: SizeEmptyException: (Sz1 0) corresponds to an empty array
--   </pre>
sheadM :: (Stream r Ix1 e, MonadThrow m) => Vector r e -> m e

-- | <i>O(1)</i> - Get the last element of a <a>Source</a> vector.
--   
--   <i>Related</i>: <a>last</a>`, <a>unsnocM</a>
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; lastM (Ix1 10 ... 10000000000000)
--   10000000000000
--   
--   &gt;&gt;&gt; lastM (Ix1 10 ... 10000000000000) :: Maybe Int
--   Just 10000000000000
--   
--   &gt;&gt;&gt; either show (const "") $ lastM (fromList Seq [] :: Array P Ix1 Int)
--   "SizeEmptyException: (Sz1 0) corresponds to an empty array"
--   </pre>
lastM :: (Source r Ix1 e, MonadThrow m) => Vector r e -> m e

-- | <i>O(1)</i> - Take one element off of the <a>Source</a> vector from
--   the left side, as well as the remaining part of the vector in delayed
--   <a>D</a> representation.
--   
--   <i>Related</i>: <a>head</a>`, <tt>shead</tt>`, <a>headM</a>,
--   <a>sheadM</a>, <a>cons</a>
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unconsM (fromList Seq [1,2,3] :: Array P Ix1 Int)
--   (1,Array P Seq (Sz1 2)
--     [ 2, 3 ])
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.List.<a>uncons</a></tt></i> Same concept, except it is
--   restricted to <a>Maybe</a> instead of the more general
--   <a>MonadThrow</a></li>
--   </ul>
unconsM :: (MonadThrow m, Source r Ix1 e) => Vector r e -> m (e, Vector r e)

-- | <i>O(1)</i> - Take one element off of the vector from the right side,
--   as well as the remaining part of the vector.
--   
--   <i>Related</i>: <a>last</a>`, <a>lastM</a>, <a>snoc</a>
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unsnocM (fromList Seq [1,2,3] :: Array P Ix1 Int)
--   (Array P Seq (Sz1 2)
--     [ 1, 2 ],3)
--   </pre>
unsnocM :: (MonadThrow m, Source r Ix1 e) => Vector r e -> m (Vector r e, e)

-- | <i>O(1)</i> - Take a slice of a <a>Source</a> vector. Never fails,
--   instead adjusts the indices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; slice 10 5 (Ix1 0 ... 10000000000000)
--   Array D Seq (Sz1 5)
--     [ 10, 11, 12, 13, 14 ]
--   
--   &gt;&gt;&gt; slice (-10) 5 (Ix1 0 ... 10000000000000)
--   Array D Seq (Sz1 5)
--     [ 0, 1, 2, 3, 4 ]
--   
--   &gt;&gt;&gt; slice 9999999999998 50 (Ix1 0 ... 10000000000000)
--   Array D Seq (Sz1 3)
--     [ 9999999999998, 9999999999999, 10000000000000 ]
--   </pre>
slice :: Source r Ix1 e => Ix1 -> Sz1 -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Take a slice of a <a>Source</a> vector. Throws an error
--   on incorrect indices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; slice' 10 5 (Ix1 0 ... 100)
--   Array D Seq (Sz1 5)
--     [ 10, 11, 12, 13, 14 ]
--   
--   &gt;&gt;&gt; slice' (-10) 5 (Ix1 0 ... 100)
--   Array D *** Exception: SizeSubregionException: (Sz1 101) is to small for -10 (Sz1 5)
--   
--   &gt;&gt;&gt; slice' 98 50 (Ix1 0 ... 100)
--   Array D *** Exception: SizeSubregionException: (Sz1 101) is to small for 98 (Sz1 50)
--   
--   &gt;&gt;&gt; slice' 9999999999998 50 (Ix1 0 ... 10000000000000)
--   Array D *** Exception: SizeSubregionException: (Sz1 10000000000001) is to small for 9999999999998 (Sz1 50)
--   
--   &gt;&gt;&gt; slice' 9999999999998 3 (Ix1 0 ... 10000000000000)
--   Array D Seq (Sz1 3)
--     [ 9999999999998, 9999999999999, 10000000000000 ]
--   </pre>
slice' :: Source r Ix1 e => Ix1 -> Sz1 -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Take a slice of a <a>Source</a> vector. Throws an error
--   on incorrect indices.
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeSubregionException</a>
--   
--   <h4><b>Examples</b></h4>
sliceM :: (Source r Ix1 e, MonadThrow m) => Ix1 -> Sz1 -> Vector r e -> m (Vector r e)

-- | Take a slice of a <a>Stream</a> vector. Never fails, instead adjusts
--   the indices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sslice 10 5 (Ix1 0 ... 10000000000000)
--   Array DS Seq (Sz1 5)
--     [ 10, 11, 12, 13, 14 ]
--   
--   &gt;&gt;&gt; sslice 10 5 (sfromList [0 :: Int .. ])
--   Array DS Seq (Sz1 5)
--     [ 10, 11, 12, 13, 14 ]
--   
--   &gt;&gt;&gt; sslice (-10) 5 (Ix1 0 ... 10000000000000)
--   Array DS Seq (Sz1 5)
--     [ 0, 1, 2, 3, 4 ]
--   </pre>
--   
--   Unlike <a>slice</a> it has to iterate through each element until the
--   staring index is reached, therefore something like <tt>sslice
--   9999999999998 50 (Ix1 0 ... 10000000000000)</tt> will not be feasable.
--   
--   <pre>
--   &gt;&gt;&gt; import System.Timeout (timeout)
--   
--   &gt;&gt;&gt; let smallArr = sslice 9999999999998 50 (Ix1 0 ... 10000000000000)
--   
--   &gt;&gt;&gt; timeout 500000 (computeIO smallArr :: IO (Array P Ix1 Int))
--   Nothing
--   </pre>
sslice :: Stream r Ix1 e => Ix1 -> Sz1 -> Vector r e -> Vector DS e

-- | Samel as <a>sliceAt</a>, except it never fails.
--   
--   <h4><b>Examples</b></h4>
sliceAt :: Source r Ix1 e => Sz1 -> Vector r e -> (Vector r e, Vector r e)

-- | Same as <a>splitAt</a>`, except for a flat vector.
--   
--   <h4><b>Examples</b></h4>
sliceAt' :: Source r Ix1 e => Sz1 -> Vector r e -> (Vector r e, Vector r e)

-- | Same as <a>splitAtM</a>, except for a flat vector.
--   
--   <h4><b>Examples</b></h4>
sliceAtM :: (Source r Ix1 e, MonadThrow m) => Sz1 -> Vector r e -> m (Vector r e, Vector r e)

-- | <i>O(1)</i> - Get a vector without the last element. Never fails.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; init (0 ..: 10)
--   Array D Seq (Sz1 9)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
--   
--   &gt;&gt;&gt; init (empty :: Array D Ix1 Int)
--   Array D Seq (Sz1 0)
--     [  ]
--   </pre>
init :: Source r Ix1 e => Vector r e -> Vector r e

-- | <i>O(1)</i> - Get a vector without the last element. Throws an error
--   on empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; init' (0 ..: 10)
--   Array D Seq (Sz1 9)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
--   
--   &gt;&gt;&gt; init' (empty :: Array D Ix1 Int)
--   Array D *** Exception: SizeEmptyException: (Sz1 0) corresponds to an empty array
--   </pre>
init' :: Source r Ix1 e => Vector r e -> Vector r e

-- | <i>O(1)</i> - Get a vector without the last element. Throws an error
--   on empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; initM (0 ..: 10)
--   Array D Seq (Sz1 9)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
--   
--   &gt;&gt;&gt; maybe 0 sum $ initM (0 ..: 10)
--   36
--   
--   &gt;&gt;&gt; maybe 0 sum $ initM (empty :: Array D Ix1 Int)
--   0
--   </pre>
initM :: (Source r Ix1 e, MonadThrow m) => Vector r e -> m (Vector r e)

-- | <i>O(1)</i> - Get a vector without the first element. Never fails
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; tail (0 ..: 10)
--   Array D Seq (Sz1 9)
--     [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   
--   &gt;&gt;&gt; tail (empty :: Array D Ix1 Int)
--   Array D Seq (Sz1 0)
--     [  ]
--   </pre>
tail :: Source r Ix1 e => Vector r e -> Vector r e

-- | <i>O(1)</i> - Get a vector without the first element. Throws an error
--   on empty
--   
--   <h4><b>Examples</b></h4>
--   
--   λ&gt; tail' (0 ..: 10) Array D Seq (Sz1 9) [ 1, 2, 3, 4, 5, 6, 7, 8, 9
--   ] λ&gt; tail' (empty :: Array D Ix1 Int) Array D *** Exception:
--   SizeEmptyException: (Sz1 0) corresponds to an empty array
tail' :: Source r Ix1 e => Vector r e -> Vector r e

-- | <i>O(1)</i> - Get the vector without the first element. Throws an
--   error on empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; tailM (0 ..: 10)
--   Array D Seq (Sz1 9)
--     [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   
--   &gt;&gt;&gt; maybe 0 sum $ tailM (0 ..: 10)
--   45
--   
--   &gt;&gt;&gt; maybe 0 sum $ tailM (empty :: Array D Ix1 Int)
--   0
--   </pre>
tailM :: (Source r Ix1 e, MonadThrow m) => Vector r e -> m (Vector r e)

-- | <i>O(1)</i> - Get the vector with the first <tt>n</tt> elements. Never
--   fails
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 (0 ..: 10)
--   Array D Seq (Sz1 5)
--     [ 0, 1, 2, 3, 4 ]
--   
--   &gt;&gt;&gt; take (-5) (0 ..: 10)
--   Array D Seq (Sz1 0)
--     [  ]
--   
--   &gt;&gt;&gt; take 100 (0 ..: 10)
--   Array D Seq (Sz1 10)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   
--   &gt;&gt;&gt; 
--   </pre>
take :: Source r Ix1 e => Sz1 -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Get the vector with the first <tt>n</tt> elements.
--   Throws an error size is less than <tt>n</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take' 0 (0 ..: 0)
--   Array D Seq (Sz1 0)
--     [  ]
--   
--   &gt;&gt;&gt; take' 5 (0 ..: 10)
--   Array D Seq (Sz1 5)
--     [ 0, 1, 2, 3, 4 ]
--   
--   &gt;&gt;&gt; take' 15 (0 ..: 10)
--   Array D *** Exception: SizeSubregionException: (Sz1 10) is to small for 0 (Sz1 15)
--   </pre>
take' :: Source r Ix1 e => Sz1 -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Get the vector with the first <tt>n</tt> elements.
--   Throws an error size is less than <tt>n</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; takeM 5 (0 ..: 10)
--   Array D Seq (Sz1 5)
--     [ 0, 1, 2, 3, 4 ]
--   
--   &gt;&gt;&gt; maybe 0 sum $ takeM 5 (0 ..: 10)
--   10
--   
--   &gt;&gt;&gt; maybe (-1) sum $ takeM 15 (0 ..: 10)
--   -1
--   </pre>
takeM :: (Source r Ix1 e, MonadThrow m) => Sz1 -> Vector r e -> m (Vector r e)

-- | Slice a manifest vector in such a way that it will contain all initial
--   elements that satisfy the supplied predicate.
takeWhile :: Manifest r Ix1 e => (e -> Bool) -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Get a <a>Stream</a> vector with the first <tt>n</tt>
--   elements. Never fails
--   
--   <h4><b>Examples</b></h4>
stake :: Stream r Ix1 e => Sz1 -> Vector r e -> Vector DS e

-- | <h4><b>Examples</b></h4>
drop :: Source r Ix1 e => Sz1 -> Vector r e -> Vector r e

-- | Slice a manifest vector in such a way that it will not contain all
--   initial elements that satisfy the supplied predicate.
dropWhile :: Manifest r Ix1 e => (e -> Bool) -> Vector r e -> Vector r e

-- | <h4><b>Examples</b></h4>
drop' :: Source r Ix1 e => Sz1 -> Vector r e -> Vector r e

-- | <h4><b>Examples</b></h4>
dropM :: (Source r Ix1 e, MonadThrow m) => Sz1 -> Vector r e -> m (Vector r e)

-- | Keep all but the first <tt>n</tt> elements from the delayed stream
--   vector.
--   
--   <h4><b>Examples</b></h4>
sdrop :: Stream r Ix1 e => Sz1 -> Vector r e -> Vector DS e

-- | Create an Array with no elements. By itself it is not particularly
--   useful, but it serves as a nice base for constructing larger arrays.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; xs = empty @DL @Ix1 @Double
--   
--   &gt;&gt;&gt; snoc (cons 4 (cons 5 xs)) 22
--   Array DL Seq (Sz1 3)
--     [ 4.0, 5.0, 22.0 ]
--   </pre>
empty :: forall r ix e. Construct r ix e => Array r ix e

-- | Create an empty delayed stream vector
--   
--   <h4><b>Examples</b></h4>
sempty :: Vector DS e

-- | Create an Array with a single element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; singleton 7 :: Array D Ix4 Double
--   Array D Seq (Sz (1 :&gt; 1 :&gt; 1 :. 1))
--     [ [ [ [ 7.0 ]
--         ]
--       ]
--     ]
--   </pre>
--   
--   Instead of specifying type signature we could use
--   <tt>TypeApplications</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; singleton @U @Ix4 @Double 7
--   Array U Seq (Sz (1 :&gt; 1 :&gt; 1 :. 1))
--     [ [ [ [ 7.0 ]
--         ]
--       ]
--     ]
--   </pre>
singleton :: forall r ix e. Construct r ix e => e -> Array r ix e

-- | Create a delayed stream vector with a single element
--   
--   <h4><b>Examples</b></h4>
ssingleton :: e -> Vector DS e

-- | <i>O(1)</i> - Add an element to the vector from the left side
cons :: Load r Ix1 e => e -> Vector r e -> Vector DL e

-- | <i>O(1)</i> - Add an element to the vector from the right side
snoc :: Load r Ix1 e => Vector r e -> e -> Vector DL e
replicate :: Construct r ix e => Comp -> Sz ix -> e -> Array r ix e

-- | Replicate the same element <tt>n</tt> times
--   
--   <h4><b>Examples</b></h4>
sreplicate :: Sz1 -> e -> Vector DS e

-- | Create a delayed vector of length <tt>n</tt> with a function that maps
--   an index to an element. Same as <tt>makeLinearArray</tt>
--   
--   <h4><b>Examples</b></h4>
generate :: Comp -> Sz1 -> (Ix1 -> e) -> Vector D e

-- | Create a delayed stream vector of length <tt>n</tt> with a function
--   that maps an index to an element. Same as <tt>makeLinearArray</tt>
--   
--   <h4><b>Examples</b></h4>
sgenerate :: Sz1 -> (Ix1 -> e) -> Vector DS e

-- | Create a delayed stream vector of infinite length by repeatedly
--   applying a function to the initial value.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; stake 10 $ siterate succ 'a'
--   Array DS Seq (Sz1 10)
--     [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' ]
--   </pre>
siterate :: (e -> e) -> e -> Vector DS e

-- | Create a delayed stream vector of length <tt>n</tt> by repeatedly
--   applying a function to the initial value.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; siterateN 10 succ 'a'
--   Array DS Seq (Sz1 10)
--     [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' ]
--   </pre>
siterateN :: Sz1 -> (e -> e) -> e -> Vector DS e

-- | Create a vector by using the same monadic action <tt>n</tt> times
--   
--   <h4><b>Examples</b></h4>
sreplicateM :: Monad m => Sz1 -> m e -> m (Vector DS e)

-- | Create a delayed stream vector of length <tt>n</tt> with a monadic
--   action that from an index generates an element.
--   
--   <h4><b>Examples</b></h4>
sgenerateM :: Monad m => Sz1 -> (Ix1 -> m e) -> m (Vector DS e)

-- | Create a delayed stream vector of length <tt>n</tt> by repeatedly
--   apply a monadic action to the initial value.
--   
--   <h4><b>Examples</b></h4>
siterateNM :: Monad m => Sz1 -> (e -> m e) -> e -> m (Vector DS e)

-- | Right unfolding function. Useful when it is unknown ahead of time how
--   many elements a vector will have.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; sunfoldr (\i -&gt; if i &lt; 9 then Just (i * i, i + 1) else Nothing) (0 :: Int)
--   Array DS Seq (Sz1 9)
--     [ 0, 1, 4, 9, 16, 25, 36, 49, 64 ]
--   </pre>
sunfoldr :: (s -> Maybe (e, s)) -> s -> Vector DS e

-- | <i>O(n)</i> - Same as <a>unfoldr</a>, but with monadic generating
--   function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad (when, guard)
--   
--   &gt;&gt;&gt; sunfoldrM (\i -&gt; when (i == 0) (Left "Zero denominator") &gt;&gt; Right (guard (i &lt; 5) &gt;&gt; Just (100 `div` i, i + 1))) (-10 :: Int)
--   Left "Zero denominator"
--   
--   &gt;&gt;&gt; sunfoldrM (\i -&gt; when (i == 0) (Left "Zero denominator") &gt;&gt; Right (guard (i &lt; -5) &gt;&gt; Just (100 `div` i, i + 1))) (-10 :: Int)
--   Right (Array DS Seq (Sz1 5)
--     [ -10, -12, -13, -15, -17 ]
--   )
--   </pre>
sunfoldrM :: Monad m => (s -> m (Maybe (e, s))) -> s -> m (Vector DS e)

-- | <i>O(n)</i> - Right unfolding function with at most <tt>n</tt> number
--   of elements.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; sunfoldrN 9 (\i -&gt; Just (i*i, i + 1)) (0 :: Int)
--   Array DS Seq (Sz1 9)
--     [ 0, 1, 4, 9, 16, 25, 36, 49, 64 ]
--   </pre>
sunfoldrN :: Sz1 -> (s -> Maybe (e, s)) -> s -> Vector DS e

-- | <i>O(n)</i> - Same as <a>unfoldrN</a>, but with monadic generating
--   function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad (guard)
--   
--   &gt;&gt;&gt; sunfoldrNM 6 (\i -&gt; print i &gt;&gt; pure (guard (i &lt; 5) &gt;&gt; Just (i * i, i + 1))) (10 :: Int)
--   10
--   Array DS Seq (Sz1 0)
--     [  ]
--   
--   &gt;&gt;&gt; sunfoldrNM 6 (\i -&gt; print i &gt;&gt; pure (guard (i &lt; 15) &gt;&gt; Just (i * i, i + 1))) (10 :: Int)
--   10
--   11
--   12
--   13
--   14
--   15
--   Array DS Seq (Sz1 5)
--     [ 100, 121, 144, 169, 196 ]
--   </pre>
sunfoldrNM :: Monad m => Sz1 -> (s -> m (Maybe (e, s))) -> s -> m (Vector DS e)

-- | <i>O(n)</i> - Similar to <a>unfoldrN</a>, except the length of the
--   resulting vector will be exactly <tt>n</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sunfoldrExactN 10 (\i -&gt; (i * i, i + 1)) (10 :: Int)
--   Array DS Seq (Sz1 10)
--     [ 100, 121, 144, 169, 196, 225, 256, 289, 324, 361 ]
--   </pre>
sunfoldrExactN :: Sz1 -> (s -> (e, s)) -> s -> Vector DS e

-- | <i>O(n)</i> - Similar to <tt>unfoldrNM</tt>, except the length of the
--   resulting vector will be exactly <tt>n</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   λ&gt; sunfoldrExactNM 11 (i -&gt; pure (100 <a>div</a> i, i + 1)) (-10
--   :: Int) Array DS *** Exception: divide by zero λ&gt; sunfoldrExactNM
--   11 (i -&gt; guard (i /= 0) &gt;&gt; Just (100 <a>div</a> i, i + 1))
--   (-10 :: Int) Nothing λ&gt; sunfoldrExactNM 9 (i -&gt; guard (i /= 0)
--   &gt;&gt; Just (100 <a>div</a> i, i + 1)) (-10 :: Int) Just (Array DS
--   Seq (Sz1 9) [ -10, -12, -13, -15, -17, -20, -25, -34, -50 ] )
sunfoldrExactNM :: Monad m => Sz1 -> (s -> m (e, s)) -> s -> m (Vector DS e)

-- | Handy synonym for <tt><a>rangeInclusive</a> <a>Seq</a></tt>. Similar
--   to <tt>..</tt> for list.
--   
--   <pre>
--   &gt;&gt;&gt; Ix1 4 ... 10
--   Array D Seq (Sz1 7)
--     [ 4, 5, 6, 7, 8, 9, 10 ]
--   </pre>
(...) :: Index ix => ix -> ix -> Array D ix ix
infix 4 ...

-- | Handy synonym for <tt><a>range</a> <a>Seq</a></tt>
--   
--   <pre>
--   &gt;&gt;&gt; Ix1 4 ..: 10
--   Array D Seq (Sz1 6)
--     [ 4, 5, 6, 7, 8, 9 ]
--   </pre>
(..:) :: Index ix => ix -> ix -> Array D ix ix
infix 4 ..:

-- | Same as <a>enumFromStepN</a> with step <tt>dx = 1</tt>.
--   
--   <i>Related</i>: <a>senumFromN</a>, <a>senumFromStepN</a>,
--   <a>enumFromStepN</a>, <a>rangeSize</a>, <a>rangeStepSize</a>,
--   <a>range</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; enumFromN Seq (5 :: Double) 3
--   Array D Seq (Sz1 3)
--     [ 5.0, 6.0, 7.0 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFromTo</a></tt></i> Very similar to <tt>[i
--   .. i + n - 1]</tt>, except that <tt>senumFromN</tt> is faster, but it
--   only works for <a>Num</a> and not for <a>Enum</a> elements</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromN</a></tt></i></li>
--   </ul>
enumFromN :: Num e => Comp -> e -> Sz1 -> Vector D e

-- | <i>O(n)</i> - Enumerate from a starting number <tt>x</tt> exactly
--   <tt>n</tt> times with a step <tt>1</tt>.
--   
--   <i>Related</i>: <a>senumFromStepN</a>, <a>enumFromN</a>,
--   <a>enumFromStepN</a>, <a>rangeSize</a>, <a>rangeStepSize</a>,
--   <a>range</a>, <tt>rangeStep</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; senumFromN (10 :: Int) 9
--   Array DS Seq (Sz1 9)
--     [ 10, 11, 12, 13, 14, 15, 16, 17, 18 ]
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFromTo</a></tt></i> Very similar to <tt>[x
--   .. x + n - 1]</tt>, except that <a>senumFromN</a> is faster and it
--   only works for <a>Num</a> and not for <a>Enum</a> elements</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromN</a></tt></i> Uses exactly
--   the same implementation underneath.</li>
--   </ul>
senumFromN :: Num e => e -> Sz1 -> Vector DS e

-- | Enumerate from a starting number <tt>x</tt> exactly <tt>n</tt> times
--   with a custom step value <tt>dx</tt>. Unlike <a>senumFromStepN</a>,
--   there is no dependency on neigboring elements therefore
--   <a>enumFromStepN</a> is parallelizable.
--   
--   <i>Related</i>: <a>senumFromN</a>, <a>senumFromStepN</a>,
--   <a>enumFromN</a>, <a>rangeSize</a>, <a>rangeStepSize</a>,
--   <a>range</a>, <a>rangeStepM</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; enumFromStepN Seq 1 (0.1 :: Double) 5
--   Array D Seq (Sz1 5)
--     [ 1.0, 1.1, 1.2, 1.3, 1.4 ]
--   
--   &gt;&gt;&gt; enumFromStepN Seq (-pi :: Float) (pi/4) 9
--   Array D Seq (Sz1 9)
--     [ -3.1415927, -2.3561945, -1.5707964, -0.78539824, 0.0, 0.78539824, 1.5707963, 2.3561947, 3.1415927 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFrom</a></tt></i> Similar to <tt>take n [x,
--   x + dx ..]</tt>, except that <a>enumFromStepN</a> is parallelizable
--   and it only works for <a>Num</a> and not for <a>Enum</a> elements.
--   Floating point value will be slightly different as well.</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromStepN</a></tt></i> Similar
--   in the outcome, but very different in the way it works.</li>
--   </ul>
enumFromStepN :: Num e => Comp -> e -> e -> Sz1 -> Vector D e

-- | <i>O(n)</i> - Enumerate from a starting number <tt>x</tt> exactly
--   <tt>n</tt> times with a custom step value <tt>dx</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; senumFromStepN (5 :: Int) 2 10
--   Array DS Seq (Sz1 10)
--     [ 5, 7, 9, 11, 13, 15, 17, 19, 21, 23 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFrom</a></tt></i> Just like <tt>take n [x, x
--   + dx ..]</tt>, except that <a>senumFromN</a> is faster and it only
--   works for <a>Num</a> and not for <a>Enum</a> elements</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromStepN</a></tt></i> Uses
--   exactly the same implementation underneath.</li>
--   </ul>
senumFromStepN :: Num e => e -> e -> Sz1 -> Vector DS e

-- | Append two vectors together
--   
--   <i>Related</i>: <tt>appendM</tt>, <a>appendOuterM</a>,
--   
--   <h4><b>Examples</b></h4>
--   
--   λ&gt; sappend (1 ..: 6) (senumFromStepN 6 (-1) 6) Array DS Seq (Sz1
--   11) [ 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1 ]
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Data.Semigroup.<a>&lt;&gt;</a></tt></i> <a>DS</a> and
--   <a>DL</a> arrays have instances for <a>Semigroup</a>, so they will
--   work in a similar fashion. <a>sappend</a> differs in that it accepts
--   <a>Stream</a> arrays with possibly different representations.</li>
--   <li><i><tt>Data.List.<a>++</a></tt></i> Same operation, but for
--   lists.</li>
--   <li><i><tt>Data.Vector.Generic.<a>++</a></tt></i> Uses exactly the
--   same implementation underneath as <a>sappend</a>, except that it
--   cannot append two vectors with different memory representations.</li>
--   </ul>
sappend :: (Stream r1 Ix1 e, Stream r2 Ix1 e) => Vector r1 e -> Vector r2 e -> Vector DS e

-- | Concat vectors together
--   
--   <i>Related</i>: <tt>concatM</tt>, <a>concatOuterM</a>,
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat [2 ... 6, empty, singleton 1, generate Seq 5 id]
--   Array DS Seq (Sz1 11)
--     [ 2, 3, 4, 5, 6, 1, 0, 1, 2, 3, 4 ]
--   
--   &gt;&gt;&gt; sconcat [senumFromN 2 5, sempty, ssingleton 1, sgenerate 5 id]
--   Array DS Seq (Sz1 11)
--     [ 2, 3, 4, 5, 6, 1, 0, 1, 2, 3, 4 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Data.Monoid.<a>mconcat</a></tt></i> <a>DS</a> and <a>DL</a>
--   arrays have instances for <a>Monoid</a>, so they will work in a
--   similar fashion. <a>sconcat</a> differs in that it accepts
--   <a>Stream</a> arrays of other representations.</li>
--   <li><i><tt>Data.List.<a>concat</a></tt></i> Same operation, but for
--   lists.</li>
--   <li><i><tt>Data.Vector.Generic.<a>concat</a></tt></i> Uses exactly the
--   same implementation underneath as <a>sconcat</a>.</li>
--   </ul>
sconcat :: Stream r Ix1 e => [Vector r e] -> Vector DS e

-- | Map a function over a stream vector
--   
--   <h4><b>Examples</b></h4>
smap :: Stream r ix a => (a -> b) -> Array r ix a -> Vector DS b

-- | Map an index aware function over a stream vector
--   
--   <h4><b>Examples</b></h4>
simap :: Stream r ix a => (ix -> a -> b) -> Array r ix a -> Vector DS b

-- | Traverse a stream vector with an applicative function.
--   
--   <h4><b>Examples</b></h4>
straverse :: (Stream r ix a, Applicative f) => (a -> f b) -> Array r ix a -> f (Vector DS b)

-- | Traverse a stream vector with an index aware applicative function.
--   
--   <h4><b>Examples</b></h4>
sitraverse :: (Stream r ix a, Applicative f) => (ix -> a -> f b) -> Array r ix a -> f (Vector DS b)

-- | Traverse a stream vector with a monadic function.
--   
--   <h4><b>Examples</b></h4>
smapM :: (Stream r ix a, Monad m) => (a -> m b) -> Array r ix a -> m (Vector DS b)

-- | Traverse a stream vector with a monadic function, while discarding the
--   result
--   
--   <h4><b>Examples</b></h4>
smapM_ :: (Stream r ix a, Monad m) => (a -> m b) -> Array r ix a -> m ()

-- | Traverse a stream vector with a monadic index aware function.
--   
--   Corresponds to: <tt>mapM (uncurry f) . imap (,) v</tt>
--   
--   <h4><b>Examples</b></h4>
simapM :: (Stream r ix a, Monad m) => (ix -> a -> m b) -> Array r ix a -> m (Vector DS b)

-- | Traverse a stream vector with a monadic index aware function, while
--   discarding the result
--   
--   <h4><b>Examples</b></h4>
simapM_ :: (Stream r ix a, Monad m) => (ix -> a -> m b) -> Array r ix a -> m ()

-- | Same as <a>smapM</a>, but with arguments flipped.
--   
--   <h4><b>Examples</b></h4>
sforM :: (Stream r ix a, Monad m) => Array r ix a -> (a -> m b) -> m (Vector DS b)

-- | Same as <a>smapM_</a>, but with arguments flipped.
--   
--   <h4><b>Examples</b></h4>
sforM_ :: (Stream r ix a, Monad m) => Array r ix a -> (a -> m b) -> m ()

-- | Same as <a>simapM</a>, but with arguments flipped.
--   
--   <h4><b>Examples</b></h4>
siforM :: (Stream r ix a, Monad m) => Array r ix a -> (ix -> a -> m b) -> m (Vector DS b)

-- | Same as <a>simapM_</a>, but with arguments flipped.
--   
--   <h4><b>Examples</b></h4>
siforM_ :: (Stream r ix a, Monad m) => Array r ix a -> (ix -> a -> m b) -> m ()

-- | Zip two arrays in a row-major order together together into a flat
--   vector. Resulting length of a vector will be the smallest number of
--   elements of the supplied arrays.
--   
--   <h4><b>Examples</b></h4>
szip :: (Stream ra Ix1 a, Stream rb Ix1 b) => Vector ra a -> Vector rb b -> Vector DS (a, b)

szip3 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c) => Vector ra a -> Vector rb b -> Vector rc c -> Vector DS (a, b, c)

szip4 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d) => Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector DS (a, b, c, d)

szip5 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e) => Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector DS (a, b, c, d, e)

szip6 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f) => Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> Vector DS (a, b, c, d, e, f)

-- | <h4><b>Examples</b></h4>
szipWith :: (Stream ra Ix1 a, Stream rb Ix1 b) => (a -> b -> c) -> Vector ra a -> Vector rb b -> Vector DS c

szipWith3 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c) => (a -> b -> c -> d) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector DS d

szipWith4 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d) => (a -> b -> c -> d -> e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector DS e

szipWith5 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e) => (a -> b -> c -> d -> e -> f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector DS f

szipWith6 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f) => (a -> b -> c -> d -> e -> f -> g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> Vector DS g

-- | <h4><b>Examples</b></h4>
sizipWith :: (Stream ra Ix1 a, Stream rb Ix1 b) => (Ix1 -> a -> b -> c) -> Vector ra a -> Vector rb b -> Vector DS c

sizipWith3 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c) => (Ix1 -> a -> b -> c -> d) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector DS d

sizipWith4 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d) => (Ix1 -> a -> b -> c -> d -> e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector DS e

sizipWith5 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e) => (Ix1 -> a -> b -> c -> d -> e -> f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector DS f

sizipWith6 :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f) => (Ix1 -> a -> b -> c -> d -> e -> f -> g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> Vector DS g

-- | <h4><b>Examples</b></h4>
szipWithM :: (Stream ra Ix1 a, Stream rb Ix1 b, Monad m) => (a -> b -> m c) -> Vector ra a -> Vector rb b -> m (Vector DS c)

szipWith3M :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Monad m) => (a -> b -> c -> m d) -> Vector ra a -> Vector rb b -> Vector rc c -> m (Vector DS d)

szipWith4M :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Monad m) => (a -> b -> c -> d -> m e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> m (Vector DS e)

szipWith5M :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Monad m) => (a -> b -> c -> d -> e -> m f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> m (Vector DS f)

szipWith6M :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f, Monad m) => (a -> b -> c -> d -> e -> f -> m g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> m (Vector DS g)

-- | <h4><b>Examples</b></h4>
sizipWithM :: (Stream ra Ix1 a, Stream rb Ix1 b, Monad m) => (Ix1 -> a -> b -> m c) -> Vector ra a -> Vector rb b -> m (Vector DS c)

sizipWith3M :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Monad m) => (Ix1 -> a -> b -> c -> m d) -> Vector ra a -> Vector rb b -> Vector rc c -> m (Vector DS d)

sizipWith4M :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Monad m) => (Ix1 -> a -> b -> c -> d -> m e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> m (Vector DS e)

sizipWith5M :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Monad m) => (Ix1 -> a -> b -> c -> d -> e -> m f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> m (Vector DS f)

-- | <h4><b>Examples</b></h4>
sizipWith6M :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f, Monad m) => (Ix1 -> a -> b -> c -> d -> e -> f -> m g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> m (Vector DS g)

-- | <h4><b>Examples</b></h4>
szipWithM_ :: (Stream ra Ix1 a, Stream rb Ix1 b, Monad m) => (a -> b -> m c) -> Vector ra a -> Vector rb b -> m ()

szipWith3M_ :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Monad m) => (a -> b -> c -> m d) -> Vector ra a -> Vector rb b -> Vector rc c -> m ()

szipWith4M_ :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Monad m) => (a -> b -> c -> d -> m e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> m ()

szipWith5M_ :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Monad m) => (a -> b -> c -> d -> e -> m f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> m ()

szipWith6M_ :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f, Monad m) => (a -> b -> c -> d -> e -> f -> m g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> m ()

-- | <h4><b>Examples</b></h4>
sizipWithM_ :: (Stream ra Ix1 a, Stream rb Ix1 b, Monad m) => (Ix1 -> a -> b -> m c) -> Vector ra a -> Vector rb b -> m ()

sizipWith3M_ :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Monad m) => (Ix1 -> a -> b -> c -> m d) -> Vector ra a -> Vector rb b -> Vector rc c -> m ()

sizipWith4M_ :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Monad m) => (Ix1 -> a -> b -> c -> d -> m e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> m ()

sizipWith5M_ :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Monad m) => (Ix1 -> a -> b -> c -> d -> e -> m f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> m ()

sizipWith6M_ :: (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f, Monad m) => (Ix1 -> a -> b -> c -> d -> e -> f -> m g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> m ()

-- | Sequentially filter out elements from the array according to the
--   supplied predicate.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = makeArrayR D Seq (Sz2 3 4) fromIx2
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (3 :. 4))
--     [ [ (0,0), (0,1), (0,2), (0,3) ]
--     , [ (1,0), (1,1), (1,2), (1,3) ]
--     , [ (2,0), (2,1), (2,2), (2,3) ]
--     ]
--   
--   &gt;&gt;&gt; sfilter (even . fst) arr
--   Array DS Seq (Sz1 8)
--     [ (0,0), (0,1), (0,2), (0,3), (2,0), (2,1), (2,2), (2,3) ]
--   </pre>
sfilter :: Stream r ix e => (e -> Bool) -> Array r ix e -> Vector DS e

-- | Similar to <a>sfilter</a>, but filter with an index aware function.
--   
--   <h4><b>Examples</b></h4>
sifilter :: Stream r ix a => (ix -> a -> Bool) -> Array r ix a -> Vector DS a

-- | Sequentially filter out elements from the array according to the
--   supplied applicative predicate.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = makeArrayR D Seq (Sz2 3 4) fromIx2
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (3 :. 4))
--     [ [ (0,0), (0,1), (0,2), (0,3) ]
--     , [ (1,0), (1,1), (1,2), (1,3) ]
--     , [ (2,0), (2,1), (2,2), (2,3) ]
--     ]
--   
--   &gt;&gt;&gt; sfilterM (Just . odd . fst) arr
--   Just (Array DS Seq (Sz1 4)
--     [ (1,0), (1,1), (1,2), (1,3) ]
--   )
--   
--   &gt;&gt;&gt; sfilterM (\ix@(_, j) -&gt; print ix &gt;&gt; return (even j)) arr
--   (0,0)
--   (0,1)
--   (0,2)
--   (0,3)
--   (1,0)
--   (1,1)
--   (1,2)
--   (1,3)
--   (2,0)
--   (2,1)
--   (2,2)
--   (2,3)
--   Array DS Seq (Sz1 6)
--     [ (0,0), (0,2), (1,0), (1,2), (2,0), (2,2) ]
--   </pre>
sfilterM :: (Stream r ix e, Applicative f) => (e -> f Bool) -> Array r ix e -> f (Vector DS e)

-- | Similar to <a>filterM</a>, but filter with an index aware function.
--   
--   Corresponds to: <tt><a>filterM</a> (uncurry f) . <a>simap</a> (,)</tt>
sifilterM :: (Stream r ix a, Applicative f) => (ix -> a -> f Bool) -> Array r ix a -> f (Vector DS a)

-- | Apply a function to each element of the array, while discarding
--   <a>Nothing</a> and keeping the <a>Maybe</a> result.
--   
--   <h4><b>Examples</b></h4>
smapMaybe :: Stream r ix a => (a -> Maybe b) -> Array r ix a -> Vector DS b

-- | Similar to <a>smapMaybe</a>, but with the <a>Applicative</a> function.
--   
--   Similar to <tt>mapMaybe id <a>$</a> mapM f arr</tt>
--   
--   <h4><b>Examples</b></h4>
smapMaybeM :: (Stream r ix a, Applicative f) => (a -> f (Maybe b)) -> Array r ix a -> f (Vector DS b)

-- | Keep all <a>Maybe</a>s and discard the <a>Nothing</a>s.
--   
--   <h4><b>Examples</b></h4>
scatMaybes :: Stream r ix (Maybe a) => Array r ix (Maybe a) -> Vector DS a

-- | Similar to <a>smapMaybe</a>, but map with an index aware function.
--   
--   <h4><b>Examples</b></h4>
simapMaybe :: Stream r ix a => (ix -> a -> Maybe b) -> Array r ix a -> Vector DS b

-- | Similar to <a>smapMaybeM</a>, but map with an index aware function.
--   
--   <h4><b>Examples</b></h4>
simapMaybeM :: (Stream r ix a, Applicative f) => (ix -> a -> f (Maybe b)) -> Array r ix a -> f (Vector DS b)

-- | <i>O(n)</i> - Perform a row-major search starting at <tt>0</tt> for an
--   element. Returns the index of the first occurance of an element or
--   <a>Nothing</a> if a predicate could not be satisifed after it was
--   applyied to all elements of the array.
findIndex :: Manifest r ix e => (e -> Bool) -> Array r ix e -> Maybe ix

-- | <h4><b>Examples</b></h4>
sfoldl :: Stream r ix e => (a -> e -> a) -> a -> Array r ix e -> a

-- | <h4><b>Examples</b></h4>
sfoldlM :: (Stream r ix e, Monad m) => (a -> e -> m a) -> a -> Array r ix e -> m a

-- | <h4><b>Examples</b></h4>
sfoldlM_ :: (Stream r ix e, Monad m) => (a -> e -> m a) -> a -> Array r ix e -> m ()

-- | <h4><b>Examples</b></h4>
sifoldl :: Stream r ix e => (a -> ix -> e -> a) -> a -> Array r ix e -> a

-- | <h4><b>Examples</b></h4>
sifoldlM :: (Stream r ix e, Monad m) => (a -> ix -> e -> m a) -> a -> Array r ix e -> m a

-- | <h4><b>Examples</b></h4>
sifoldlM_ :: (Stream r ix e, Monad m) => (a -> ix -> e -> m a) -> a -> Array r ix e -> m ()

-- | <h4><b>Examples</b></h4>
sfoldl1' :: Stream r ix e => (e -> e -> e) -> Array r ix e -> e

-- | <h4><b>Examples</b></h4>
sfoldl1M :: (Stream r ix e, MonadThrow m) => (e -> e -> m e) -> Array r ix e -> m e

-- | <h4><b>Examples</b></h4>
sfoldl1M_ :: (Stream r ix e, MonadThrow m) => (e -> e -> m e) -> Array r ix e -> m ()

-- | <h4><b>Examples</b></h4>
sor :: Stream r ix Bool => Array r ix Bool -> Bool

-- | <h4><b>Examples</b></h4>
sand :: Stream r ix Bool => Array r ix Bool -> Bool

-- | <h4><b>Examples</b></h4>
sall :: Stream r ix e => (e -> Bool) -> Array r ix e -> Bool

-- | <h4><b>Examples</b></h4>
sany :: Stream r ix e => (e -> Bool) -> Array r ix e -> Bool

-- | Add all elements of the array together
--   
--   <i>Related</i>: <a>sum</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.ssum $ V.sfromList [10, 3, 70, 5 :: Int]
--   88
--   </pre>
ssum :: (Num e, Stream r ix e) => Array r ix e -> e

-- | Multiply all elements of the array together
--   
--   <i>Related</i>: <a>product</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.sproduct $ V.sfromList [10, 3, 70, 5 :: Int]
--   10500
--   </pre>
sproduct :: (Num e, Stream r ix e) => Array r ix e -> e

-- | <i>O(n)</i> - Find the largest value in the array. Throws an error on
--   empty.
--   
--   <i>Related</i>: <a>smaximumM</a>, <a>maximum</a>, <tt>maximumM</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.smaximum' $ V.sfromList [10, 3, 70, 5 :: Int]
--   70
--   
--   &gt;&gt;&gt; V.smaximum' (V.empty :: Vector D Int)
--   *** Exception: SizeEmptyException: (Sz1 0) corresponds to an empty array
--   </pre>
smaximum' :: (Ord e, Stream r ix e) => Array r ix e -> e

-- | <i>O(n)</i> - Find the largest value in the array.
--   
--   <i>Related</i>: <tt>smaximum</tt>, <a>maximum</a>, <tt>maximumM</tt>.
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a> when array
--   is empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.smaximumM $ V.sfromList [10, 3, 70, 5 :: Int]
--   70
--   
--   &gt;&gt;&gt; V.smaximumM (V.empty :: Vector D Int) :: Maybe Int
--   Nothing
--   </pre>
smaximumM :: (Ord e, Stream r ix e, MonadThrow m) => Array r ix e -> m e

-- | <i>O(n)</i> - Find the smallest value in the array. Throws an error on
--   empty.
--   
--   <i>Related</i>: <a>sminimumM</a>, <a>minimum</a>, <tt>minimumM</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.sminimum' $ V.sfromList [10, 3, 70, 5 :: Int]
--   3
--   
--   &gt;&gt;&gt; V.sminimum' (V.empty :: Array D Ix2 Int)
--   *** Exception: SizeEmptyException: (Sz (0 :. 0)) corresponds to an empty array
--   </pre>
sminimum' :: (Ord e, Stream r ix e) => Array r ix e -> e

-- | <i>O(n)</i> - Find the smallest value in the array.
--   
--   <i>Related</i>: <tt>sminimum</tt>`, <a>minimum</a>, <tt>minimumM</tt>.
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a> when array
--   is empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.sminimumM $ V.sfromList [10, 3, 70, 5 :: Int]
--   3
--   
--   &gt;&gt;&gt; V.sminimumM (V.empty :: Array D Ix2 Int) :: Maybe Int
--   Nothing
--   </pre>
sminimumM :: (Ord e, Stream r ix e, MonadThrow m) => Array r ix e -> m e

-- | Convert an array to a list by the means of a delayed stream vector.
--   
--   <i>Related</i>: <tt>toList</tt>
--   
--   <h4><b>Examples</b></h4>
stoList :: Stream r ix e => Array r ix e -> [e]

-- | Convert a flat list into a vector
fromList :: forall r e. Mutable r Ix1 e => Comp -> [e] -> Array r Ix1 e

-- | Convert a list to a delayed stream vector
--   
--   <i>Related</i>: <a>fromList</a>, <tt>fromListN</tt>, <a>sfromListN</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sfromList ([] :: [Int])
--   Array DS Seq (Sz1 0)
--     [  ]
--   
--   &gt;&gt;&gt; sfromList ([1,2,3] :: [Int])
--   Array DS Seq (Sz1 3)
--     [ 1, 2, 3 ]
--   </pre>
sfromList :: [e] -> Vector DS e

-- | Convert a list to a delayed stream vector. Length of the resulting
--   vector will be at most <tt>n</tt>. This version isn't really more
--   efficient then <a>sfromList</a>, but there is <a>unsafeFromListN</a>
--   
--   <i>Related</i>: <a>fromList</a>, <tt>fromListN</tt>, <a>sfromList</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sfromListN 10 [1 :: Int ..]
--   Array DS Seq (Sz1 10)
--     [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
--   
--   &gt;&gt;&gt; sfromListN 10 [1 :: Int .. 5]
--   Array DS Seq (Sz1 5)
--     [ 1, 2, 3, 4, 5 ]
--   </pre>
sfromListN :: Sz1 -> [e] -> Vector DS e

-- | Ensure that Array is computed, i.e. represented with concrete elements
--   in memory, hence is the <a>Mutable</a> type class restriction. Use
--   <a>setComp</a> if you'd like to change computation strategy before
--   calling <tt>compute</tt>
compute :: forall r ix e r'. (Mutable r ix e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Compute array sequentially disregarding predefined computation
--   strategy. Very much the same as <a>computePrimM</a>, but executed in
--   <a>ST</a>, thus pure.
computeS :: forall r ix e r'. (Mutable r ix e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Very similar to <a>compute</a>, but computes an array inside the
--   <a>IO</a> monad. Despite being deterministic and referentially
--   transparent, because this is an <a>IO</a> action it can be very useful
--   for enforcing the order of evaluation. Should be a prefered way of
--   computing an array during benchmarking.
computeIO :: forall r ix e r' m. (Mutable r ix e, Load r' ix e, MonadIO m) => Array r' ix e -> m (Array r ix e)

-- | Compute an array in <a>PrimMonad</a> sequentially disregarding
--   predefined computation strategy.
computePrimM :: forall r ix e r' m. (Mutable r ix e, Load r' ix e, PrimMonad m) => Array r' ix e -> m (Array r ix e)

-- | Just as <a>compute</a>, but let's you supply resulting representation
--   type as an argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; computeAs P $ range Seq (Ix1 0) 10
--   Array P Seq (Sz1 10)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   </pre>
computeAs :: (Mutable r ix e, Load r' ix e) => r -> Array r' ix e -> Array r ix e

-- | Same as <a>compute</a> and <a>computeAs</a>, but let's you supply
--   resulting representation type as a proxy argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   Useful only really for cases when representation constructor or
--   <tt>TypeApplications</tt> extension aren't desireable for some reason:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Proxy
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; computeProxy (Proxy :: Proxy P) $ (^ (2 :: Int)) &lt;$&gt; range Seq (Ix1 0) 10
--   Array P Seq (Sz1 10)
--     [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 ]
--   </pre>
computeProxy :: (Mutable r ix e, Load r' ix e) => proxy r -> Array r' ix e -> Array r ix e

-- | This is just like <a>convert</a>, but restricted to <a>Source</a>
--   arrays. Will be a noop if resulting type is the same as the input.
computeSource :: forall r ix e r'. (Mutable r ix e, Source r' ix e) => Array r' ix e -> Array r ix e

-- | Same as <a>compute</a>, but with <a>Stride</a>.
--   
--   <i>O(n div k)</i> - Where <tt>n</tt> is numer of elements in the
--   source array and <tt>k</tt> is number of elements in the stride.
computeWithStride :: forall r ix e r'. (Mutable r ix e, StrideLoad r' ix e) => Stride ix -> Array r' ix e -> Array r ix e

-- | Same as <a>computeWithStride</a>, but with ability to specify
--   resulting array representation.
computeWithStrideAs :: (Mutable r ix e, StrideLoad r' ix e) => r -> Stride ix -> Array r' ix e -> Array r ix e

-- | <i>O(n)</i> - Make an exact immutable copy of an Array.
clone :: Mutable r ix e => Array r ix e -> Array r ix e

-- | <i>O(n)</i> - conversion between array types. A full copy will occur,
--   unless when the source and result arrays are of the same
--   representation, in which case it is an <i>O(1)</i> operation.
convert :: forall r ix e r'. (Mutable r ix e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Same as <a>convert</a>, but let's you supply resulting representation
--   type as an argument.
convertAs :: (Mutable r ix e, Load r' ix e) => r -> Array r' ix e -> Array r ix e

-- | Same as <a>convert</a> and <a>convertAs</a>, but let's you supply
--   resulting representation type as a proxy argument.
convertProxy :: (Mutable r ix e, Load r' ix e) => proxy r -> Array r' ix e -> Array r ix e

-- | See <a>stake</a>.

-- | <i>Deprecated: In favor of <a>stake</a></i>
takeS :: Stream r ix e => Sz1 -> Array r ix e -> Array DS Ix1 e

-- | See <a>sdrop</a>.

-- | <i>Deprecated: In favor of <a>sdrop</a></i>
dropS :: Stream r ix e => Sz1 -> Array r ix e -> Array DS Ix1 e

-- | See <a>sunfoldr</a>

-- | <i>Deprecated: In favor of <a>sunfoldr</a></i>
unfoldr :: (s -> Maybe (e, s)) -> s -> Vector DS e

-- | See <a>sunfoldrN</a>

-- | <i>Deprecated: In favor of <a>sunfoldrN</a></i>
unfoldrN :: Sz1 -> (s -> Maybe (e, s)) -> s -> Vector DS e

-- | See <a>sfilter</a>

-- | <i>Deprecated: In favor of <a>sfilter</a></i>
filterS :: Stream r ix e => (e -> Bool) -> Array r ix e -> Array DS Ix1 e

-- | Similar to <a>filterS</a>, but map with an index aware function.

-- | <i>Deprecated: In favor of <a>sifilter</a></i>
ifilterS :: Source r ix a => (ix -> a -> Bool) -> Array r ix a -> Array DS Ix1 a

-- | See <a>sfilterM</a>

-- | <i>Deprecated: In favor of <a>sfilterM</a></i>
filterM :: (Stream r ix e, Applicative f) => (e -> f Bool) -> Array r ix e -> f (Vector DS e)

-- | Similar to <a>filterM</a>, but map with an index aware function.

-- | <i>Deprecated: In favor of <a>sifilterM</a></i>
ifilterM :: (Source r ix a, Applicative f) => (ix -> a -> f Bool) -> Array r ix a -> f (Array DS Ix1 a)

-- | See <a>smapMaybe</a>

-- | <i>Deprecated: In favor of <a>smapMaybe</a></i>
mapMaybeS :: Stream r ix a => (a -> Maybe b) -> Array r ix a -> Vector DS b

-- | See <a>simapMaybe</a>

-- | <i>Deprecated: In favor of <a>simapMaybe</a></i>
imapMaybeS :: Source r ix a => (ix -> a -> Maybe b) -> Array r ix a -> Array DS Ix1 b

-- | See <a>smapMaybeM</a>

-- | <i>Deprecated: In favor of <a>smapMaybeM</a></i>
mapMaybeM :: (Stream r ix a, Applicative f) => (a -> f (Maybe b)) -> Array r ix a -> f (Vector DS b)

-- | See <a>simapMaybeM</a>

-- | <i>Deprecated: In favor of <a>simapMaybeM</a></i>
imapMaybeM :: (Source r ix a, Applicative f) => (ix -> a -> f (Maybe b)) -> Array r ix a -> f (Array DS Ix1 b)

-- | See <a>scatMaybes</a>

-- | <i>Deprecated: In favor of <a>scatMaybes</a></i>
catMaybesS :: Stream r ix (Maybe a) => Array r ix (Maybe a) -> Vector DS a

-- | See <a>traverseS</a>

-- | <i>Deprecated: In favor of <a>straverse</a></i>
traverseS :: (Stream r ix a, Applicative f) => (a -> f b) -> Array r ix a -> f (Vector DS b)


module Data.Massiv.Array.Mutable.Algorithms

-- | Mutable version of <a>quicksort</a>
quicksortM_ :: (Ord e, Mutable r Ix1 e, PrimMonad m) => Scheduler m () -> MVector (PrimState m) r e -> m ()

-- | Same as <a>quicksortM_</a>, but instead of <a>Ord</a> constraint
--   expects a custom <a>Ordering</a>.
quicksortByM_ :: (Mutable r Ix1 e, PrimMonad m) => (e -> e -> m Ordering) -> Scheduler m () -> MVector (PrimState m) r e -> m ()

-- | Partition elements of the supplied mutable vector according to the
--   predicate.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import Data.Massiv.Array.Mutable.Algorithms
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; m &lt;- thaw ([2,1,50,10,20,8] :: Array P Ix1 Int)
--   
--   &gt;&gt;&gt; unstablePartitionM m (&lt;= 10)
--   4
--   
--   &gt;&gt;&gt; freeze Seq m
--   Array P Seq (Sz1 6)
--     [ 2, 1, 8, 10, 20, 50 ]
--   </pre>
unstablePartitionM :: forall r e m. (Mutable r Ix1 e, PrimMonad m) => MVector (PrimState m) r e -> (e -> Bool) -> m Ix1

-- | Monadic version of <a>iterateUntil</a> where at each iteration mutable
--   version of an array is available.
iterateUntilM :: (Load r' ix e, Mutable r ix e, PrimMonad m, MonadIO m, PrimState m ~ RealWorld) => (Int -> Array r ix e -> MArray (PrimState m) r ix e -> m Bool) -> (Int -> Array r ix e -> Array r' ix e) -> Array r ix e -> m (Array r ix e)


-- | Massiv is a library, that allows creation and manipulation of arrays
--   in parallel and sequentially. Depending on the representation
--   (<tt><b>r</b></tt>), an <tt><b><a>Array</a> r ix e</b></tt> will have
--   certain properties that are unique to that particular representation,
--   but all of them will share the same trait, that an array is simply a
--   mapping from an index (<tt><b>ix</b></tt>) of an arbitrary dimension
--   to an element (<tt><b>e</b></tt>) of some value. Which means that some
--   representations describe classic arrays and are backed by a contiguous
--   chunk of memory reserved for the elements (or pointers to elements),
--   namely arrays with <a>Manifest</a> representations:
--   
--   <ul>
--   <li><a>B</a> - The most basic type of array that can hold any type of
--   element in a boxed form, i.e. each element is a pointer to the actual
--   value, therefore it is also the slowest representation. Elements are
--   kept in a Weak Head Normal Form (WHNF).</li>
--   <li><a>BN</a> - Similar to <a>B</a>, is also a boxed type, except it's
--   elements are always kept in a Normal Form (NF). This property is very
--   useful for parallel processing, i.e. when calling <a>compute</a> you
--   do want all of your elements to be fully evaluated.</li>
--   <li><a>BL</a> - Similar to <a>B</a>, is also a boxed type, but lazy.
--   It's elements are not evaluated.</li>
--   <li><a>S</a> - Is a type of array that is backed by pinned memory,
--   therefore pointers to those arrays can be passed to FFI calls, because
--   Garbage Collector (GC) is guaranteed not to move it. Elements must be
--   an instance of <a>Storable</a> class. It is just as efficient as
--   <a>P</a> and <a>U</a> arrays, except it is subject to
--   fragmentation.</li>
--   <li><a>U</a> - Unboxed representation. Elements must be an instance of
--   <a>Unbox</a> class.</li>
--   <li><a>P</a> - Array that can hold Haskell primitives, such as
--   <a>Int</a>, <a>Word</a>, <a>Double</a>, etc. Any element must be an
--   instance of <a>Prim</a> class.</li>
--   <li><a>M</a> - General manifest array type, that any of the above
--   representations can be converted to in constant time using
--   <a>toManifest</a>.</li>
--   </ul>
--   
--   There are also array representations that only describe how values for
--   its elements can be computed or loaded into memory, as such, they are
--   represented by functions and do not impose the memory overhead, that
--   is normally associated with arrays. They are needed for proper fusion
--   and parallelization of computation.
--   
--   <ul>
--   <li><a>D</a> - delayed array that is a mere function from an index to
--   an element. Also known as <i>Pull</i> array. Crucial representation
--   for fusing computation. Use <a>computeAs</a> in order to load array
--   into <a>Manifest</a> representation.</li>
--   <li><a>DL</a> - delayed load array representation that describes how
--   an array can be loaded. Also known as <i>Push</i> array. Useful for
--   fusing various array combining functions. Use <a>computeAs</a> in
--   order to load array into <a>Manifest</a> representation.</li>
--   <li><a>DS</a> - delayed stream vector representation that describes
--   how to handle a vector with possibility of unknown length. Useful for
--   filtering and unfolding. Use <a>computeAs</a> in order to load such
--   vector into <a>Manifest</a> representation.</li>
--   <li><a>DI</a> - delayed interleaved array. Same as <a>D</a>, but
--   performs better with unbalanced computation, when evaluation of one
--   element takes much longer than of its neighbor.</li>
--   <li><a>DW</a> - delayed windowed array. This peculiar representation
--   allows for very fast <a>Stencil</a> computation.</li>
--   </ul>
--   
--   Other Array types:
--   
--   <ul>
--   <li><a>L</a> and <a>LN</a> - those types aren't particularly useful on
--   their own, but because of their unique ability to be converted to and
--   from nested lists in constant time, provide a perfect intermediary for
--   lists &lt;-&gt; array conversion.</li>
--   </ul>
--   
--   Most of the <a>Manifest</a> arrays are capable of in-place mutation.
--   Check out <a>Data.Massiv.Array.Mutable</a> module for available
--   functionality.
--   
--   Many of the function names exported by this package will clash with
--   the ones from <a>Prelude</a>, hence it can be more convenient to
--   import like this:
--   
--   <pre>
--   import Prelude as P
--   import Data.Massiv.Array as A
--   </pre>
module Data.Massiv.Array

-- | Create an Array with no elements. By itself it is not particularly
--   useful, but it serves as a nice base for constructing larger arrays.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; xs = empty @DL @Ix1 @Double
--   
--   &gt;&gt;&gt; snoc (cons 4 (cons 5 xs)) 22
--   Array DL Seq (Sz1 3)
--     [ 4.0, 5.0, 22.0 ]
--   </pre>
empty :: forall r ix e. Construct r ix e => Array r ix e

-- | Create an Array with a single element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; singleton 7 :: Array D Ix4 Double
--   Array D Seq (Sz (1 :&gt; 1 :&gt; 1 :. 1))
--     [ [ [ [ 7.0 ]
--         ]
--       ]
--     ]
--   </pre>
--   
--   Instead of specifying type signature we could use
--   <tt>TypeApplications</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; singleton @U @Ix4 @Double 7
--   Array U Seq (Sz (1 :&gt; 1 :&gt; 1 :. 1))
--     [ [ [ [ 7.0 ]
--         ]
--       ]
--     ]
--   </pre>
singleton :: forall r ix e. Construct r ix e => e -> Array r ix e
replicate :: Construct r ix e => Comp -> Sz ix -> e -> Array r ix e

-- | Construct an Array. Resulting type either has to be unambiguously
--   inferred or restricted manually, like in the example below. Use
--   "Data.Massiv.Array.makeArrayR" if you'd like to specify representation
--   as an argument.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; makeArray Seq (Sz (3 :. 4)) (\ (i :. j) -&gt; if i == j then i else 0) :: Array D Ix2 Int
--   Array D Seq (Sz (3 :. 4))
--     [ [ 0, 0, 0, 0 ]
--     , [ 0, 1, 0, 0 ]
--     , [ 0, 0, 2, 0 ]
--     ]
--   </pre>
--   
--   Instead of restricting the full type manually we can use
--   <tt>TypeApplications</tt> as convenience:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; makeArray @P @_ @Double Seq (Sz2 3 4) $ \(i :. j) -&gt; logBase (fromIntegral i) (fromIntegral j)
--   Array P Seq (Sz (3 :. 4))
--     [ [ NaN, -0.0, -0.0, -0.0 ]
--     , [ -Infinity, NaN, Infinity, Infinity ]
--     , [ -Infinity, 0.0, 1.0, 1.5849625007211563 ]
--     ]
--   </pre>
makeArray :: Construct r ix e => Comp -> Sz ix -> (ix -> e) -> Array r ix e

-- | Same as <a>makeArray</a>, but produce elements using linear row-major
--   index.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; makeArrayLinear Seq (Sz (2 :. 4)) id :: Array D Ix2 Int
--   Array D Seq (Sz (2 :. 4))
--     [ [ 0, 1, 2, 3 ]
--     , [ 4, 5, 6, 7 ]
--     ]
--   </pre>
makeArrayLinear :: Construct r ix e => Comp -> Sz ix -> (Int -> e) -> Array r ix e

-- | Just like <a>makeArray</a> but with ability to specify the result
--   representation as an argument. Note the <a>U</a>nboxed type
--   constructor in the below example.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; makeArrayR U Par (Sz (2 :&gt; 3 :. 4)) (\ (i :&gt; j :. k) -&gt; i * i + j * j == k * k)
--   Array U Par (Sz (2 :&gt; 3 :. 4))
--     [ [ [ True, False, False, False ]
--       , [ False, True, False, False ]
--       , [ False, False, True, False ]
--       ]
--     , [ [ False, True, False, False ]
--       , [ False, False, False, False ]
--       , [ False, False, False, False ]
--       ]
--     ]
--   </pre>
makeArrayR :: Construct r ix e => r -> Comp -> Sz ix -> (ix -> e) -> Array r ix e

-- | Same as <a>makeArrayLinear</a>, but with ability to supply resulting
--   representation
makeArrayLinearR :: Construct r ix e => r -> Comp -> Sz ix -> (Int -> e) -> Array r ix e

-- | Same as <a>makeArrayR</a>, but restricted to 1-dimensional arrays.
makeVectorR :: Construct r Ix1 e => r -> Comp -> Sz1 -> (Ix1 -> e) -> Array r Ix1 e

-- | Sequentially iterate over each cell in the array in the row-major
--   order while continuously aplying the accumulator at each step.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; iterateN (Sz2 2 10) succ (10 :: Int)
--   Array DL Seq (Sz (2 :. 10))
--     [ [ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 ]
--     , [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ]
--     ]
--   </pre>
iterateN :: forall ix e. Index ix => Sz ix -> (e -> e) -> e -> Array DL ix e

-- | Same as <a>iterateN</a>, but with index aware function.
iiterateN :: forall ix e. Index ix => Sz ix -> (e -> ix -> e) -> e -> Array DL ix e

-- | Unfold sequentially from the end. There is no way to save the
--   accumulator after unfolding is done, since resulting array is delayed,
--   but it's possible to use <a>unfoldlPrimM</a> to achive such effect.
unfoldlS_ :: Construct DL ix e => Sz ix -> (a -> (a, e)) -> a -> Array DL ix e

-- | Unfold sequentially from the right with an index aware function.
iunfoldlS_ :: forall ix e a. Construct DL ix e => Sz ix -> (ix -> a -> (a, e)) -> a -> Array DL ix e

-- | Right unfold into a delayed load array. For the opposite direction use
--   <a>unfoldlS_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; unfoldrS_ (Sz1 10) (\xs -&gt; (Prelude.head xs, Prelude.tail xs)) ([10 ..] :: [Int])
--   Array DL Seq (Sz1 10)
--     [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ]
--   </pre>
unfoldrS_ :: forall ix e a. Construct DL ix e => Sz ix -> (a -> (e, a)) -> a -> Array DL ix e

-- | Right unfold of a delayed load array with index aware function
iunfoldrS_ :: forall ix e a. Construct DL ix e => Sz ix -> (a -> ix -> (e, a)) -> a -> Array DL ix e

-- | Create an array with random values by using a pure splittable random
--   number generator such as one provided by either <a>splitmix</a> or
--   <a>random</a> packages. If you don't have a splittable generator
--   consider using <a>randomArrayS</a> or <a>randomArrayWS</a> instead.
--   
--   Because of the pure nature of the generator and its splitability we
--   are not only able to parallelize the random value generation, but also
--   guarantee that it will be deterministic, granted none of the arguments
--   have changed.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import System.Random.SplitMix as SplitMix
--   
--   &gt;&gt;&gt; gen = SplitMix.mkSMGen 217
--   
--   &gt;&gt;&gt; randomArray gen SplitMix.splitSMGen SplitMix.nextDouble (ParN 2) (Sz2 2 3) :: Array DL Ix2 Double
--   Array DL (ParN 2) (Sz (2 :. 3))
--     [ [ 0.7383156058619669, 0.39904053166835896, 0.5617584038393628 ]
--     , [ 0.7218718218678238, 0.7006722805067258, 0.7225894731396042 ]
--     ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import System.Random as System
--   
--   &gt;&gt;&gt; gen = System.mkStdGen 217
--   
--   &gt;&gt;&gt; randomArray gen System.split System.random (ParN 2) (Sz2 2 3) :: Array DL Ix2 Double
--   Array DL (ParN 2) (Sz (2 :. 3))
--     [ [ 0.15191527341922206, 0.2045537167404079, 0.9635356052820256 ]
--     , [ 9.308278528094238e-2, 0.7200934018606843, 0.23173694193083583 ]
--     ]
--   </pre>
randomArray :: forall ix e g. Index ix => g -> (g -> (g, g)) -> (g -> (e, g)) -> Comp -> Sz ix -> Array DL ix e

-- | Similar to <a>randomArray</a> but performs generation sequentially,
--   which means it doesn't require splitability property. Another
--   consequence is that it returns the new generator together with
--   <i>manifest</i> array of random values.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import System.Random.SplitMix as SplitMix
--   
--   &gt;&gt;&gt; gen = SplitMix.mkSMGen 217
--   
--   &gt;&gt;&gt; snd $ randomArrayS gen (Sz2 2 3) SplitMix.nextDouble :: Array P Ix2 Double
--   Array P Seq (Sz (2 :. 3))
--     [ [ 0.8878273949359751, 0.11290807610140963, 0.7383156058619669 ]
--     , [ 0.39904053166835896, 0.5617584038393628, 0.16248374266020216 ]
--     ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import System.Random.Mersenne.Pure64 as MT
--   
--   &gt;&gt;&gt; gen = MT.pureMT 217
--   
--   &gt;&gt;&gt; snd $ randomArrayS gen (Sz2 2 3) MT.randomDouble :: Array P Ix2 Double
--   Array P Seq (Sz (2 :. 3))
--     [ [ 0.5504018416543631, 0.22504666452851707, 0.4480480867867128 ]
--     , [ 0.7139711572975297, 0.49401087853770953, 0.9397201599368645 ]
--     ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import System.Random as System
--   
--   &gt;&gt;&gt; gen = System.mkStdGen 217
--   
--   &gt;&gt;&gt; snd $ randomArrayS gen (Sz2 2 3) System.random :: Array P Ix2 Double
--   Array P Seq (Sz (2 :. 3))
--     [ [ 0.7972230393466304, 0.4485860543300083, 0.257773196880671 ]
--     , [ 0.19115043859955794, 0.33784788936970034, 3.479381605706322e-2 ]
--     ]
--   </pre>
randomArrayS :: forall r ix e g. Mutable r ix e => g -> Sz ix -> (g -> (e, g)) -> (g, Array r ix e)

-- | This is a stateful approach of generating random values. If your
--   generator is pure and splittable, it is better to use
--   <a>randomArray</a> instead, which will give you a pure, deterministic
--   and parallelizable generation of arrays. On the other hand, if your
--   generator is not thread safe, which is most likely the case, instead
--   of using some sort of global mutex, <a>WorkerStates</a> allows you to
--   keep track of individual state per worker (thread), which fits
--   parallelization of random value generation perfectly. All that needs
--   to be done is generators need to be initialized once per worker and
--   then they can be reused as many times as necessary.
--   
--   <h4><b>Examples</b></h4>
--   
--   In the example below we take a stateful random generator from
--   <a>wmc-random</a>, which is not thread safe, and safely parallelize it
--   by giving each thread it's own generator:
--   
--   <pre>
--   λ&gt; import Data.Massiv.Array
--   λ&gt; import System.Random.MWC (createSystemRandom, uniformR)
--   λ&gt; import System.Random.MWC.Distributions (standard)
--   λ&gt; gens &lt;- initWorkerStates Par (\_ -&gt; createSystemRandom)
--   λ&gt; randomArrayWS gens (Sz2 2 3) standard :: IO (Array P Ix2 Double)
--   Array P Par (Sz (2 :. 3))
--     [ [ -0.9066144845415213, 0.5264323240310042, -1.320943607597422 ]
--     , [ -0.6837929005619592, -0.3041255565826211, 6.53353089112833e-2 ]
--     ]
--   λ&gt; randomArrayWS gens (Sz1 10) (uniformR (0, 9)) :: IO (Array P Ix1 Int)
--   Array P Par (Sz1 10)
--     [ 3, 6, 1, 2, 1, 7, 6, 0, 8, 8 ]
--   </pre>
randomArrayWS :: forall r ix e g m. (Mutable r ix e, MonadUnliftIO m, PrimMonad m) => WorkerStates g -> Sz ix -> (g -> m e) -> m (Array r ix e)

-- | Similar to <a>makeArray</a>, but construct the array sequentially
--   using an <a>Applicative</a> interface.
--   
--   <i>Note</i> - using <a>generateArray</a> or <a>generateArrayS</a> will
--   always be faster, althought not always possible.
makeArrayA :: forall r ix e f. (Mutable r ix e, Applicative f) => Sz ix -> (ix -> f e) -> f (Array r ix e)

-- | Same as <a>makeArrayA</a>, but with ability to supply result array
--   representation.
makeArrayAR :: forall r ix e f. (Mutable r ix e, Applicative f) => r -> Sz ix -> (ix -> f e) -> f (Array r ix e)

-- | Same as <a>makeArrayA</a>, but with linear index.
makeArrayLinearA :: forall r ix e f. (Mutable r ix e, Applicative f) => Sz ix -> (Int -> f e) -> f (Array r ix e)

-- | Handy synonym for <tt><a>rangeInclusive</a> <a>Seq</a></tt>. Similar
--   to <tt>..</tt> for list.
--   
--   <pre>
--   &gt;&gt;&gt; Ix1 4 ... 10
--   Array D Seq (Sz1 7)
--     [ 4, 5, 6, 7, 8, 9, 10 ]
--   </pre>
(...) :: Index ix => ix -> ix -> Array D ix ix
infix 4 ...

-- | Handy synonym for <tt><a>range</a> <a>Seq</a></tt>
--   
--   <pre>
--   &gt;&gt;&gt; Ix1 4 ..: 10
--   Array D Seq (Sz1 6)
--     [ 4, 5, 6, 7, 8, 9 ]
--   </pre>
(..:) :: Index ix => ix -> ix -> Array D ix ix
infix 4 ..:

-- | Create an array of indices with a range from start to finish
--   (not-including), where indices are incremeted by one.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; range Seq (Ix1 1) 6
--   Array D Seq (Sz1 5)
--     [ 1, 2, 3, 4, 5 ]
--   
--   &gt;&gt;&gt; fromIx2 &lt;$&gt; range Seq (-1) (2 :. 2)
--   Array D Seq (Sz (3 :. 3))
--     [ [ (-1,-1), (-1,0), (-1,1) ]
--     , [ (0,-1), (0,0), (0,1) ]
--     , [ (1,-1), (1,0), (1,1) ]
--     ]
--   </pre>
range :: Index ix => Comp -> ix -> ix -> Array D ix ix

-- | Same as <a>range</a>, but with a custom step.
--   
--   <i><b>Throws Exceptions</b></i>: <a>IndexZeroException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; rangeStepM Seq (Ix1 1) 2 8
--   Array D Seq (Sz1 4)
--     [ 1, 3, 5, 7 ]
--   
--   &gt;&gt;&gt; rangeStepM Seq (Ix1 1) 0 8
--   *** Exception: IndexZeroException: 0
--   </pre>
rangeStepM :: (Index ix, MonadThrow m) => Comp -> ix -> ix -> ix -> m (Array D ix ix)

-- | Same as <a>rangeStepM</a>, but will throw an error whenever
--   <tt>step</tt> contains zeros.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; rangeStep' Seq (Ix1 1) 2 6
--   Array D Seq (Sz1 3)
--     [ 1, 3, 5 ]
--   </pre>
rangeStep' :: Index ix => Comp -> ix -> ix -> ix -> Array D ix ix

-- | Just like <a>range</a>, except the finish index is included.
rangeInclusive :: Index ix => Comp -> ix -> ix -> Array D ix ix

-- | Just like <tt>rangeStep</tt>, except the finish index is included.
rangeStepInclusiveM :: (MonadThrow m, Index ix) => Comp -> ix -> ix -> ix -> m (Array D ix ix)

-- | Just like <a>range</a>, except the finish index is included.
rangeStepInclusive' :: Index ix => Comp -> ix -> ix -> ix -> Array D ix ix

-- | Create an array of specified size with indices starting with some
--   index at position <tt>0</tt> and incremented by <tt>1</tt> until the
--   end of the array is reached
rangeSize :: Index ix => Comp -> ix -> Sz ix -> Array D ix ix

-- | Same as <a>rangeSize</a>, but with ability to specify the step.
rangeStepSize :: Index ix => Comp -> ix -> ix -> Sz ix -> Array D ix ix

-- | Same as <a>enumFromStepN</a> with step <tt>dx = 1</tt>.
--   
--   <i>Related</i>: <a>senumFromN</a>, <a>senumFromStepN</a>,
--   <a>enumFromStepN</a>, <a>rangeSize</a>, <a>rangeStepSize</a>,
--   <a>range</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; enumFromN Seq (5 :: Double) 3
--   Array D Seq (Sz1 3)
--     [ 5.0, 6.0, 7.0 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFromTo</a></tt></i> Very similar to <tt>[i
--   .. i + n - 1]</tt>, except that <tt>senumFromN</tt> is faster, but it
--   only works for <a>Num</a> and not for <a>Enum</a> elements</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromN</a></tt></i></li>
--   </ul>
enumFromN :: Num e => Comp -> e -> Sz1 -> Vector D e

-- | Enumerate from a starting number <tt>x</tt> exactly <tt>n</tt> times
--   with a custom step value <tt>dx</tt>. Unlike <a>senumFromStepN</a>,
--   there is no dependency on neigboring elements therefore
--   <a>enumFromStepN</a> is parallelizable.
--   
--   <i>Related</i>: <a>senumFromN</a>, <a>senumFromStepN</a>,
--   <a>enumFromN</a>, <a>rangeSize</a>, <a>rangeStepSize</a>,
--   <a>range</a>, <a>rangeStepM</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; enumFromStepN Seq 1 (0.1 :: Double) 5
--   Array D Seq (Sz1 5)
--     [ 1.0, 1.1, 1.2, 1.3, 1.4 ]
--   
--   &gt;&gt;&gt; enumFromStepN Seq (-pi :: Float) (pi/4) 9
--   Array D Seq (Sz1 9)
--     [ -3.1415927, -2.3561945, -1.5707964, -0.78539824, 0.0, 0.78539824, 1.5707963, 2.3561947, 3.1415927 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFrom</a></tt></i> Similar to <tt>take n [x,
--   x + dx ..]</tt>, except that <a>enumFromStepN</a> is parallelizable
--   and it only works for <a>Num</a> and not for <a>Enum</a> elements.
--   Floating point value will be slightly different as well.</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromStepN</a></tt></i> Similar
--   in the outcome, but very different in the way it works.</li>
--   </ul>
enumFromStepN :: Num e => Comp -> e -> e -> Sz1 -> Vector D e

-- | Function that expands an array to one with a higher dimension.
--   
--   This is useful for constructing arrays where there is shared
--   computation between multiple cells. The makeArray method of
--   constructing arrays:
--   
--   <pre>
--   makeArray :: Construct r ix e =&gt; Comp -&gt; ix -&gt; (ix -&gt; e) -&gt; Array r ix e
--   </pre>
--   
--   ...runs a function <tt>ix -&gt; e</tt> at every array index. This is
--   inefficient if there is a substantial amount of repeated computation
--   that could be shared while constructing elements on the same
--   dimension. The expand functions make this possible. First you
--   construct an <tt>Array r (Lower ix) a</tt> of one fewer dimensions
--   where <tt>a</tt> is something like <tt><a>Array</a> r <a>Ix1</a>
--   a</tt> or <tt><a>Array</a> r <a>Ix2</a> a</tt>. Then you use
--   <a>expandWithin</a> and a creation function <tt>a -&gt; Int -&gt;
--   b</tt> to create an <tt><a>Array</a> <a>D</a> <a>Ix2</a> b</tt> or
--   <tt><a>Array</a> <a>D</a> <a>Ix3</a> b</tt> respectfully.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; a = makeArrayR U Seq (Sz1 6) (+10) -- Imagine (+10) is some expensive function
--   
--   &gt;&gt;&gt; a
--   Array U Seq (Sz1 6)
--     [ 10, 11, 12, 13, 14, 15 ]
--   
--   &gt;&gt;&gt; expandWithin Dim1 5 (\ e j -&gt; (j + 1) * 100 + e) a :: Array D Ix2 Int
--   Array D Seq (Sz (6 :. 5))
--     [ [ 110, 210, 310, 410, 510 ]
--     , [ 111, 211, 311, 411, 511 ]
--     , [ 112, 212, 312, 412, 512 ]
--     , [ 113, 213, 313, 413, 513 ]
--     , [ 114, 214, 314, 414, 514 ]
--     , [ 115, 215, 315, 415, 515 ]
--     ]
--   
--   &gt;&gt;&gt; expandWithin Dim2 5 (\ e j -&gt; (j + 1) * 100 + e) a :: Array D Ix2 Int
--   Array D Seq (Sz (5 :. 6))
--     [ [ 110, 111, 112, 113, 114, 115 ]
--     , [ 210, 211, 212, 213, 214, 215 ]
--     , [ 310, 311, 312, 313, 314, 315 ]
--     , [ 410, 411, 412, 413, 414, 415 ]
--     , [ 510, 511, 512, 513, 514, 515 ]
--     ]
--   </pre>
expandWithin :: forall ix e r n a. (IsIndexDimension ix n, Manifest r (Lower ix) a) => Dimension n -> Sz1 -> (a -> Ix1 -> e) -> Array r (Lower ix) a -> Array D ix e

-- | Similar to <a>expandWithin</a>, except that dimension is specified at
--   a value level, which means it will throw an exception on an invalid
--   dimension.
expandWithinM :: (Index ix, Manifest r (Lower ix) a, MonadThrow m) => Dim -> Sz1 -> (a -> Ix1 -> b) -> Array r (Lower ix) a -> m (Array D ix b)

-- | Similar to <a>expandWithin</a>, except that dimension is specified at
--   a value level, which means it will throw an exception on an invalid
--   dimension.
expandWithin' :: (Index ix, Manifest r (Lower ix) a) => Dim -> Sz1 -> (a -> Ix1 -> b) -> Array r (Lower ix) a -> Array D ix b

-- | Similar to <a>expandWithin</a>, except it uses the outermost
--   dimension.
expandOuter :: (Index ix, Manifest r (Lower ix) a) => Sz1 -> (a -> Ix1 -> b) -> Array r (Lower ix) a -> Array D ix b

-- | Similar to <a>expandWithin</a>, except it uses the innermost
--   dimension.
expandInner :: (Index ix, Manifest r (Lower ix) a) => Sz1 -> (a -> Ix1 -> b) -> Array r (Lower ix) a -> Array D ix b

-- | Get computation strategy of this array
getComp :: Load r ix e => Array r ix e -> Comp

-- | Set computation strategy for this array
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; a = singleton @DL @Ix1 @Int 0
--   
--   &gt;&gt;&gt; a
--   Array DL Seq (Sz1 1)
--     [ 0 ]
--   
--   &gt;&gt;&gt; setComp (ParN 6) a -- use 6 capabilities
--   Array DL (ParN 6) (Sz1 1)
--     [ 0 ]
--   </pre>
setComp :: Construct r ix e => Comp -> Array r ix e -> Array r ix e

-- | Ensure that Array is computed, i.e. represented with concrete elements
--   in memory, hence is the <a>Mutable</a> type class restriction. Use
--   <a>setComp</a> if you'd like to change computation strategy before
--   calling <tt>compute</tt>
compute :: forall r ix e r'. (Mutable r ix e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Compute array sequentially disregarding predefined computation
--   strategy. Very much the same as <a>computePrimM</a>, but executed in
--   <a>ST</a>, thus pure.
computeS :: forall r ix e r'. (Mutable r ix e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Compute array in parallel using all cores disregarding predefined
--   computation strategy. Computation stategy of the resulting array will
--   match the source, despite that it is diregarded.
computeP :: forall r ix e r'. (Mutable r ix e, Construct r' ix e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Very similar to <a>compute</a>, but computes an array inside the
--   <a>IO</a> monad. Despite being deterministic and referentially
--   transparent, because this is an <a>IO</a> action it can be very useful
--   for enforcing the order of evaluation. Should be a prefered way of
--   computing an array during benchmarking.
computeIO :: forall r ix e r' m. (Mutable r ix e, Load r' ix e, MonadIO m) => Array r' ix e -> m (Array r ix e)

-- | Compute an array in <a>PrimMonad</a> sequentially disregarding
--   predefined computation strategy.
computePrimM :: forall r ix e r' m. (Mutable r ix e, Load r' ix e, PrimMonad m) => Array r' ix e -> m (Array r ix e)

-- | Just as <a>compute</a>, but let's you supply resulting representation
--   type as an argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; computeAs P $ range Seq (Ix1 0) 10
--   Array P Seq (Sz1 10)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   </pre>
computeAs :: (Mutable r ix e, Load r' ix e) => r -> Array r' ix e -> Array r ix e

-- | Same as <a>compute</a> and <a>computeAs</a>, but let's you supply
--   resulting representation type as a proxy argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   Useful only really for cases when representation constructor or
--   <tt>TypeApplications</tt> extension aren't desireable for some reason:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Proxy
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; computeProxy (Proxy :: Proxy P) $ (^ (2 :: Int)) &lt;$&gt; range Seq (Ix1 0) 10
--   Array P Seq (Sz1 10)
--     [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 ]
--   </pre>
computeProxy :: (Mutable r ix e, Load r' ix e) => proxy r -> Array r' ix e -> Array r ix e

-- | This is just like <a>convert</a>, but restricted to <a>Source</a>
--   arrays. Will be a noop if resulting type is the same as the input.
computeSource :: forall r ix e r'. (Mutable r ix e, Source r' ix e) => Array r' ix e -> Array r ix e

-- | Same as <a>compute</a>, but with <a>Stride</a>.
--   
--   <i>O(n div k)</i> - Where <tt>n</tt> is numer of elements in the
--   source array and <tt>k</tt> is number of elements in the stride.
computeWithStride :: forall r ix e r'. (Mutable r ix e, StrideLoad r' ix e) => Stride ix -> Array r' ix e -> Array r ix e

-- | Same as <a>computeWithStride</a>, but with ability to specify
--   resulting array representation.
computeWithStrideAs :: (Mutable r ix e, StrideLoad r' ix e) => r -> Stride ix -> Array r' ix e -> Array r ix e

-- | <i>O(n)</i> - Make an exact immutable copy of an Array.
clone :: Mutable r ix e => Array r ix e -> Array r ix e

-- | <i>O(n)</i> - conversion between array types. A full copy will occur,
--   unless when the source and result arrays are of the same
--   representation, in which case it is an <i>O(1)</i> operation.
convert :: forall r ix e r'. (Mutable r ix e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Same as <a>convert</a>, but let's you supply resulting representation
--   type as an argument.
convertAs :: (Mutable r ix e, Load r' ix e) => r -> Array r' ix e -> Array r ix e

-- | Same as <a>convert</a> and <a>convertAs</a>, but let's you supply
--   resulting representation type as a proxy argument.
convertProxy :: (Mutable r ix e, Load r' ix e) => proxy r -> Array r' ix e -> Array r ix e

-- | Convert a ragged array into a common array with rectangular shape.
--   Throws <a>ShapeException</a> whenever supplied ragged array does not
--   have a rectangular shape.
fromRaggedArrayM :: forall r ix e r' m. (Mutable r ix e, Ragged r' ix e, Load r' ix e, MonadThrow m) => Array r' ix e -> m (Array r ix e)

-- | Same as <a>fromRaggedArrayM</a>, but will throw a pure exception if
--   its shape is not rectangular.
fromRaggedArray' :: forall r ix e r'. (Mutable r ix e, Load r' ix e, Ragged r' ix e) => Array r' ix e -> Array r ix e

-- | Get the exact size of an immutabe array. Most of the time will produce
--   the size in constant time, except for <tt>DS</tt> representation,
--   which could result in evaluation of the whole stream. See
--   <a>maxSize</a> and <a>slength</a> for more info.
size :: Load r ix e => Array r ix e -> Sz ix

-- | <i>O(1)</i> - Get the number of elements in the array.
--   
--   <i>Note</i> - It is always a constant time operation except for some
--   arrays with <a>DS</a> representation. See <a>slength</a> for more
--   info.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; elemsCount $ range Seq (Ix1 10) 15
--   5
--   </pre>
elemsCount :: Load r ix e => Array r ix e -> Int

-- | <i>O(1)</i> - Check if an array has no elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; isEmpty $ range Seq (Ix2 10 20) (11 :. 21)
--   False
--   
--   &gt;&gt;&gt; isEmpty $ range Seq (Ix2 10 20) (10 :. 21)
--   True
--   </pre>
isEmpty :: Load r ix e => Array r ix e -> Bool

-- | <i>O(1)</i> - Check if array has elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; isNotEmpty (singleton 1 :: Array D Ix2 Int)
--   True
--   
--   &gt;&gt;&gt; isNotEmpty (empty :: Array D Ix2 Int)
--   False
--   </pre>
isNotEmpty :: Load r ix e => Array r ix e -> Bool

-- | <i>O(1)</i> - Infix version of <a>indexM</a>.
--   
--   <i><b>Exceptions</b></i>: <a>IndexOutOfBoundsException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; a &lt;- fromListsM @U @Ix2 @Int Seq [[1,2,3],[4,5,6]]
--   
--   &gt;&gt;&gt; a
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; a !? 0 :. 2
--   3
--   
--   &gt;&gt;&gt; a !? 0 :. 3
--   *** Exception: IndexOutOfBoundsException: (0 :. 3) is not safe for (Sz (2 :. 3))
--   
--   &gt;&gt;&gt; a !? 0 :. 3 :: Maybe Int
--   Nothing
--   </pre>
(!?) :: (Manifest r ix e, MonadThrow m) => Array r ix e -> ix -> m e
infixl 4 !?

-- | <i>O(1)</i> - Infix version of <a>index</a>`.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs U $ iterateN (Sz (2 :. 3)) succ (0 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; a ! 0 :. 2
--   3
--   
--   &gt;&gt;&gt; a ! 0 :. 3
--   *** Exception: IndexOutOfBoundsException: (0 :. 3) is not safe for (Sz (2 :. 3))
--   </pre>
(!) :: Manifest r ix e => Array r ix e -> ix -> e
infixl 4 !

-- | <i>O(1)</i> - Lookup an element in the array, where array itself is
--   wrapped with <a>MonadThrow</a>. This operator is useful when used
--   together with slicing or other functions that can fail.
--   
--   <i><b>Exceptions</b></i>: <a>IndexOutOfBoundsException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; ma = fromListsM @U @Ix3 @Int @Maybe Seq [[[1,2,3]],[[4,5,6]]]
--   
--   &gt;&gt;&gt; ma
--   Just (Array U Seq (Sz (2 :&gt; 1 :. 3))
--     [ [ [ 1, 2, 3 ]
--       ]
--     , [ [ 4, 5, 6 ]
--       ]
--     ]
--   )
--   
--   &gt;&gt;&gt; ma ??&gt; 1
--   Just (Array M Seq (Sz (1 :. 3))
--     [ [ 4, 5, 6 ]
--     ]
--   )
--   
--   &gt;&gt;&gt; ma ??&gt; 1 ?? 0 :. 2
--   Just 6
--   
--   &gt;&gt;&gt; ma ?? 1 :&gt; 0 :. 2
--   Just 6
--   </pre>
(??) :: (Manifest r ix e, MonadThrow m) => m (Array r ix e) -> ix -> m e
infixl 4 ??

-- | <i>O(1)</i> - Lookup an element in the array.
--   
--   <i><b>Exceptions</b></i>: <a>IndexOutOfBoundsException</a>
indexM :: (Manifest r ix e, MonadThrow m) => Array r ix e -> ix -> m e

-- | <i>O(1)</i> - Lookup an element in the array. Returns <a>Nothing</a>,
--   when index is out of bounds and returns the element at the supplied
--   index otherwise. Use <a>indexM</a> instead, since it is more general
--   and it can just as well be used with <a>Maybe</a>.
index :: Manifest r ix e => Array r ix e -> ix -> Maybe e

-- | <i>O(1)</i> - Lookup an element in the array. This is a partial
--   function and it can throw <a>IndexOutOfBoundsException</a> inside pure
--   code. It is safer to use <a>index</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; xs = [0..100] :: Array U Ix1 Int
--   
--   &gt;&gt;&gt; index' xs 50
--   50
--   
--   &gt;&gt;&gt; index' xs 150
--   *** Exception: IndexOutOfBoundsException: 150 is not safe for (Sz1 101)
--   </pre>
index' :: Manifest r ix e => Array r ix e -> ix -> e

-- | <i>O(1)</i> - Lookup an element in the array, while using default
--   element when index is out of bounds.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; xs = [0..100] :: Array P Ix1 Int
--   
--   &gt;&gt;&gt; defaultIndex 999 xs 100
--   100
--   
--   &gt;&gt;&gt; defaultIndex 999 xs 101
--   999
--   </pre>
defaultIndex :: Manifest r ix e => e -> Array r ix e -> ix -> e

-- | <i>O(1)</i> - Lookup an element in the array. Use a border resolution
--   technique when index is out of bounds.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; xs = [0..100] :: Array U Ix1 Int
--   
--   &gt;&gt;&gt; borderIndex Wrap xs &lt;$&gt; range Seq 99 104
--   Array D Seq (Sz1 5)
--     [ 99, 100, 0, 1, 2 ]
--   </pre>
borderIndex :: Manifest r ix e => Border e -> Array r ix e -> ix -> e

-- | This is just like <a>indexM</a> function, but it allows getting values
--   from delayed arrays as well as <a>Manifest</a>. As the name suggests,
--   indexing into a delayed array at the same index multiple times will
--   cause evaluation of the value each time and can destroy the performace
--   if used without care.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Exception
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; evaluateM (range Seq (Ix2 10 20) (100 :. 210)) 50 :: Either SomeException Ix2
--   Right (60 :. 70)
--   
--   &gt;&gt;&gt; evaluateM (range Seq (Ix2 10 20) (100 :. 210)) 150 :: Either SomeException Ix2
--   Left (IndexOutOfBoundsException: (150 :. 150) is not safe for (Sz (90 :. 190)))
--   </pre>
evaluateM :: (Source r ix e, MonadThrow m) => Array r ix e -> ix -> m e

-- | Similar to <a>evaluateM</a>, but will throw an exception in pure code.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; evaluate' (range Seq (Ix2 10 20) (100 :. 210)) 50
--   60 :. 70
--   
--   &gt;&gt;&gt; evaluate' (range Seq (Ix2 10 20) (100 :. 210)) 150
--   *** Exception: IndexOutOfBoundsException: (150 :. 150) is not safe for (Sz (90 :. 190))
--   </pre>
evaluate' :: Source r ix e => Array r ix e -> ix -> e

-- | Map a function over an array
map :: Source r ix e' => (e' -> e) -> Array r ix e' -> Array D ix e

-- | Map an index aware function over an array
imap :: Source r ix e' => (ix -> e' -> e) -> Array r ix e' -> Array D ix e

-- | Traverse with an <a>Applicative</a> action over an array sequentially.
--   
--   <i>Note</i> - using <a>traversePrim</a> will always be faster,
--   althought not always possible.
traverseA :: forall r ix e r' a f. (Source r' ix a, Mutable r ix e, Applicative f) => (a -> f e) -> Array r' ix a -> f (Array r ix e)

-- | Traverse sequentially over a source array, while discarding the
--   result.
traverseA_ :: forall r ix e a f. (Source r ix e, Applicative f) => (e -> f a) -> Array r ix e -> f ()

-- | Traverse with an <a>Applicative</a> index aware action over an array
--   sequentially.
itraverseA :: forall r ix e r' a f. (Source r' ix a, Mutable r ix e, Applicative f) => (ix -> a -> f e) -> Array r' ix a -> f (Array r ix e)

-- | Traverse with an <a>Applicative</a> index aware action over an array
--   sequentially.
itraverseA_ :: forall r ix e a f. (Source r ix a, Applicative f) => (ix -> a -> f e) -> Array r ix a -> f ()

-- | Sequence actions in a source array.
sequenceA :: forall r ix e r' f. (Source r' ix (f e), Mutable r ix e, Applicative f) => Array r' ix (f e) -> f (Array r ix e)

-- | Sequence actions in a source array, while discarding the result.
sequenceA_ :: forall r ix e f. (Source r ix (f e), Applicative f) => Array r ix (f e) -> f ()

-- | Traverse sequentially within <a>PrimMonad</a> over an array with an
--   action.
traversePrim :: forall r ix b r' a m. (Source r' ix a, Mutable r ix b, PrimMonad m) => (a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>traversePrim</a>, but traverse with index aware action.
itraversePrim :: forall r ix b r' a m. (Source r' ix a, Mutable r ix b, PrimMonad m) => (ix -> a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Map a monadic action over an array sequentially.
mapM :: forall r ix b r' a m. (Source r' ix a, Mutable r ix b, Monad m) => (a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>mapM</a> except with arguments flipped.
forM :: forall r ix b r' a m. (Source r' ix a, Mutable r ix b, Monad m) => Array r' ix a -> (a -> m b) -> m (Array r ix b)

-- | Map an index aware monadic action over an array sequentially.
imapM :: forall r ix b r' a m. (Source r' ix a, Mutable r ix b, Monad m) => (ix -> a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>forM</a>, except with an index aware action.
iforM :: forall r ix b r' a m. (Source r' ix a, Mutable r ix b, Monad m) => Array r' ix a -> (ix -> a -> m b) -> m (Array r ix b)

-- | Map a monadic function over an array sequentially, while discarding
--   the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; rangeStepM Par (Ix1 10) 12 60 &gt;&gt;= A.mapM_ print
--   10
--   22
--   34
--   46
--   58
--   </pre>
mapM_ :: (Source r ix a, Monad m) => (a -> m b) -> Array r ix a -> m ()

-- | Just like <a>mapM_</a>, except with flipped arguments.
--   
--   <h4><b>Examples</b></h4>
--   
--   Here is a common way of iterating N times using a for loop in an
--   imperative language with mutation being an obvious side effect:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; ref &lt;- newIORef 0 :: IO (IORef Int)
--   
--   &gt;&gt;&gt; A.forM_ (range Seq (Ix1 0) 1000) $ \ i -&gt; modifyIORef' ref (+i)
--   
--   &gt;&gt;&gt; readIORef ref
--   499500
--   </pre>
forM_ :: (Source r ix a, Monad m) => Array r ix a -> (a -> m b) -> m ()

-- | Map a monadic index aware function over an array sequentially, while
--   discarding the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; imapM_ (curry print) $ range Seq (Ix1 10) 15
--   (0,10)
--   (1,11)
--   (2,12)
--   (3,13)
--   (4,14)
--   </pre>
imapM_ :: (Source r ix a, Monad m) => (ix -> a -> m b) -> Array r ix a -> m ()

-- | Just like <a>imapM_</a>, except with flipped arguments.
iforM_ :: (Source r ix a, Monad m) => Array r ix a -> (ix -> a -> m b) -> m ()

-- | Map an <a>IO</a> action over an <a>Array</a>. Underlying computation
--   strategy is respected and will be parallelized when requested.
--   Unfortunately no fusion is possible and new array will be create upon
--   each call.
mapIO :: forall r ix b r' a m. (Source r' ix a, Mutable r ix b, MonadUnliftIO m, PrimMonad m) => (a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>imapWS</a>, but without the index.
mapWS :: forall r ix b r' a s m. (Source r' ix a, Mutable r ix b, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> (a -> s -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Similar to <a>mapIO</a>, but ignores the result of mapping action and
--   does not create a resulting array, therefore it is faster. Use this
--   instead of <a>mapIO</a> when result is irrelevant.
mapIO_ :: (Source r b e, MonadUnliftIO m) => (e -> m a) -> Array r b e -> m ()

-- | Same as <a>mapIO</a> but map an index aware action instead. Respects
--   computation strategy.
imapIO :: forall r ix b r' a m. (Source r' ix a, Mutable r ix b, MonadUnliftIO m, PrimMonad m) => (ix -> a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>imapIO</a>, but ignores the inner computation strategy and
--   uses stateful workers during computation instead. Use
--   <a>initWorkerStates</a> for the <a>WorkerStates</a> initialization.
imapWS :: forall r ix b r' a s m. (Source r' ix a, Mutable r ix b, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> (ix -> a -> s -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>mapIO_</a>, but map an index aware action instead.
imapIO_ :: (Source r ix e, MonadUnliftIO m) => (ix -> e -> m a) -> Array r ix e -> m ()

-- | Same as <a>mapIO</a> but with arguments flipped.
forIO :: forall r ix b r' a m. (Source r' ix a, Mutable r ix b, MonadUnliftIO m, PrimMonad m) => Array r' ix a -> (a -> m b) -> m (Array r ix b)

-- | Same as <a>iforWS</a>, but without the index.
forWS :: forall r ix b r' a s m. (Source r' ix a, Mutable r ix b, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> Array r' ix a -> (a -> s -> m b) -> m (Array r ix b)

-- | Same as <a>mapIO_</a> but with arguments flipped.
--   
--   <h4><b>Example</b></h4>
--   
--   This is the same example as in <a>forM_</a>, with important difference
--   that accumulator <tt>ref</tt> will be modified concurrently by as many
--   threads as there are capabilities.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; ref &lt;- newIORef 0 :: IO (IORef Int)
--   
--   &gt;&gt;&gt; forIO_ (range Par (Ix1 0) 1000) $ \ i -&gt; atomicModifyIORef' ref (\v -&gt; (v+i, ()))
--   
--   &gt;&gt;&gt; readIORef ref
--   499500
--   </pre>
forIO_ :: (Source r ix e, MonadUnliftIO m) => Array r ix e -> (e -> m a) -> m ()

-- | Same as <a>imapIO</a> but with arguments flipped.
iforIO :: forall r ix b r' a m. (Source r' ix a, Mutable r ix b, MonadUnliftIO m, PrimMonad m) => Array r' ix a -> (ix -> a -> m b) -> m (Array r ix b)

-- | Same as <a>imapWS</a>, but with source array and mapping action
--   arguments flipped.
iforWS :: forall r ix b r' a s m. (Source r' ix a, Mutable r ix b, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> Array r' ix a -> (ix -> a -> s -> m b) -> m (Array r ix b)

-- | Same as <a>imapIO_</a> but with arguments flipped.
iforIO_ :: (Source r ix a, MonadUnliftIO m) => Array r ix a -> (ix -> a -> m b) -> m ()

-- | Same as <a>imapM_</a>, but will use the supplied scheduler.
imapSchedulerM_ :: (Source r ix e, Monad m) => Scheduler m () -> (ix -> e -> m a) -> Array r ix e -> m ()

-- | Same as <a>imapM_</a>, but will use the supplied scheduler.
iforSchedulerM_ :: (Source r ix e, Monad m) => Scheduler m () -> Array r ix e -> (ix -> e -> m a) -> m ()

-- | Zip two arrays
zip :: (Source r1 ix e1, Source r2 ix e2) => Array r1 ix e1 -> Array r2 ix e2 -> Array D ix (e1, e2)

-- | Zip three arrays
zip3 :: (Source r1 ix e1, Source r2 ix e2, Source r3 ix e3) => Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array D ix (e1, e2, e3)

-- | Zip four arrays
zip4 :: (Source r1 ix e1, Source r2 ix e2, Source r3 ix e3, Source r4 ix e4) => Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array r4 ix e4 -> Array D ix (e1, e2, e3, e4)

-- | Unzip two arrays
unzip :: Source r ix (e1, e2) => Array r ix (e1, e2) -> (Array D ix e1, Array D ix e2)

-- | Unzip three arrays
unzip3 :: Source r ix (e1, e2, e3) => Array r ix (e1, e2, e3) -> (Array D ix e1, Array D ix e2, Array D ix e3)

-- | Unzip four arrays
unzip4 :: Source r ix (e1, e2, e3, e4) => Array r ix (e1, e2, e3, e4) -> (Array D ix e1, Array D ix e2, Array D ix e3, Array D ix e4)

-- | Zip two arrays with a function. Resulting array will be an
--   intersection of source arrays in case their dimensions do not match.
zipWith :: (Source r1 ix e1, Source r2 ix e2) => (e1 -> e2 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array D ix e

-- | Just like <a>zipWith</a>, except zip three arrays with a function.
zipWith3 :: (Source r1 ix e1, Source r2 ix e2, Source r3 ix e3) => (e1 -> e2 -> e3 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array D ix e

-- | Just like <a>zipWith</a>, except zip four arrays with a function.
zipWith4 :: (Source r1 ix e1, Source r2 ix e2, Source r3 ix e3, Source r4 ix e4) => (e1 -> e2 -> e3 -> e4 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array r4 ix e4 -> Array D ix e

-- | Just like <a>zipWith</a>, except with an index aware function.
izipWith :: (Source r1 ix e1, Source r2 ix e2) => (ix -> e1 -> e2 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array D ix e

-- | Just like <a>zipWith3</a>, except with an index aware function.
izipWith3 :: (Source r1 ix e1, Source r2 ix e2, Source r3 ix e3) => (ix -> e1 -> e2 -> e3 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array D ix e

-- | Just like <a>zipWith4</a>, except with an index aware function.
izipWith4 :: (Source r1 ix e1, Source r2 ix e2, Source r3 ix e3, Source r4 ix e4) => (ix -> e1 -> e2 -> e3 -> e4 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array r4 ix e4 -> Array D ix e

-- | Similar to <a>zipWith</a>, except dimensions of both arrays either
--   have to be the same, or at least one of the two array must be a
--   singleton array, in which case it will behave as a <a>map</a>.
liftArray2 :: (Source r1 ix a, Source r2 ix b) => (a -> b -> e) -> Array r1 ix a -> Array r2 ix b -> Array D ix e

-- | Similar to <a>zipWith</a>, except does it sequentially and using the
--   <a>Applicative</a>. Note that resulting array has Mutable
--   representation.
zipWithA :: (Source r1 ix e1, Source r2 ix e2, Applicative f, Mutable r ix e) => (e1 -> e2 -> f e) -> Array r1 ix e1 -> Array r2 ix e2 -> f (Array r ix e)

-- | Similar to <a>zipWith</a>, except does it sequentiall and using the
--   <a>Applicative</a>. Note that resulting array has Mutable
--   representation.
izipWithA :: (Source r1 ix e1, Source r2 ix e2, Applicative f, Mutable r ix e) => (ix -> e1 -> e2 -> f e) -> Array r1 ix e1 -> Array r2 ix e2 -> f (Array r ix e)

-- | Same as <a>zipWithA</a>, but for three arrays.
zipWith3A :: (Source r1 ix e1, Source r2 ix e2, Source r3 ix e3, Applicative f, Mutable r ix e) => (e1 -> e2 -> e3 -> f e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> f (Array r ix e)

-- | Same as <a>izipWithA</a>, but for three arrays.
izipWith3A :: (Source r1 ix e1, Source r2 ix e2, Source r3 ix e3, Applicative f, Mutable r ix e) => (ix -> e1 -> e2 -> e3 -> f e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> f (Array r ix e)

-- | <i>O(n)</i> - Unstructured fold of an array.
fold :: (Monoid e, Source r ix e) => Array r ix e -> e

-- | <i>O(n)</i> - Monoidal fold over an array with an index aware
--   function. Also known as reduce.
ifoldMono :: (Source r ix e, Monoid m) => (ix -> e -> m) -> Array r ix e -> m

-- | <i>O(n)</i> - This is exactly like <a>foldMap</a>, but for arrays.
--   Fold over an array, while converting each element into a
--   <a>Monoid</a>. Also known as map-reduce. If elements of the array are
--   already a <a>Monoid</a> you can use <a>fold</a> instead.
foldMono :: (Source r ix e, Monoid m) => (e -> m) -> Array r ix e -> m

-- | <i>O(n)</i> - Semigroup fold over an array with an index aware
--   function.
ifoldSemi :: (Source r ix e, Semigroup m) => (ix -> e -> m) -> m -> Array r ix e -> m

-- | <i>O(n)</i> - Semigroup fold over an array.
foldSemi :: (Source r ix e, Semigroup m) => (e -> m) -> m -> Array r ix e -> m

-- | Reduce each outer slice into a monoid and mappend results together
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import Data.Monoid (Product(..))
--   
--   &gt;&gt;&gt; arr = computeAs P $ iterateN (Sz2 2 3) (+1) (10 :: Int)
--   
--   &gt;&gt;&gt; arr
--   Array P Seq (Sz (2 :. 3))
--     [ [ 11, 12, 13 ]
--     , [ 14, 15, 16 ]
--     ]
--   
--   &gt;&gt;&gt; getProduct $ foldOuterSlice (\row -&gt; Product (A.sum row)) arr
--   1620
--   
--   &gt;&gt;&gt; (11 + 12 + 13) * (14 + 15 + 16) :: Int
--   1620
--   </pre>
foldOuterSlice :: (OuterSlice r ix e, Monoid m) => (Elt r ix e -> m) -> Array r ix e -> m

-- | Reduce each outer slice into a monoid with an index aware function and
--   mappend results together
ifoldOuterSlice :: (OuterSlice r ix e, Monoid m) => (Ix1 -> Elt r ix e -> m) -> Array r ix e -> m

-- | Reduce each inner slice into a monoid and mappend results together
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import Data.Monoid (Product(..))
--   
--   &gt;&gt;&gt; arr = computeAs P $ iterateN (Sz2 2 3) (+1) (10 :: Int)
--   
--   &gt;&gt;&gt; arr
--   Array P Seq (Sz (2 :. 3))
--     [ [ 11, 12, 13 ]
--     , [ 14, 15, 16 ]
--     ]
--   
--   &gt;&gt;&gt; getProduct $ foldInnerSlice (\column -&gt; Product (A.sum column)) arr
--   19575
--   
--   &gt;&gt;&gt; (11 + 14) * (12 + 15) * (13 + 16) :: Int
--   19575
--   </pre>
foldInnerSlice :: (InnerSlice r ix e, Monoid m) => (Elt r ix e -> m) -> Array r ix e -> m

-- | Reduce each inner slice into a monoid with an index aware function and
--   mappend results together
ifoldInnerSlice :: (InnerSlice r ix e, Monoid m) => (Ix1 -> Elt r ix e -> m) -> Array r ix e -> m

-- | <i>O(n)</i> - Compute minimum of all elements.
minimumM :: (MonadThrow m, Source r ix e, Ord e) => Array r ix e -> m e

-- | <i>O(n)</i> - Compute minimum of all elements.
minimum' :: (Source r ix e, Ord e) => Array r ix e -> e

-- | <i>O(n)</i> - Compute maximum of all elements.
maximumM :: (MonadThrow m, Source r ix e, Ord e) => Array r ix e -> m e

-- | <i>O(n)</i> - Compute maximum of all elements.
maximum' :: (Source r ix e, Ord e) => Array r ix e -> e

-- | <i>O(n)</i> - Compute sum of all elements.
sum :: (Source r ix e, Num e) => Array r ix e -> e

-- | <i>O(n)</i> - Compute product of all elements.
product :: (Source r ix e, Num e) => Array r ix e -> e

-- | <i>O(n)</i> - Compute conjunction of all elements.
and :: Source r ix Bool => Array r ix Bool -> Bool

-- | <i>O(n)</i> - Compute disjunction of all elements.
or :: Source r ix Bool => Array r ix Bool -> Bool

-- | <i>O(n)</i> - Determines whether all elements of the array satisfy a
--   predicate.
all :: Source r ix e => (e -> Bool) -> Array r ix e -> Bool

-- | <i>O(n)</i> - Determines whether any element of the array satisfies a
--   predicate.
any :: Source r ix e => (e -> Bool) -> Array r ix e -> Bool

-- | <i>O(n)</i> - Determines whether an element is present in the array.
elem :: (Eq e, Source r ix e) => e -> Array r ix e -> Bool

-- | <i>O(min (n1, n2))</i> - Compute array equality by applying a
--   comparing function to each element.
eqArrays :: (Source r1 ix e1, Source r2 ix e2) => (e1 -> e2 -> Bool) -> Array r1 ix e1 -> Array r2 ix e2 -> Bool

-- | <i>O(min (n1, n2))</i> - Compute array ordering by applying a
--   comparing function to each element. The exact ordering is unspecified
--   so this is only intended for use in maps and the like where you need
--   an ordering but do not care about which one is used.
compareArrays :: (Source r1 ix e1, Source r2 ix e2) => (e1 -> e2 -> Ordering) -> Array r1 ix e1 -> Array r2 ix e2 -> Ordering

-- | Left fold over the inner most dimension with index aware function.
ifoldlInner :: (Index (Lower ix), Source r ix e) => (ix -> a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Left fold over the inner most dimension.
foldlInner :: (Index (Lower ix), Source r ix e) => (a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Right fold over the inner most dimension with index aware function.
ifoldrInner :: (Index (Lower ix), Source r ix e) => (ix -> e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Right fold over the inner most dimension.
foldrInner :: (Index (Lower ix), Source r ix e) => (e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Monoidal fold over the inner most dimension.
foldInner :: (Monoid e, Index (Lower ix), Source r ix e) => Array r ix e -> Array D (Lower ix) e

-- | Left fold along a specified dimension with an index aware function.
ifoldlWithin :: (Index (Lower ix), IsIndexDimension ix n, Source r ix e) => Dimension n -> (ix -> a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Left fold along a specified dimension.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; arr = makeArrayLinear @U Seq (Sz (2 :. 5)) id
--   
--   &gt;&gt;&gt; arr
--   Array U Seq (Sz (2 :. 5))
--     [ [ 0, 1, 2, 3, 4 ]
--     , [ 5, 6, 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; foldlWithin Dim1 (flip (:)) [] arr
--   Array D Seq (Sz1 2)
--     [ [4,3,2,1,0], [9,8,7,6,5] ]
--   
--   &gt;&gt;&gt; foldlWithin Dim2 (flip (:)) [] arr
--   Array D Seq (Sz1 5)
--     [ [5,0], [6,1], [7,2], [8,3], [9,4] ]
--   </pre>
foldlWithin :: (Index (Lower ix), IsIndexDimension ix n, Source r ix e) => Dimension n -> (a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Right fold along a specified dimension with an index aware function.
ifoldrWithin :: (Index (Lower ix), IsIndexDimension ix n, Source r ix e) => Dimension n -> (ix -> e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Right fold along a specified dimension.
foldrWithin :: (Index (Lower ix), IsIndexDimension ix n, Source r ix e) => Dimension n -> (e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Monoidal fold over some internal dimension.
foldWithin :: (Source r ix a, Monoid a, Index (Lower ix), IsIndexDimension ix n) => Dimension n -> Array r ix a -> Array D (Lower ix) a

-- | Similar to <a>ifoldlWithin</a>, except that dimension is specified at
--   a value level, which means it will throw an exception on an invalid
--   dimension.
ifoldlWithin' :: (Index (Lower ix), Source r ix e) => Dim -> (ix -> a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Similar to <a>foldlWithin</a>, except that dimension is specified at a
--   value level, which means it will throw an exception on an invalid
--   dimension.
foldlWithin' :: (Index (Lower ix), Source r ix e) => Dim -> (a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Similar to <a>ifoldrWithin</a>, except that dimension is specified at
--   a value level, which means it will throw an exception on an invalid
--   dimension.
ifoldrWithin' :: (Index (Lower ix), Source r ix e) => Dim -> (ix -> e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Similar to <a>foldrWithin</a>, except that dimension is specified at a
--   value level, which means it will throw an exception on an invalid
--   dimension.
foldrWithin' :: (Index (Lower ix), Source r ix e) => Dim -> (e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Monoidal fold over some internal dimension. This is a pratial function
--   and will result in <a>IndexDimensionException</a> if supplied
--   dimension is invalid.
foldWithin' :: (Source r ix a, Monoid a, Index (Lower ix)) => Dim -> Array r ix a -> Array D (Lower ix) a

-- | <i>O(n)</i> - Left fold, computed sequentially.
foldlS :: Source r ix e => (a -> e -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Right fold, computed sequentially.
foldrS :: Source r ix e => (e -> a -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Left fold with an index aware function, computed
--   sequentially.
ifoldlS :: Source r ix e => (a -> ix -> e -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Right fold with an index aware function, computed
--   sequentially.
ifoldrS :: Source r ix e => (ix -> e -> a -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Monadic left fold.
foldlM :: (Source r ix e, Monad m) => (a -> e -> m a) -> a -> Array r ix e -> m a

-- | <i>O(n)</i> - Monadic right fold.
foldrM :: (Source r ix e, Monad m) => (e -> a -> m a) -> a -> Array r ix e -> m a

-- | <i>O(n)</i> - Monadic left fold, that discards the result.
foldlM_ :: (Source r ix e, Monad m) => (a -> e -> m a) -> a -> Array r ix e -> m ()

-- | <i>O(n)</i> - Monadic right fold, that discards the result.
foldrM_ :: (Source r ix e, Monad m) => (e -> a -> m a) -> a -> Array r ix e -> m ()

-- | <i>O(n)</i> - Monadic left fold with an index aware function.
ifoldlM :: (Source r ix e, Monad m) => (a -> ix -> e -> m a) -> a -> Array r ix e -> m a

-- | <i>O(n)</i> - Monadic right fold with an index aware function.
ifoldrM :: (Source r ix e, Monad m) => (ix -> e -> a -> m a) -> a -> Array r ix e -> m a

-- | <i>O(n)</i> - Monadic left fold with an index aware function, that
--   discards the result.
ifoldlM_ :: (Source r ix e, Monad m) => (a -> ix -> e -> m a) -> a -> Array r ix e -> m ()

-- | <i>O(n)</i> - Monadic right fold with an index aware function, that
--   discards the result.
ifoldrM_ :: (Source r ix e, Monad m) => (ix -> e -> a -> m a) -> a -> Array r ix e -> m ()

-- | Version of foldr that supports <tt>foldr/build</tt> list fusion
--   implemented by GHC.
foldrFB :: Source r ix e => (e -> b -> b) -> b -> Array r ix e -> b

-- | <i>O(n)</i> - Left fold, computed sequentially with lazy accumulator.
lazyFoldlS :: Source r ix e => (a -> e -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Right fold, computed sequentially with lazy accumulator.
lazyFoldrS :: Source r ix e => (e -> a -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Left fold, computed with respect of array's computation
--   strategy. Because we do potentially split the folding among many
--   threads, we also need a combining function and an accumulator for the
--   results. Depending on the number of threads being used, results can be
--   different, hence is the <a>MonadIO</a> constraint.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; foldlP (flip (:)) [] (flip (:)) [] $ makeArrayR D Seq (Sz1 6) id
--   [[5,4,3,2,1,0]]
--   
--   &gt;&gt;&gt; foldlP (flip (:)) [] (++) [] $ makeArrayR D Seq (Sz1 6) id
--   [5,4,3,2,1,0]
--   
--   &gt;&gt;&gt; foldlP (flip (:)) [] (flip (:)) [] $ makeArrayR D (ParN 3) (Sz1 6) id
--   [[5,4],[3,2],[1,0]]
--   
--   &gt;&gt;&gt; foldlP (flip (:)) [] (++) [] $ makeArrayR D (ParN 3) (Sz1 6) id
--   [1,0,3,2,5,4]
--   </pre>
foldlP :: (MonadIO m, Source r ix e) => (a -> e -> a) -> a -> (b -> a -> b) -> b -> Array r ix e -> m b

-- | <i>O(n)</i> - Right fold, computed with respect to computation
--   strategy. Same as <a>foldlP</a>, except directed from the last element
--   in the array towards beginning.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; foldrP (:) [] (++) [] $ makeArrayR D (ParN 2) (Sz2 2 3) fromIx2
--   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
--   
--   &gt;&gt;&gt; foldrP (:) [] (:) [] $ makeArrayR D Seq (Sz1 6) id
--   [[0,1,2,3,4,5]]
--   
--   &gt;&gt;&gt; foldrP (:) [] (:) [] $ makeArrayR D (ParN 3) (Sz1 6) id
--   [[0,1],[2,3],[4,5]]
--   </pre>
foldrP :: (MonadIO m, Source r ix e) => (e -> a -> a) -> a -> (a -> b -> b) -> b -> Array r ix e -> m b

-- | <i>O(n)</i> - Left fold with an index aware function, computed in
--   parallel. Just like <a>foldlP</a>, except that folding function will
--   receive an index of an element it is being applied to.
ifoldlP :: (MonadIO m, Source r ix e) => (a -> ix -> e -> a) -> a -> (b -> a -> b) -> b -> Array r ix e -> m b

-- | <i>O(n)</i> - Right fold with an index aware function, while
--   respecting the computation strategy. Same as <a>ifoldlP</a>, except
--   directed from the last element in the array towards beginning, but
--   also row-major.
ifoldrP :: (MonadIO m, Source r ix e) => (ix -> e -> a -> a) -> a -> (a -> b -> b) -> b -> Array r ix e -> m b

-- | Similar to <a>ifoldlP</a>, except that folding functions themselves do
--   live in IO
ifoldlIO :: (MonadUnliftIO m, Source r ix e) => (a -> ix -> e -> m a) -> a -> (b -> a -> m b) -> b -> Array r ix e -> m b

-- | Similar to <a>ifoldrP</a>, except that folding functions themselves do
--   live in IO
ifoldrIO :: (MonadUnliftIO m, Source r ix e) => (ix -> e -> a -> m a) -> a -> (a -> b -> m b) -> b -> Array r ix e -> m b

-- | Transpose a 2-dimensional array
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayLinearR D Seq (Sz (2 :. 3)) id
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (2 :. 3))
--     [ [ 0, 1, 2 ]
--     , [ 3, 4, 5 ]
--     ]
--   
--   &gt;&gt;&gt; transpose arr
--   Array D Seq (Sz (3 :. 2))
--     [ [ 0, 3 ]
--     , [ 1, 4 ]
--     , [ 2, 5 ]
--     ]
--   </pre>
transpose :: Source r Ix2 e => Array r Ix2 e -> Array D Ix2 e

-- | Transpose inner two dimensions of at least rank-2 array.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayLinearR U Seq (Sz (2 :&gt; 3 :. 4)) id
--   
--   &gt;&gt;&gt; arr
--   Array U Seq (Sz (2 :&gt; 3 :. 4))
--     [ [ [ 0, 1, 2, 3 ]
--       , [ 4, 5, 6, 7 ]
--       , [ 8, 9, 10, 11 ]
--       ]
--     , [ [ 12, 13, 14, 15 ]
--       , [ 16, 17, 18, 19 ]
--       , [ 20, 21, 22, 23 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; transposeInner arr
--   Array D Seq (Sz (3 :&gt; 2 :. 4))
--     [ [ [ 0, 1, 2, 3 ]
--       , [ 12, 13, 14, 15 ]
--       ]
--     , [ [ 4, 5, 6, 7 ]
--       , [ 16, 17, 18, 19 ]
--       ]
--     , [ [ 8, 9, 10, 11 ]
--       , [ 20, 21, 22, 23 ]
--       ]
--     ]
--   </pre>
transposeInner :: (Index (Lower ix), Source r' ix e) => Array r' ix e -> Array D ix e

-- | Transpose outer two dimensions of at least rank-2 array.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; arr = makeArrayLinear @U Seq (Sz (2 :&gt; 3 :. 4)) id
--   
--   &gt;&gt;&gt; arr
--   Array U Seq (Sz (2 :&gt; 3 :. 4))
--     [ [ [ 0, 1, 2, 3 ]
--       , [ 4, 5, 6, 7 ]
--       , [ 8, 9, 10, 11 ]
--       ]
--     , [ [ 12, 13, 14, 15 ]
--       , [ 16, 17, 18, 19 ]
--       , [ 20, 21, 22, 23 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; transposeOuter arr
--   Array D Seq (Sz (2 :&gt; 4 :. 3))
--     [ [ [ 0, 4, 8 ]
--       , [ 1, 5, 9 ]
--       , [ 2, 6, 10 ]
--       , [ 3, 7, 11 ]
--       ]
--     , [ [ 12, 16, 20 ]
--       , [ 13, 17, 21 ]
--       , [ 14, 18, 22 ]
--       , [ 15, 19, 23 ]
--       ]
--     ]
--   </pre>
transposeOuter :: (Index (Lower ix), Source r' ix e) => Array r' ix e -> Array D ix e

-- | Reverse an array along some dimension. Dimension supplied is checked
--   at compile time.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = makeArrayLinear Seq (Sz2 4 5) (+10) :: Array D Ix2 Int
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (4 :. 5))
--     [ [ 10, 11, 12, 13, 14 ]
--     , [ 15, 16, 17, 18, 19 ]
--     , [ 20, 21, 22, 23, 24 ]
--     , [ 25, 26, 27, 28, 29 ]
--     ]
--   
--   &gt;&gt;&gt; A.reverse Dim1 arr
--   Array D Seq (Sz (4 :. 5))
--     [ [ 14, 13, 12, 11, 10 ]
--     , [ 19, 18, 17, 16, 15 ]
--     , [ 24, 23, 22, 21, 20 ]
--     , [ 29, 28, 27, 26, 25 ]
--     ]
--   
--   &gt;&gt;&gt; A.reverse Dim2 arr
--   Array D Seq (Sz (4 :. 5))
--     [ [ 25, 26, 27, 28, 29 ]
--     , [ 20, 21, 22, 23, 24 ]
--     , [ 15, 16, 17, 18, 19 ]
--     , [ 10, 11, 12, 13, 14 ]
--     ]
--   </pre>
reverse :: (IsIndexDimension ix n, Source r ix e) => Dimension n -> Array r ix e -> Array D ix e

-- | Reverse an array along some dimension. Same as <a>reverseM</a>, but
--   throws the <a>IndexDimensionException</a> from pure code.
reverse' :: Source r ix e => Dim -> Array r ix e -> Array D ix e

-- | Similarly to <a>reverse</a>, flip an array along a particular
--   dimension, but throws <a>IndexDimensionException</a> for an incorrect
--   dimension.
reverseM :: (MonadThrow m, Source r ix e) => Dim -> Array r ix e -> m (Array D ix e)

-- | Rearrange elements of an array into a new one by using a function that
--   maps indices of the newly created one into the old one. This function
--   can throw <a>IndexOutOfBoundsException</a>.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; arr = makeArrayLinear @D Seq (Sz (2 :&gt; 3 :. 4)) id
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (2 :&gt; 3 :. 4))
--     [ [ [ 0, 1, 2, 3 ]
--       , [ 4, 5, 6, 7 ]
--       , [ 8, 9, 10, 11 ]
--       ]
--     , [ [ 12, 13, 14, 15 ]
--       , [ 16, 17, 18, 19 ]
--       , [ 20, 21, 22, 23 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; backpermuteM @U (Sz (4 :. 2)) (\(i :. j) -&gt; j :&gt; j :. i) arr
--   Array U Seq (Sz (4 :. 2))
--     [ [ 0, 16 ]
--     , [ 1, 17 ]
--     , [ 2, 18 ]
--     , [ 3, 19 ]
--     ]
--   </pre>
backpermuteM :: forall r ix e r' ix' m. (Mutable r ix e, Source r' ix' e, MonadUnliftIO m, PrimMonad m, MonadThrow m) => Sz ix -> (ix -> ix') -> Array r' ix' e -> m (Array r ix e)

-- | Similar to <a>backpermuteM</a>, with a few notable differences:
--   
--   <ul>
--   <li>Creates a delayed array, instead of manifest, therefore it can be
--   fused</li>
--   <li>Respects computation strategy, so it can be parallelized</li>
--   <li>Throws a runtime <a>IndexOutOfBoundsException</a> from pure
--   code.</li>
--   </ul>
backpermute' :: (Source r' ix' e, Index ix) => Sz ix -> (ix -> ix') -> Array r' ix' e -> Array D ix e

-- | <i>O(1)</i> - Changes the shape of an array. Returns <a>Nothing</a> if
--   total number of elements does not match the source array.
resizeM :: (MonadThrow m, Index ix', Load r ix e, Resize r ix) => Sz ix' -> Array r ix e -> m (Array r ix' e)

-- | Same as <a>resizeM</a>, but will throw an error if supplied dimensions
--   are incorrect.
resize' :: (Index ix', Load r ix e, Resize r ix) => Sz ix' -> Array r ix e -> Array r ix' e

-- | <i>O(1)</i> - Reduce a multi-dimensional array into a flat vector
flatten :: (Load r ix e, Resize r ix) => Array r ix e -> Array r Ix1 e

-- | Extract a sub-array from within a larger source array. Array that is
--   being extracted must be fully encapsulated in a source array,
--   otherwise <a>SizeSubregionException</a> will be thrown.
extractM :: (MonadThrow m, Extract r ix e) => ix -> Sz ix -> Array r ix e -> m (Array (R r) ix e)

-- | Same as <a>extractM</a>, but will throw a runtime exception from pure
--   code if supplied dimensions are incorrect.
extract' :: Extract r ix e => ix -> Sz ix -> Array r ix e -> Array (R r) ix e

-- | Similar to <a>extractM</a>, except it takes starting and ending index.
--   Result array will not include the ending index.
extractFromToM :: (MonadThrow m, Extract r ix e) => ix -> ix -> Array r ix e -> m (Array (R r) ix e)

-- | Same as <tt>extractFromTo</tt>, but throws an error on invalid
--   indices.
extractFromTo' :: Extract r ix e => ix -> ix -> Array r ix e -> Array (R r) ix e

-- | Similar to <a>deleteRegionM</a>, but drop a specified number of rows
--   from an array that has at least 2 dimensions.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = fromIx2 &lt;$&gt; (0 :. 0 ..: 3 :. 6)
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (3 :. 6))
--     [ [ (0,0), (0,1), (0,2), (0,3), (0,4), (0,5) ]
--     , [ (1,0), (1,1), (1,2), (1,3), (1,4), (1,5) ]
--     , [ (2,0), (2,1), (2,2), (2,3), (2,4), (2,5) ]
--     ]
--   
--   &gt;&gt;&gt; deleteRowsM 1 1 arr
--   Array DL Seq (Sz (2 :. 6))
--     [ [ (0,0), (0,1), (0,2), (0,3), (0,4), (0,5) ]
--     , [ (2,0), (2,1), (2,2), (2,3), (2,4), (2,5) ]
--     ]
--   </pre>
deleteRowsM :: (MonadThrow m, Extract r ix e, Source (R r) ix e, Index (Lower ix)) => Ix1 -> Sz Ix1 -> Array r ix e -> m (Array DL ix e)

-- | Similar to <a>deleteRegionM</a>, but drop a specified number of
--   columns an array.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = fromIx2 &lt;$&gt; (0 :. 0 ..: 3 :. 6)
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (3 :. 6))
--     [ [ (0,0), (0,1), (0,2), (0,3), (0,4), (0,5) ]
--     , [ (1,0), (1,1), (1,2), (1,3), (1,4), (1,5) ]
--     , [ (2,0), (2,1), (2,2), (2,3), (2,4), (2,5) ]
--     ]
--   
--   &gt;&gt;&gt; deleteColumnsM 2 3 arr
--   Array DL Seq (Sz (3 :. 3))
--     [ [ (0,0), (0,1), (0,5) ]
--     , [ (1,0), (1,1), (1,5) ]
--     , [ (2,0), (2,1), (2,5) ]
--     ]
--   </pre>
deleteColumnsM :: (MonadThrow m, Extract r ix e, Source (R r) ix e) => Ix1 -> Sz Ix1 -> Array r ix e -> m (Array DL ix e)

-- | Delete a region from an array along the specified dimension.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = fromIx3 &lt;$&gt; (0 :&gt; 0 :. 0 ..: 3 :&gt; 2 :. 6)
--   
--   &gt;&gt;&gt; deleteRegionM 1 2 3 arr
--   Array DL Seq (Sz (3 :&gt; 2 :. 3))
--     [ [ [ (0,0,0), (0,0,1), (0,0,5) ]
--       , [ (0,1,0), (0,1,1), (0,1,5) ]
--       ]
--     , [ [ (1,0,0), (1,0,1), (1,0,5) ]
--       , [ (1,1,0), (1,1,1), (1,1,5) ]
--       ]
--     , [ [ (2,0,0), (2,0,1), (2,0,5) ]
--       , [ (2,1,0), (2,1,1), (2,1,5) ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; v = Ix1 0 ... 10
--   
--   &gt;&gt;&gt; deleteRegionM 1 3 5 v
--   Array DL Seq (Sz1 6)
--     [ 0, 1, 2, 8, 9, 10 ]
--   </pre>
deleteRegionM :: (MonadThrow m, Extract r ix e, Source (R r) ix e) => Dim -> Ix1 -> Sz Ix1 -> Array r ix e -> m (Array DL ix e)

-- | Append two arrays together along the outer most dimension. Inner
--   dimensions must agree, otherwise <a>SizeMismatchException</a>.
appendOuterM :: forall ix e m. (Index ix, MonadThrow m) => Array DL ix e -> Array DL ix e -> m (Array DL ix e)

-- | Append two arrays together along a particular dimension. Sizes of both
--   arrays must match, with an allowed exception of the dimension they are
--   being appended along, otherwise <a>Nothing</a> is returned.
--   
--   <h4><b>Examples</b></h4>
--   
--   Append two 2D arrays along both dimensions. Note that they do agree on
--   inner dimensions.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arrA = makeArrayR U Seq (Sz2 2 3) (\(i :. j) -&gt; ('A', i, j))
--   
--   &gt;&gt;&gt; arrB = makeArrayR U Seq (Sz2 2 3) (\(i :. j) -&gt; ('B', i, j))
--   
--   &gt;&gt;&gt; appendM 1 arrA arrB
--   Array DL Seq (Sz (2 :. 6))
--     [ [ ('A',0,0), ('A',0,1), ('A',0,2), ('B',0,0), ('B',0,1), ('B',0,2) ]
--     , [ ('A',1,0), ('A',1,1), ('A',1,2), ('B',1,0), ('B',1,1), ('B',1,2) ]
--     ]
--   
--   &gt;&gt;&gt; appendM 2 arrA arrB
--   Array DL Seq (Sz (4 :. 3))
--     [ [ ('A',0,0), ('A',0,1), ('A',0,2) ]
--     , [ ('A',1,0), ('A',1,1), ('A',1,2) ]
--     , [ ('B',0,0), ('B',0,1), ('B',0,2) ]
--     , [ ('B',1,0), ('B',1,1), ('B',1,2) ]
--     ]
--   </pre>
--   
--   Now appending arrays with different sizes:
--   
--   <pre>
--   &gt;&gt;&gt; arrC = makeArrayR U Seq (Sz (2 :. 4)) (\(i :. j) -&gt; ('C', i, j))
--   
--   &gt;&gt;&gt; appendM 1 arrA arrC
--   Array DL Seq (Sz (2 :. 7))
--     [ [ ('A',0,0), ('A',0,1), ('A',0,2), ('C',0,0), ('C',0,1), ('C',0,2), ('C',0,3) ]
--     , [ ('A',1,0), ('A',1,1), ('A',1,2), ('C',1,0), ('C',1,1), ('C',1,2), ('C',1,3) ]
--     ]
--   
--   &gt;&gt;&gt; appendM 2 arrA arrC
--   *** Exception: SizeMismatchException: (Sz (2 :. 3)) vs (Sz (2 :. 4))
--   </pre>
appendM :: forall r1 r2 ix e m. (MonadThrow m, Source r1 ix e, Source r2 ix e) => Dim -> Array r1 ix e -> Array r2 ix e -> m (Array DL ix e)

-- | Same as <a>appendM</a>, but will throw an exception in pure code on
--   mismatched sizes.
append' :: (Source r1 ix e, Source r2 ix e) => Dim -> Array r1 ix e -> Array r2 ix e -> Array DL ix e

-- | Concat arrays together along the outer most dimension. Inner
--   dimensions must agree for all arrays in the list, otherwise
--   <a>SizeMismatchException</a>.
concatOuterM :: forall ix e m. (Index ix, MonadThrow m) => [Array DL ix e] -> m (Array DL ix e)

-- | Concatenate many arrays together along some dimension. It is important
--   that all sizes are equal, with an exception of the dimensions along
--   which concatenation happens.
--   
--   <i><b>Exceptions</b></i>: <a>IndexDimensionException</a>,
--   <a>SizeMismatchException</a>
concatM :: forall r ix e f m. (MonadThrow m, Foldable f, Source r ix e) => Dim -> f (Array r ix e) -> m (Array DL ix e)

-- | Concat many arrays together along some dimension.
concat' :: (Foldable f, Source r ix e) => Dim -> f (Array r ix e) -> Array DL ix e

-- | Stack slices on top of each other along the specified dimension.
--   
--   <i><b>Exceptions</b></i>: <a>IndexDimensionException</a>,
--   <a>SizeMismatchException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   Here are the three different ways to stack up two 2D Matrix pages into
--   a 3D array.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; x = compute (iterateN 3 succ 0) :: Matrix P Int
--   
--   &gt;&gt;&gt; y = compute (iterateN 3 succ 9) :: Matrix P Int
--   
--   &gt;&gt;&gt; x
--   Array P Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; y
--   Array P Seq (Sz (3 :. 3))
--     [ [ 10, 11, 12 ]
--     , [ 13, 14, 15 ]
--     , [ 16, 17, 18 ]
--     ]
--   
--   &gt;&gt;&gt; stackSlicesM 1 [x, y] :: IO (Array DL Ix3 Int)
--   Array DL Seq (Sz (3 :&gt; 3 :. 2))
--     [ [ [ 1, 10 ]
--       , [ 2, 11 ]
--       , [ 3, 12 ]
--       ]
--     , [ [ 4, 13 ]
--       , [ 5, 14 ]
--       , [ 6, 15 ]
--       ]
--     , [ [ 7, 16 ]
--       , [ 8, 17 ]
--       , [ 9, 18 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; stackSlicesM 2 [x, y] :: IO (Array DL Ix3 Int)
--   Array DL Seq (Sz (3 :&gt; 2 :. 3))
--     [ [ [ 1, 2, 3 ]
--       , [ 10, 11, 12 ]
--       ]
--     , [ [ 4, 5, 6 ]
--       , [ 13, 14, 15 ]
--       ]
--     , [ [ 7, 8, 9 ]
--       , [ 16, 17, 18 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; stackSlicesM 3 [x, y] :: IO (Array DL Ix3 Int)
--   Array DL Seq (Sz (2 :&gt; 3 :. 3))
--     [ [ [ 1, 2, 3 ]
--       , [ 4, 5, 6 ]
--       , [ 7, 8, 9 ]
--       ]
--     , [ [ 10, 11, 12 ]
--       , [ 13, 14, 15 ]
--       , [ 16, 17, 18 ]
--       ]
--     ]
--   </pre>
stackSlicesM :: forall r ix e f m. (Foldable f, MonadThrow m, Source r (Lower ix) e, Index ix) => Dim -> f (Array r (Lower ix) e) -> m (Array DL ix e)

-- | Specialized <a>stackSlicesM</a> to handling stacking from the outside.
--   It is the inverse of <a>outerSlices</a>.
--   
--   <i><b>Exceptions</b></i>: <a>SizeMismatchException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   In this example we stack vectors as row of a matrix from top to
--   bottom:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; x = compute (iterateN 3 succ 0) :: Matrix P Int
--   
--   &gt;&gt;&gt; x
--   Array P Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; rows = outerSlices x
--   
--   &gt;&gt;&gt; A.mapM_ print rows
--   Array M Seq (Sz1 3)
--     [ 1, 2, 3 ]
--   Array M Seq (Sz1 3)
--     [ 4, 5, 6 ]
--   Array M Seq (Sz1 3)
--     [ 7, 8, 9 ]
--   
--   &gt;&gt;&gt; stackOuterSlicesM rows :: IO (Matrix DL Int)
--   Array DL Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   </pre>
stackOuterSlicesM :: forall r ix e f m. (Foldable f, MonadThrow m, Source r (Lower ix) e, Index ix) => f (Array r (Lower ix) e) -> m (Array DL ix e)

-- | Specialized <a>stackSlicesM</a> to handling stacking from the inside.
--   It is the inverse of <a>innerSlices</a>.
--   
--   <i><b>Exceptions</b></i>: <a>SizeMismatchException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   In this example we stack vectors as columns of a matrix from left to
--   right:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; x = compute (iterateN 3 succ 0) :: Matrix P Int
--   
--   &gt;&gt;&gt; x
--   Array P Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; columns = innerSlices x
--   
--   &gt;&gt;&gt; A.mapM_ print columns
--   Array M Seq (Sz1 3)
--     [ 1, 4, 7 ]
--   Array M Seq (Sz1 3)
--     [ 2, 5, 8 ]
--   Array M Seq (Sz1 3)
--     [ 3, 6, 9 ]
--   
--   &gt;&gt;&gt; stackInnerSlicesM columns :: IO (Matrix DL Int)
--   Array DL Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   </pre>
stackInnerSlicesM :: forall r ix e f m. (Foldable f, MonadThrow m, Source r (Lower ix) e, Index ix) => f (Array r (Lower ix) e) -> m (Array DL ix e)

-- | <i>O(1)</i> - Split an array into two at an index along a specified
--   dimension.
--   
--   <i>Related</i>: <tt>splitAt</tt>`, <a>splitExtractM</a>,
--   <a>sliceAt</a>`, <a>sliceAtM</a>
--   
--   <i><b>Exceptions</b></i>: <a>IndexDimensionException</a>,
--   <a>SizeSubregionException</a>
splitAtM :: (MonadThrow m, Extract r ix e) => Dim -> Int -> Array r ix e -> m (Array (R r) ix e, Array (R r) ix e)

-- | <i>O(1)</i> - Split an array into two at an index along a specified
--   dimension. Throws an error for a wrong dimension or incorrect indices.
--   
--   <i>Related</i>: <a>splitAtM</a>, <a>splitExtractM</a>,
--   <a>sliceAt</a>`, <a>sliceAtM</a>
--   
--   <h4><b>Examples</b></h4>
splitAt' :: Extract r ix e => Dim -> Int -> Array r ix e -> (Array (R r) ix e, Array (R r) ix e)

-- | Split an array in three parts across some dimension
splitExtractM :: (MonadThrow m, Extract r ix e, Source (R r) ix e) => Dim -> Ix1 -> Sz Ix1 -> Array r ix e -> m (Array (R r) ix e, Array (R r) ix e, Array (R r) ix e)

-- | Replace a slice of an array with another one
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayR U Seq (Sz3 3 4 5) fromIx3
--   
--   &gt;&gt;&gt; arr' = makeArrayR U Seq (Sz3 3 4 5) (fromIx3 . liftIndex (* 100))
--   
--   &gt;&gt;&gt; replaceSlice 2 1 (arr' &lt;!&gt; (2, 3)) arr
--   Array DL Seq (Sz (3 :&gt; 4 :. 5))
--     [ [ [ (0,0,0), (0,0,1), (0,0,2), (0,0,3), (0,0,4) ]
--       , [ (0,300,0), (0,300,100), (0,300,200), (0,300,300), (0,300,400) ]
--       , [ (0,2,0), (0,2,1), (0,2,2), (0,2,3), (0,2,4) ]
--       , [ (0,3,0), (0,3,1), (0,3,2), (0,3,3), (0,3,4) ]
--       ]
--     , [ [ (1,0,0), (1,0,1), (1,0,2), (1,0,3), (1,0,4) ]
--       , [ (100,300,0), (100,300,100), (100,300,200), (100,300,300), (100,300,400) ]
--       , [ (1,2,0), (1,2,1), (1,2,2), (1,2,3), (1,2,4) ]
--       , [ (1,3,0), (1,3,1), (1,3,2), (1,3,3), (1,3,4) ]
--       ]
--     , [ [ (2,0,0), (2,0,1), (2,0,2), (2,0,3), (2,0,4) ]
--       , [ (200,300,0), (200,300,100), (200,300,200), (200,300,300), (200,300,400) ]
--       , [ (2,2,0), (2,2,1), (2,2,2), (2,2,3), (2,2,4) ]
--       , [ (2,3,0), (2,3,1), (2,3,2), (2,3,3), (2,3,4) ]
--       ]
--     ]
--   </pre>
replaceSlice :: (MonadThrow m, Extract r ix e, Source (R r) ix e, Load (R r) (Lower ix) e, Resize (R r) (Lower ix)) => Dim -> Ix1 -> Array (R r) (Lower ix) e -> Array r ix e -> m (Array DL ix e)

-- | Replace an outer slice of an array with another one
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayR U Seq (Sz3 3 4 5) fromIx3
--   
--   &gt;&gt;&gt; arr' = makeArrayR U Seq (Sz3 3 4 5) (fromIx3 . liftIndex (* 100))
--   
--   &gt;&gt;&gt; replaceOuterSlice 1 (arr' !&gt; 2) arr
--   Array DL Seq (Sz (3 :&gt; 4 :. 5))
--     [ [ [ (0,0,0), (0,0,1), (0,0,2), (0,0,3), (0,0,4) ]
--       , [ (0,1,0), (0,1,1), (0,1,2), (0,1,3), (0,1,4) ]
--       , [ (0,2,0), (0,2,1), (0,2,2), (0,2,3), (0,2,4) ]
--       , [ (0,3,0), (0,3,1), (0,3,2), (0,3,3), (0,3,4) ]
--       ]
--     , [ [ (200,0,0), (200,0,100), (200,0,200), (200,0,300), (200,0,400) ]
--       , [ (200,100,0), (200,100,100), (200,100,200), (200,100,300), (200,100,400) ]
--       , [ (200,200,0), (200,200,100), (200,200,200), (200,200,300), (200,200,400) ]
--       , [ (200,300,0), (200,300,100), (200,300,200), (200,300,300), (200,300,400) ]
--       ]
--     , [ [ (2,0,0), (2,0,1), (2,0,2), (2,0,3), (2,0,4) ]
--       , [ (2,1,0), (2,1,1), (2,1,2), (2,1,3), (2,1,4) ]
--       , [ (2,2,0), (2,2,1), (2,2,2), (2,2,3), (2,2,4) ]
--       , [ (2,3,0), (2,3,1), (2,3,2), (2,3,3), (2,3,4) ]
--       ]
--     ]
--   </pre>
replaceOuterSlice :: (MonadThrow m, Extract r ix e, Source (R r) ix e, Load (R r) (Lower ix) e, Resize (R r) (Lower ix)) => Ix1 -> Array (R r) (Lower ix) e -> Array r ix e -> m (Array DL ix e)

-- | Insert the same element into a <a>Load</a>able array according to the
--   supplied stride.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = iterateN (Sz2 3 2) succ (0 :: Int)
--   
--   &gt;&gt;&gt; arr
--   Array DL Seq (Sz (3 :. 2))
--     [ [ 1, 2 ]
--     , [ 3, 4 ]
--     , [ 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; upsample 0 (Stride (2 :. 3)) arr
--   Array DL Seq (Sz (6 :. 6))
--     [ [ 1, 0, 0, 2, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     , [ 3, 0, 0, 4, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     , [ 5, 0, 0, 6, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     ]
--   
--   &gt;&gt;&gt; upsample 9 (Stride (1 :. 2)) arr
--   Array DL Seq (Sz (3 :. 4))
--     [ [ 1, 9, 2, 9 ]
--     , [ 3, 9, 4, 9 ]
--     , [ 5, 9, 6, 9 ]
--     ]
--   </pre>
upsample :: forall r ix e. Load r ix e => e -> Stride ix -> Array r ix e -> Array DL ix e

-- | Discard elements from the source array according to the stride.
downsample :: forall r ix e. Source r ix e => Stride ix -> Array r ix e -> Array DL ix e

-- | Increaze the size of the array accoridng to the stride multiplier
--   while replicating the same element to fill the neighbors. It is
--   exactly the same as <a>zoomWithGrid</a>, but without the grid.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = resize' (Sz3 1 3 2) (Ix1 1 ... 6)
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (1 :&gt; 3 :. 2))
--     [ [ [ 1, 2 ]
--       , [ 3, 4 ]
--       , [ 5, 6 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; zoom (Stride (2 :&gt; 2 :. 3)) arr
--   Array DL Seq (Sz (2 :&gt; 6 :. 6))
--     [ [ [ 1, 1, 1, 2, 2, 2 ]
--       , [ 1, 1, 1, 2, 2, 2 ]
--       , [ 3, 3, 3, 4, 4, 4 ]
--       , [ 3, 3, 3, 4, 4, 4 ]
--       , [ 5, 5, 5, 6, 6, 6 ]
--       , [ 5, 5, 5, 6, 6, 6 ]
--       ]
--     , [ [ 1, 1, 1, 2, 2, 2 ]
--       , [ 1, 1, 1, 2, 2, 2 ]
--       , [ 3, 3, 3, 4, 4, 4 ]
--       , [ 3, 3, 3, 4, 4, 4 ]
--       , [ 5, 5, 5, 6, 6, 6 ]
--       , [ 5, 5, 5, 6, 6, 6 ]
--       ]
--     ]
--   </pre>
zoom :: forall r ix e. Source r ix e => Stride ix -> Array r ix e -> Array DL ix e

-- | Replicate each element of the array by a factor in stride along each
--   dimension and surround each such group with a box of supplied grid
--   value. It will essentially zoom up an array and create a grid around
--   each element from the original array. Very useful for zooming up
--   images to inspect individual pixels.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = resize' (Sz2 3 2) (Ix1 1 ... 6)
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (3 :. 2))
--     [ [ 1, 2 ]
--     , [ 3, 4 ]
--     , [ 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; zoomWithGrid 0 (Stride (2 :. 3)) arr
--   Array DL Seq (Sz (10 :. 9))
--     [ [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 1, 1, 1, 0, 2, 2, 2, 0 ]
--     , [ 0, 1, 1, 1, 0, 2, 2, 2, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 3, 3, 3, 0, 4, 4, 4, 0 ]
--     , [ 0, 3, 3, 3, 0, 4, 4, 4, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 5, 5, 5, 0, 6, 6, 6, 0 ]
--     , [ 0, 5, 5, 5, 0, 6, 6, 6, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     ]
--   </pre>
zoomWithGrid :: forall r ix e. Source r ix e => e -> Stride ix -> Array r ix e -> Array DL ix e

-- | General array transformation, that forces computation and produces a
--   manifest array.
transformM :: forall r ix e r' ix' e' a m. (Mutable r ix e, Source r' ix' e', MonadUnliftIO m, PrimMonad m, MonadThrow m) => (Sz ix' -> m (Sz ix, a)) -> (a -> (ix' -> m e') -> ix -> m e) -> Array r' ix' e' -> m (Array r ix e)

-- | General array transformation
transform' :: (Source r' ix' e', Index ix) => (Sz ix' -> (Sz ix, a)) -> (a -> (ix' -> e') -> ix -> e) -> Array r' ix' e' -> Array D ix e

-- | Same as <a>transformM</a>, but operates on two arrays
transform2M :: (Mutable r ix e, Source r1 ix1 e1, Source r2 ix2 e2, MonadUnliftIO m, PrimMonad m, MonadThrow m) => (Sz ix1 -> Sz ix2 -> m (Sz ix, a)) -> (a -> (ix1 -> m e1) -> (ix2 -> m e2) -> ix -> m e) -> Array r1 ix1 e1 -> Array r2 ix2 e2 -> m (Array r ix e)

-- | Same as <tt>transform</tt>`, but operates on two arrays
transform2' :: (Source r1 ix1 e1, Source r2 ix2 e2, Index ix) => (Sz ix1 -> Sz ix2 -> (Sz ix, a)) -> (a -> (ix1 -> e1) -> (ix2 -> e2) -> ix -> e) -> Array r1 ix1 e1 -> Array r2 ix2 e2 -> Array D ix e

-- | <i>O(1)</i> - Slices the array from the outside. For 2-dimensional
--   array this will be equivalent of taking a row. Throws an error when
--   index is out of bounds.
--   
--   <h3><b>Examples</b></h3>
--   
--   You could say that slicing from outside is synonymous to slicing from
--   the end or slicing at the highermost dimension. For example with
--   rank-3 arrays outer slice would be equivalent to getting a page:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayR U Seq (Sz (3 :&gt; 2 :. 4)) fromIx3
--   
--   &gt;&gt;&gt; arr
--   Array U Seq (Sz (3 :&gt; 2 :. 4))
--     [ [ [ (0,0,0), (0,0,1), (0,0,2), (0,0,3) ]
--       , [ (0,1,0), (0,1,1), (0,1,2), (0,1,3) ]
--       ]
--     , [ [ (1,0,0), (1,0,1), (1,0,2), (1,0,3) ]
--       , [ (1,1,0), (1,1,1), (1,1,2), (1,1,3) ]
--       ]
--     , [ [ (2,0,0), (2,0,1), (2,0,2), (2,0,3) ]
--       , [ (2,1,0), (2,1,1), (2,1,2), (2,1,3) ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; arr !&gt; 2
--   Array M Seq (Sz (2 :. 4))
--     [ [ (2,0,0), (2,0,1), (2,0,2), (2,0,3) ]
--     , [ (2,1,0), (2,1,1), (2,1,2), (2,1,3) ]
--     ]
--   </pre>
--   
--   There is nothing wrong with chaining, mixing and matching slicing
--   operators, or even using them to index arrays:
--   
--   <pre>
--   &gt;&gt;&gt; arr !&gt; 2 !&gt; 0 !&gt; 3
--   (2,0,3)
--   
--   &gt;&gt;&gt; arr !&gt; 2 &lt;! 3 ! 0
--   (2,0,3)
--   
--   &gt;&gt;&gt; (arr !&gt; 2 !&gt; 0 !&gt; 3) == (arr ! 2 :&gt; 0 :. 3)
--   True
--   </pre>
(!>) :: OuterSlice r ix e => Array r ix e -> Int -> Elt r ix e
infixl 4 !>

-- | <i>O(1)</i> - Just like <a>!&gt;</a> slices the array from the
--   outside, but returns <a>Nothing</a> when index is out of bounds.
(!?>) :: (MonadThrow m, OuterSlice r ix e) => Array r ix e -> Int -> m (Elt r ix e)
infixl 4 !?>

-- | <i>O(1)</i> - Safe slicing continuation from the outside. Similarly to
--   (<a>!&gt;</a>) slices the array from the outside, but takes
--   <a>Maybe</a> array as input and returns <a>Nothing</a> when index is
--   out of bounds.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayR U Seq (Sz (3 :&gt; 2 :. 4)) fromIx3
--   
--   &gt;&gt;&gt; arr !?&gt; 2 ??&gt; 0 ??&gt; 3 :: Maybe Ix3T
--   Just (2,0,3)
--   
--   &gt;&gt;&gt; arr !?&gt; 2 ??&gt; 0 ??&gt; -1 :: Maybe Ix3T
--   Nothing
--   
--   &gt;&gt;&gt; arr !?&gt; 2 ??&gt; -10 ?? 1
--   *** Exception: IndexOutOfBoundsException: -10 is not safe for (Sz1 2)
--   </pre>
(??>) :: (MonadThrow m, OuterSlice r ix e) => m (Array r ix e) -> Int -> m (Elt r ix e)
infixl 4 ??>

-- | <i>O(1)</i> - Similarly to (<a>!&gt;</a>) slice an array from an
--   opposite direction.
(<!) :: InnerSlice r ix e => Array r ix e -> Int -> Elt r ix e
infixl 4 <!

-- | <i>O(1)</i> - Safe slice from the inside
(<!?) :: (MonadThrow m, InnerSlice r ix e) => Array r ix e -> Int -> m (Elt r ix e)
infixl 4 <!?

-- | <i>O(1)</i> - Safe slicing continuation from the inside
(<??) :: (MonadThrow m, InnerSlice r ix e) => m (Array r ix e) -> Int -> m (Elt r ix e)
infixl 4 <??

-- | <i>O(1)</i> - Slices the array in any available dimension. Throws an
--   error when index is out of bounds or dimensions is invalid.
(<!>) :: Slice r ix e => Array r ix e -> (Dim, Int) -> Elt r ix e
infixl 4 <!>

-- | <i>O(1)</i> - Same as (<a>&lt;!&gt;</a>), but fails gracefully with a
--   <a>Nothing</a>, instead of an error
(<!?>) :: (MonadThrow m, Slice r ix e) => Array r ix e -> (Dim, Int) -> m (Elt r ix e)
infixl 4 <!?>

-- | <i>O(1)</i> - Safe slicing continuation from within.
(<??>) :: (MonadThrow m, Slice r ix e) => m (Array r ix e) -> (Dim, Int) -> m (Elt r ix e)
infixl 4 <??>

-- | Create a delayed array of outer slices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; A.mapM_ print $ outerSlices (0 ..: (3 :. 2))
--   Array D Seq (Sz1 2)
--     [ 0 :. 0, 0 :. 1 ]
--   Array D Seq (Sz1 2)
--     [ 1 :. 0, 1 :. 1 ]
--   Array D Seq (Sz1 2)
--     [ 2 :. 0, 2 :. 1 ]
--   </pre>
outerSlices :: OuterSlice r ix e => Array r ix e -> Array D Ix1 (Elt r ix e)

-- | Create a delayed array of inner slices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; A.mapM_ print $ innerSlices (0 ..: (3 :. 2))
--   Array D Seq (Sz1 3)
--     [ 0 :. 0, 1 :. 0, 2 :. 0 ]
--   Array D Seq (Sz1 3)
--     [ 0 :. 1, 1 :. 1, 2 :. 1 ]
--   </pre>
innerSlices :: InnerSlice r ix e => Array r ix e -> Array D Ix1 (Elt r ix e)

-- | Create a delayed array of slices from within. Checks dimension at
--   compile time.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = fromIx3 &lt;$&gt; (0 ..: (4 :&gt; 3 :. 2))
--   
--   &gt;&gt;&gt; print arr
--   Array D Seq (Sz (4 :&gt; 3 :. 2))
--     [ [ [ (0,0,0), (0,0,1) ]
--       , [ (0,1,0), (0,1,1) ]
--       , [ (0,2,0), (0,2,1) ]
--       ]
--     , [ [ (1,0,0), (1,0,1) ]
--       , [ (1,1,0), (1,1,1) ]
--       , [ (1,2,0), (1,2,1) ]
--       ]
--     , [ [ (2,0,0), (2,0,1) ]
--       , [ (2,1,0), (2,1,1) ]
--       , [ (2,2,0), (2,2,1) ]
--       ]
--     , [ [ (3,0,0), (3,0,1) ]
--       , [ (3,1,0), (3,1,1) ]
--       , [ (3,2,0), (3,2,1) ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; A.mapM_ print $ withinSlices Dim2 arr
--   Array D Seq (Sz (4 :. 2))
--     [ [ (0,0,0), (0,0,1) ]
--     , [ (1,0,0), (1,0,1) ]
--     , [ (2,0,0), (2,0,1) ]
--     , [ (3,0,0), (3,0,1) ]
--     ]
--   Array D Seq (Sz (4 :. 2))
--     [ [ (0,1,0), (0,1,1) ]
--     , [ (1,1,0), (1,1,1) ]
--     , [ (2,1,0), (2,1,1) ]
--     , [ (3,1,0), (3,1,1) ]
--     ]
--   Array D Seq (Sz (4 :. 2))
--     [ [ (0,2,0), (0,2,1) ]
--     , [ (1,2,0), (1,2,1) ]
--     , [ (2,2,0), (2,2,1) ]
--     , [ (3,2,0), (3,2,1) ]
--     ]
--   </pre>
withinSlices :: (IsIndexDimension ix n, Slice r ix e) => Dimension n -> Array r ix e -> Array D Ix1 (Elt r ix e)

-- | Create a delayed array of slices from within. Same as
--   <a>withinSlices</a>, but throws an error on invalid dimension.
--   
--   <i><b>Throws Exceptions</b></i>: <a>IndexDimensionException</a>
withinSlicesM :: (MonadThrow m, Slice r ix e) => Dim -> Array r ix e -> m (Array D Ix1 (Elt r ix e))

-- | This is an implementation of <a>Quicksort</a>, which is an efficient,
--   but unstable sort that uses Median-of-three for pivot choosing, as
--   such it performs very well not only for random values, but also for
--   common edge cases like already sorted, reversed sorted and arrays with
--   many duplicate elements. It will also respect the computation strategy
--   and will result in a nice speed up for systems with multiple CPUs.
quicksort :: (Mutable r Ix1 e, Ord e) => Array r Ix1 e -> Array r Ix1 e

-- | Same as <a>quicksortBy</a>, but instead of <a>Ord</a> constraint
--   expects a custom <a>Ordering</a>.
quicksortBy :: Mutable r Ix1 e => (e -> e -> Ordering) -> Vector r e -> Vector r e

-- | Same as <a>quicksortBy</a>, but instead of <a>Ord</a> constraint
--   expects a custom <a>Ordering</a>.
quicksortByM :: (Mutable r Ix1 e, MonadUnliftIO m) => (e -> e -> m Ordering) -> Vector r e -> m (Vector r e)

-- | Count number of occurrences of each element in the array. Results will
--   be sorted in ascending order of the element.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; xs = fromList Seq [2, 4, 3, 2, 4, 5, 2, 1] :: Array P Ix1 Int
--   
--   &gt;&gt;&gt; xs
--   Array P Seq (Sz1 8)
--     [ 2, 4, 3, 2, 4, 5, 2, 1 ]
--   
--   &gt;&gt;&gt; tally xs
--   Array DS Seq (Sz1 5)
--     [ (1,1), (2,3), (3,1), (4,2), (5,1) ]
--   </pre>
tally :: (Mutable r Ix1 e, Resize r ix, Load r ix e, Ord e) => Array r ix e -> Vector DS (e, Int)

-- | Efficiently iterate a function until a convergence condition is
--   satisfied. If the size of array doesn't change between iterations then
--   no more than two new arrays will be allocated, regardless of the
--   number of iterations. If the size does change from one iteration to
--   another, an attempt will be made to grow/shrink the intermediate
--   mutable array instead of allocating a new one.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; a = computeAs P $ makeLoadArrayS (Sz2 8 8) (0 :: Int) $ \ w -&gt; () &lt;$ w (0 :. 0) 1
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (8 :. 8))
--     [ [ 1, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     ]
--   
--   &gt;&gt;&gt; nextPascalRow cur above = if cur == 0 then above else cur
--   
--   &gt;&gt;&gt; pascal = makeStencil (Sz2 2 2) 1 $ \ get -&gt; nextPascalRow (get (0 :. 0)) (get (-1 :. -1) + get (-1 :. 0))
--   
--   &gt;&gt;&gt; iterateUntil (\_ _ a -&gt; (a ! (7 :. 7)) /= 0) (\ _ -&gt; mapStencil (Fill 0) pascal) a
--   Array P Seq (Sz (8 :. 8))
--     [ [ 1, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 1, 1, 0, 0, 0, 0, 0, 0 ]
--     , [ 1, 2, 1, 0, 0, 0, 0, 0 ]
--     , [ 1, 3, 3, 1, 0, 0, 0, 0 ]
--     , [ 1, 4, 6, 4, 1, 0, 0, 0 ]
--     , [ 1, 5, 10, 10, 5, 1, 0, 0 ]
--     , [ 1, 6, 15, 20, 15, 6, 1, 0 ]
--     , [ 1, 7, 21, 35, 35, 21, 7, 1 ]
--     ]
--   </pre>
iterateUntil :: (Load r' ix e, Mutable r ix e) => (Int -> Array r ix e -> Array r ix e -> Bool) -> (Int -> Array r ix e -> Array r' ix e) -> Array r ix e -> Array r ix e

-- | Convert a flat list into a vector
fromList :: forall r e. Mutable r Ix1 e => Comp -> [e] -> Array r Ix1 e

-- | <i>O(n)</i> - Convert a nested list into an array. Nested list must be
--   of a rectangular shape, otherwise a runtime error will occur. Also,
--   nestedness must match the rank of resulting array, which should be
--   specified through an explicit type signature.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; fromListsM Seq [[1,2,3],[4,5,6]] :: Maybe (Array U Ix2 Int)
--   Just (Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   )
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromListsM Par [[[1,2,3]],[[4,5,6]]] :: Maybe (Array U Ix3 Int)
--   Just (Array U Par (Sz (2 :&gt; 1 :. 3))
--     [ [ [ 1, 2, 3 ]
--       ]
--     , [ [ 4, 5, 6 ]
--       ]
--     ]
--   )
--   </pre>
--   
--   Elements of a boxed array could be lists themselves if necessary, but
--   cannot be ragged:
--   
--   <pre>
--   &gt;&gt;&gt; fromListsM Seq [[[1,2,3]],[[4,5]]] :: Maybe (Array B Ix2 [Int])
--   Just (Array B Seq (Sz (2 :. 1))
--     [ [ [1,2,3] ]
--     , [ [4,5] ]
--     ]
--   )
--   
--   &gt;&gt;&gt; fromListsM Seq [[[1,2,3]],[[4,5]]] :: Maybe (Array B Ix3 Int)
--   Nothing
--   
--   &gt;&gt;&gt; fromListsM Seq [[[1,2,3]],[[4,5]]] :: IO (Array B Ix3 Int)
--   *** Exception: DimTooShortException: expected (Sz1 3), got (Sz1 2)
--   </pre>
fromListsM :: forall r ix e m. (Nested LN ix e, Ragged L ix e, Mutable r ix e, MonadThrow m) => Comp -> [ListItem ix e] -> m (Array r ix e)

-- | Same as <a>fromListsM</a>, but will throw a pure error on irregular
--   shaped lists.
--   
--   <b>Note</b>: This function is the same as if you would turn on <tt>{-#
--   LANGUAGE OverloadedLists #-}</tt> extension. For that reason you can
--   also use <a>fromList</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert a list of lists into a 2D Array
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; fromLists' Seq [[1,2,3],[4,5,6]] :: Array U Ix2 Int
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   </pre>
--   
--   Above example implemented using GHC's <tt>OverloadedLists</tt>
--   extension:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; [[1,2,3],[4,5,6]] :: Array U Ix2 Int
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   </pre>
--   
--   Example of failure on conversion of an irregular nested list.
--   
--   <pre>
--   &gt;&gt;&gt; fromLists' Seq [[1],[3,4]] :: Array U Ix2 Int
--   Array U *** Exception: DimTooLongException
--   </pre>
fromLists' :: forall r ix e. (Nested LN ix e, Ragged L ix e, Mutable r ix e) => Comp -> [ListItem ix e] -> Array r ix e

-- | Convert any array to a flat list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; toList $ makeArrayR U Seq (Sz (2 :. 3)) fromIx2
--   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
--   </pre>
toList :: Source r ix e => Array r ix e -> [e]

-- | <i>O(n)</i> - Convert an array into a nested list. Number of array
--   dimensions and list nestedness will always match, but you can use
--   <a>toList</a>, <a>toLists2</a>, etc. if flattening of inner dimensions
--   is desired.
--   
--   <b>Note</b>: This function is almost the same as <a>toList</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayR U Seq (Sz (2 :&gt; 1 :. 3)) id
--   
--   &gt;&gt;&gt; arr
--   Array U Seq (Sz (2 :&gt; 1 :. 3))
--     [ [ [ 0 :&gt; 0 :. 0, 0 :&gt; 0 :. 1, 0 :&gt; 0 :. 2 ]
--       ]
--     , [ [ 1 :&gt; 0 :. 0, 1 :&gt; 0 :. 1, 1 :&gt; 0 :. 2 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; toLists arr
--   [[[0 :&gt; 0 :. 0,0 :&gt; 0 :. 1,0 :&gt; 0 :. 2]],[[1 :&gt; 0 :. 0,1 :&gt; 0 :. 1,1 :&gt; 0 :. 2]]]
--   </pre>
toLists :: (Nested LN ix e, Construct L ix e, Source r ix e) => Array r ix e -> [ListItem ix e]

-- | Convert an array with at least 2 dimensions into a list of lists.
--   Inner dimensions will get flattened.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; toLists2 $ makeArrayR U Seq (Sz2 2 3) fromIx2
--   [[(0,0),(0,1),(0,2)],[(1,0),(1,1),(1,2)]]
--   
--   &gt;&gt;&gt; toLists2 $ makeArrayR U Seq (Sz3 2 1 3) fromIx3
--   [[(0,0,0),(0,0,1),(0,0,2)],[(1,0,0),(1,0,1),(1,0,2)]]
--   </pre>
toLists2 :: (Source r ix e, Index (Lower ix)) => Array r ix e -> [[e]]

-- | Convert an array with at least 3 dimensions into a 3 deep nested list.
--   Inner dimensions will get flattened.
toLists3 :: (Index (Lower (Lower ix)), Index (Lower ix), Source r ix e) => Array r ix e -> [[[e]]]

-- | Convert an array with at least 4 dimensions into a 4 deep nested list.
--   Inner dimensions will get flattened.
toLists4 :: (Index (Lower (Lower (Lower ix))), Index (Lower (Lower ix)), Index (Lower ix), Source r ix e) => Array r ix e -> [[[[e]]]]


module Data.Massiv.Array.Unsafe

-- | Specify how an array can be loaded/computed through creation of a
--   <a>DL</a> array. Unlike <a>makeLoadArrayS</a> or <a>makeLoadArray</a>
--   this function is unsafe, since there is no guarantee that all elements
--   will be initialized and the supplied element writing function does not
--   perform any bounds checking.
unsafeMakeLoadArray :: forall ix e. Index ix => Comp -> Sz ix -> Maybe e -> (forall m. Monad m => Scheduler m () -> Ix1 -> (Ix1 -> e -> m ()) -> m ()) -> Array DL ix e

-- | Same as <a>unsafeMakeLoadArray</a>, except will ensure that starting
--   index is correctly adjusted. Which means the writing function gets one
--   less argument.
unsafeMakeLoadArrayAdjusted :: forall ix e. Index ix => Comp -> Sz ix -> Maybe e -> (forall m. Monad m => Scheduler m () -> (Ix1 -> e -> m ()) -> m ()) -> Array DL ix e

-- | <a>Sz</a> provides type safety guarantees preventing mixup with index,
--   which is used for looking into array cells, from the size, that
--   describes total number of elements along each dimension in the array.
--   Moreover the <tt>Sz</tt> constructor will prevent creation of invalid
--   sizes with negative numbers.
newtype Sz ix

-- | Safe size constructor. It is unsafe to use it without making sure that
--   it does not contain negative components. Use <a>Sz</a> pattern
--   instead.
SafeSz :: ix -> Sz ix

-- | Stride provides a way to ignore elements of an array if an index is
--   divisible by a corresponding value in a stride. So, for a <tt>Stride
--   (i :. j)</tt> only elements with indices will be kept around:
--   
--   <pre>
--   ( 0 :. 0) ( 0 :. j) ( 0 :. 2j) ( 0 :. 3j) ...
--   ( i :. 0) ( i :. j) ( i :. 2j) ( i :. 3j) ...
--   (2i :. 0) (2i :. j) (2i :. 2j) (2i :. 3j) ...
--   ...
--   </pre>
--   
--   Only positive strides make sense, so <a>Stride</a> pattern synonym
--   constructor will prevent a user from creating a stride with negative
--   or zero values, thus promoting safety of the library.
--   
--   <h4><b>Examples:</b></h4>
--   
--   <ul>
--   <li>Default and minimal stride of <tt><a>Stride</a> (<a>pureIndex</a>
--   1)</tt> will have no affect and all elements will kept.</li>
--   </ul>
--   
--   <ul>
--   <li>If stride is <tt><a>Stride</a> 2</tt>, then every 2nd element
--   (i.e. with index 1, 3, 5, ..) will be skipped and only elemnts with
--   indices divisible by 2 will be kept around.</li>
--   <li>In case of two dimensions, if what you want is to keep all rows
--   divisible by 5, but keep every column intact then you'd use <tt>Stride
--   (5 :. 1)</tt>.</li>
--   </ul>
newtype Stride ix
SafeStride :: ix -> Stride ix

-- | Lookup element in the array. No bounds check is performed and access
--   of arbitrary memory is possible when invalid index is supplied.
unsafeIndex :: Source r ix e => Array r ix e -> ix -> e

-- | Lookup element in the array using flat index in a row-major fashion.
--   No bounds check is performed
unsafeLinearIndex :: Source r ix e => Array r ix e -> Int -> e
unsafeLinearIndexM :: Manifest r ix e => Array r ix e -> Int -> e
unsafeBackpermute :: (Source r' ix' e, Index ix) => Sz ix -> (ix -> ix') -> Array r' ix' e -> Array D ix e

-- | <i>O(1)</i> - Change the size of an array. Total number of elements
--   should be the same, but it is not validated.
unsafeResize :: (Resize r ix, Index ix') => Sz ix' -> Array r ix e -> Array r ix' e

-- | <i>O(1)</i> - Extract a portion of an array. Staring index and new
--   size are not validated.
unsafeExtract :: Extract r ix e => ix -> Sz ix -> Array r ix e -> Array (R r) ix e

-- | Same <a>transform</a>`, except no bounds checking is performed, thus
--   making it faster, but unsafe.
unsafeTransform :: (Source r' ix' e', Index ix) => (Sz ix' -> (Sz ix, a)) -> (a -> (ix' -> e') -> ix -> e) -> Array r' ix' e' -> Array D ix e

-- | Same <a>transform2</a>`, except no bounds checking is performed, thus
--   making it faster, but unsafe.
unsafeTransform2 :: (Source r1 ix1 e1, Source r2 ix2 e2, Index ix) => (Sz ix1 -> Sz ix2 -> (Sz ix, a)) -> (a -> (ix1 -> e1) -> (ix2 -> e2) -> ix -> e) -> Array r1 ix1 e1 -> Array r2 ix2 e2 -> Array D ix e
unsafeSlice :: (Slice r ix e, MonadThrow m) => Array r ix e -> ix -> Sz ix -> Dim -> m (Elt r ix e)

-- | <i>O(1)</i> - Take a slice out of an array from the outside
unsafeOuterSlice :: OuterSlice r ix e => Array r ix e -> Int -> Elt r ix e
unsafeInnerSlice :: InnerSlice r ix e => Array r ix e -> (Sz (Lower ix), Sz Int) -> Int -> Elt r ix e

-- | <i>O(1)</i> - Source arrays also give us ability to look at their
--   linear slices in constant time
unsafeLinearSlice :: Source r ix e => Ix1 -> Sz1 -> Array r ix e -> Array r Ix1 e

-- | Convert immutable array into a mutable array without copy.
unsafeThaw :: (Mutable r ix e, PrimMonad m) => Array r ix e -> m (MArray (PrimState m) r ix e)

-- | Convert mutable array into an immutable array without copy.
unsafeFreeze :: (Mutable r ix e, PrimMonad m) => Comp -> MArray (PrimState m) r ix e -> m (Array r ix e)

-- | Create new mutable array, leaving it's elements uninitialized. Size
--   isn't validated either.
unsafeNew :: (Mutable r ix e, PrimMonad m) => Sz ix -> m (MArray (PrimState m) r ix e)

-- | Load into a supplied mutable array sequentially. Returned array does
--   not have to be the same
unsafeLoadIntoS :: (Load r ix e, Mutable r' ix e, PrimMonad m) => MArray (PrimState m) r' ix e -> Array r ix e -> m (MArray (PrimState m) r' ix e)

-- | Same as <a>unsafeLoadIntoS</a>, but respecting computation strategy.
unsafeLoadIntoM :: (Load r ix e, Mutable r' ix e, MonadIO m) => MArray RealWorld r' ix e -> Array r ix e -> m (MArray RealWorld r' ix e)

-- | Same as <a>createArray</a>, but memory will not be initialized and for
--   unboxed types might contain garbage.
unsafeCreateArray :: forall r ix e a m b. (Mutable r ix e, PrimMonad m, MonadUnliftIO m) => Comp -> Sz ix -> (Scheduler m a -> MArray (PrimState m) r ix e -> m b) -> m ([a], Array r ix e)

-- | Same as <a>createArray_</a>, but memory will not be initialized and
--   for unboxed types might contain garbage.
unsafeCreateArray_ :: forall r ix e a m b. (Mutable r ix e, PrimMonad m, MonadUnliftIO m) => Comp -> Sz ix -> (Scheduler m a -> MArray (PrimState m) r ix e -> m b) -> m (Array r ix e)

-- | Same as <a>createArrayS</a>, but memory will not be initialized and
--   for unboxed types might contain garbage.
unsafeCreateArrayS :: forall r ix e a m. (Mutable r ix e, PrimMonad m) => Sz ix -> (MArray (PrimState m) r ix e -> m a) -> m (a, Array r ix e)

-- | Read an array element
unsafeRead :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> m e

-- | Read an element at linear row-major index
unsafeLinearRead :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> Int -> m e

-- | Write an element into array
unsafeWrite :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> e -> m ()

-- | Write an element into mutable array with linear row-major index
unsafeLinearWrite :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> Int -> e -> m ()

-- | Modify an element in the array with a monadic action. Returns the
--   previous value.
unsafeModify :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> ix -> m e

-- | Modify an element in the array with a monadic action. Returns the
--   previous value.
unsafeLinearModify :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> Int -> m e

-- | Swap two elements in a mutable array under the supplied indices.
--   Returns the previous values.
unsafeSwap :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> ix -> m (e, e)

-- | Swap two elements in a mutable array under the supplied linear
--   indices. Returns the previous values.
unsafeLinearSwap :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> Int -> Int -> m (e, e)

-- | Set all cells in the mutable array within the range to a specified
--   value.
unsafeLinearSet :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> Ix1 -> Sz1 -> e -> m ()

-- | Copy part of one mutable array into another
unsafeLinearCopy :: (Mutable r ix e, Mutable r ix' e, PrimMonad m) => MArray (PrimState m) r ix' e -> Ix1 -> MArray (PrimState m) r ix e -> Ix1 -> Sz1 -> m ()

-- | Copy a part of a pure array into a mutable array
unsafeArrayLinearCopy :: (Mutable r ix e, Mutable r ix' e, PrimMonad m) => Array r ix' e -> Ix1 -> MArray (PrimState m) r ix e -> Ix1 -> Sz1 -> m ()

-- | Linearly reduce the size of an array. Total number of elements should
--   be smaller or equal. There is no guarantee that the original array is
--   left unchanged, so it should no longer be used.
unsafeLinearShrink :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> Sz ix -> m (MArray (PrimState m) r ix e)

-- | Linearly increase the size of an array. Total number of elements
--   should be larger or equal. There is no guarantee that the original
--   array is left unchanged, so it should no longer be used.
unsafeLinearGrow :: (Mutable r ix e, PrimMonad m) => MArray (PrimState m) r ix e -> Sz ix -> m (MArray (PrimState m) r ix e)

-- | Allocate memory using <tt>malloc</tt> on C heap, instead of on Haskell
--   heap. Memory is left uninitialized
unsafeMallocMArray :: forall ix e m. (Index ix, Storable e, MonadIO m) => Sz ix -> m (MArray RealWorld S ix e)

-- | A pointer to the beginning of the storable array. It is unsafe since,
--   if mutated, it can break referential transparency.
unsafeWithPtr :: (MonadUnliftIO m, Storable a) => Array S ix a -> (Ptr a -> m b) -> m b

-- | <i>O(1)</i> - Yield the underlying <a>ForeignPtr</a> together with its
--   length.
unsafeArrayToForeignPtr :: Storable e => Array S ix e -> (ForeignPtr e, Int)

-- | <i>O(1)</i> - Yield the underlying <a>ForeignPtr</a> together with its
--   length.
unsafeMArrayToForeignPtr :: Storable e => MArray s S ix e -> (ForeignPtr e, Int)

-- | <i>O(1)</i> - Wrap a <a>ForeignPtr</a>, an offset and it's size into a
--   pure storable array.
unsafeArrayFromForeignPtr :: Storable e => Comp -> ForeignPtr e -> Int -> Sz1 -> Array S Ix1 e

-- | <i>O(1)</i> - Wrap a <a>ForeignPtr</a> and it's size into a pure
--   storable array.
unsafeArrayFromForeignPtr0 :: Storable e => Comp -> ForeignPtr e -> Sz1 -> Array S Ix1 e

-- | <i>O(1)</i> - Wrap a <a>ForeignPtr</a>, an offset and it's size into a
--   mutable storable array. It is still safe to modify the pointer, unless
--   the array gets frozen prior to modification.
unsafeMArrayFromForeignPtr :: Storable e => ForeignPtr e -> Int -> Sz1 -> MArray s S Ix1 e

-- | <i>O(1)</i> - Wrap a <a>ForeignPtr</a> and it's size into a mutable
--   storable array. It is still safe to modify the pointer, unless the
--   array gets frozen prior to modification.
unsafeMArrayFromForeignPtr0 :: Storable e => ForeignPtr e -> Sz1 -> MArray s S Ix1 e

-- | Atomically read an <a>Int</a> element from the array
unsafeAtomicReadIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> m Int

-- | Atomically write an <a>Int</a> element int the array
unsafeAtomicWriteIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m ()

-- | Atomically modify an <a>Int</a> element of the array. Returns the old
--   value.
unsafeAtomicModifyIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> (Int -> Int) -> m Int

-- | Atomically add to an <a>Int</a> element in the array. Returns the old
--   value.
unsafeAtomicAddIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically subtract from an <a>Int</a> element in the array. Returns
--   the old value.
unsafeAtomicSubIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically AND an <a>Int</a> element in the array. Returns the old
--   value.
unsafeAtomicAndIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically NAND an <a>Int</a> element in the array. Returns the old
--   value.
unsafeAtomicNandIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically OR an <a>Int</a> element in the array. Returns the old
--   value.
unsafeAtomicOrIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically XOR an <a>Int</a> element in the array. Returns the old
--   value.
unsafeAtomicXorIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically CAS an <a>Int</a> in the array. Returns the old value.
unsafeCasIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> Int -> m Int

-- | <i>O(1)</i> - Cast a boxed lazy array. It is unsafe because it can
--   violate the invariant that all elements of <a>B</a> array are in WHNF.
coerceBoxedArray :: Array BL ix e -> Array B ix e

-- | <i>O(1)</i> - Cast a boxed lazy array. It is unsafe because it can
--   violate the invariant that all elements of <a>N</a> array are in NF.
coerceNormalBoxedArray :: Array BL ix e -> Array N ix e

-- | Partition a segment of a vector. Starting and ending indices are
--   unchecked.
unsafeUnstablePartitionRegionM :: forall r e m. (Mutable r Ix1 e, PrimMonad m) => MVector (PrimState m) r e -> (e -> Bool) -> Ix1 -> Ix1 -> m Ix1

unsafeHead :: Source r Ix1 e => Vector r e -> e

unsafeLast :: Source r Ix1 e => Vector r e -> e

unsafeIndexM :: (Source r Ix1 e, Monad m) => Vector r e -> Ix1 -> m e

unsafeHeadM :: Monad m => Source r Ix1 e => Vector r e -> m e

unsafeLastM :: Monad m => Source r Ix1 e => Vector r e -> m e

unsafeInit :: Source r Ix1 e => Vector r e -> Vector r e

unsafeTail :: Source r Ix1 e => Vector r e -> Vector r e

unsafeTake :: Source r Ix1 e => Sz1 -> Vector r e -> Vector r e

unsafeDrop :: Source r Ix1 e => Sz1 -> Vector r e -> Vector r e

-- | <i>O(n)</i> - Right unfolding function with at most <tt>n</tt> number
--   of elements.
--   
--   <i>Unsafe</i> - This function is unsafe because it will allocate
--   enough space in memory for <tt>n</tt> elements ahead of time,
--   regardless of when unfolding function returns a <a>Nothing</a>.
--   Supplying <tt>n</tt> that is too big will result in an asynchronous
--   <a>HeapOverflow</a> exception.
unsafeUnfoldrN :: Sz1 -> (s -> Maybe (e, s)) -> s -> Vector DS e

-- | <i>O(n)</i> - Same as <a>unsafeUnfoldrN</a>, but with monadic
--   generating function.
--   
--   <i>Unsafe</i> - This function is unsafe because it will allocate
--   enough space in memory for <tt>n</tt> elements ahead of time,
--   regardless of when unfolding function returns a <a>Nothing</a>.
--   Supplying <tt>n</tt> that is too big will result in an asynchronous
--   <a>HeapOverflow</a> exception.
unsafeUnfoldrNM :: Monad m => Sz1 -> (s -> m (Maybe (e, s))) -> s -> m (Vector DS e)

-- | <i>O(n)</i> - Convert a list of a known length to a delayed stream
--   vector.
--   
--   <i>Unsafe</i> - This function is unsafe because it will allocate
--   enough space in memory for <tt>n</tt> elements ahead of time,
--   regardless of the actual size of the list. Supplying <tt>n</tt> that
--   is too big will result in an asynchronous <a>HeapOverflow</a>
--   exception.
unsafeFromListN :: Sz1 -> [e] -> Vector DS e

-- | Similar to <a>makeStencil</a>, but there are no guarantees that the
--   stencil will not read out of bounds memory. This stencil is also a bit
--   more powerful in sense it gets an extra peice of information, namely
--   the exact index for the element it is constructing.
makeUnsafeStencil :: Index ix => Sz ix -> ix -> (ix -> (ix -> e) -> a) -> Stencil ix e a

-- | Same as <a>makeConvolutionStencil</a>, but will result in reading
--   memory out of bounds and potential segfaults if supplied arguments are
--   not valid.
makeUnsafeConvolutionStencil :: (Index ix, Num e) => Sz ix -> ix -> ((ix -> e -> e -> e) -> e -> e) -> Stencil ix e e

-- | Same as <a>makeCorrelationStencil</a>, but will result in reading
--   memory out of bounds and potential segfaults if supplied arguments are
--   not valid.
makeUnsafeCorrelationStencil :: (Index ix, Num e) => Sz ix -> ix -> ((ix -> e -> e -> e) -> e -> e) -> Stencil ix e e

-- | Perform an arbitrary transformation of a stencil. This stencil
--   modifier can be used for example to turn a vector stencil into a
--   matrix stencil implement, or transpose a matrix stencil. It is really
--   easy to get this wrong, so be extremely careful.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert a 1D stencil into a row or column 2D stencil:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import Data.Massiv.Array.Unsafe
--   
--   &gt;&gt;&gt; let arr = compute $ iterateN 3 succ 0 :: Array P Ix2 Int
--   
--   &gt;&gt;&gt; arr
--   Array P Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; let rowStencil = unsafeTransformStencil (\(Sz n) -&gt; Sz (1 :. n)) (0 :.) $ \ f uget getVal (i :. j) -&gt; f (uget  . (i :.)) (getVal . (i :.)) j
--   
--   &gt;&gt;&gt; applyStencil noPadding (rowStencil (sumStencil (Sz1 3))) arr
--   Array DW Seq (Sz (3 :. 1))
--     [ [ 6 ]
--     , [ 15 ]
--     , [ 24 ]
--     ]
--   
--   &gt;&gt;&gt; let columnStencil = unsafeTransformStencil (\(Sz n) -&gt; Sz (n :. 1)) (:. 0) $ \ f uget getVal (i :. j) -&gt; f (uget . (:. j)) (getVal . (:. j)) i
--   
--   &gt;&gt;&gt; applyStencil noPadding (columnStencil (sumStencil (Sz1 3))) arr
--   Array DW Seq (Sz (1 :. 3))
--     [ [ 12, 15, 18 ]
--     ]
--   </pre>
unsafeTransformStencil :: (Sz ix' -> Sz ix) -> (ix' -> ix) -> (((ix' -> e) -> (ix' -> e) -> ix' -> a) -> (ix -> e) -> (ix -> e) -> ix -> a) -> Stencil ix' e a -> Stencil ix e a

-- | This is an unsafe version of <a>mapStencil</a>, which does not take a
--   <a>Stencil</a>, but instead accepts all necessary information as
--   separate arguments.

-- | <i>Deprecated: In favor of <a>mapStencil</a> that is applied to
--   stencil created with <a>makeUnsafeStencil</a></i>
unsafeMapStencil :: Manifest r ix e => Border e -> Sz ix -> ix -> (ix -> (ix -> e) -> a) -> Array r ix e -> Array DW ix a


module Data.Massiv.Array.Numeric.Integral

-- | Use midpoint rule to approximate an integral.
midpointRule :: (Fractional e, StrideLoad DW ix e, Mutable r ix e) => Comp -> r -> ((Int -> e) -> ix -> e) -> e -> e -> Sz ix -> Int -> Array M ix e

-- | <b>Midpoint Rule</b>
--   
--   &lt;math&gt;
midpointStencil :: (Fractional e, Index ix) => e -> Dim -> Int -> Stencil ix e e

-- | Use trapezoid rule to approximate an integral.
trapezoidRule :: (Fractional e, StrideLoad DW ix e, Mutable r ix e) => Comp -> r -> ((Int -> e) -> ix -> e) -> e -> e -> Sz ix -> Int -> Array M ix e

-- | <b>Trapezoid Rule</b>
--   
--   &lt;math&gt;
trapezoidStencil :: (Fractional e, Index ix) => e -> Dim -> Int -> Stencil ix e e

-- | Use Simpson's rule to approximate an integral.
simpsonsRule :: (Fractional e, StrideLoad DW ix e, Mutable r ix e) => Comp -> r -> ((Int -> e) -> ix -> e) -> e -> e -> Sz ix -> Int -> Array M ix e

-- | <b>Simpson's Rule</b>
--   
--   &lt;math&gt;
simpsonsStencil :: (Fractional e, Index ix) => e -> Dim -> Int -> Stencil ix e e

-- | Integrate with a stencil along a particular dimension.
integrateWith :: (Fractional e, StrideLoad DW ix e, Mutable r ix e) => (Dim -> Int -> Stencil ix e e) -> Dim -> Int -> Array r ix e -> Array r ix e

-- | Compute an approximation of integral using a supplied rule in a form
--   of <a>Stencil</a>.
integralApprox :: (Fractional e, StrideLoad DW ix e, Mutable r ix e) => (e -> Dim -> Int -> Stencil ix e e) -> e -> Sz ix -> Int -> Array r ix e -> Array M ix e

-- | Create an array from a function with sample points at the edges
--   
--   <pre>
--   &gt;&gt;&gt; fromFunction Seq (\ scale (i :. j) -&gt; scale i + scale j :: Double) (-2) 1 (Sz 4) 2
--   Array D Seq (Sz (9 :. 9))
--     [ [ -4.0, -3.5, -3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0 ]
--     , [ -3.5, -3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5 ]
--     , [ -3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0 ]
--     , [ -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5 ]
--     , [ -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0 ]
--     , [ -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5 ]
--     , [ -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 ]
--     , [ -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5 ]
--     , [ 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0 ]
--     ]
--   </pre>
fromFunction :: (Index ix, Fractional a) => Comp -> ((Int -> a) -> ix -> e) -> a -> a -> Sz ix -> Int -> Array D ix e

-- | Similar to <a>fromFunction</a>, but will create an array from a
--   function with sample points in the middle of cells.
--   
--   <pre>
--   &gt;&gt;&gt; fromFunctionMidpoint Seq (\ scale (i :. j) -&gt; scale i + scale j :: Double) (-2) 1 (Sz 4) 2
--   Array D Seq (Sz (8 :. 8))
--     [ [ -3.5, -3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0 ]
--     , [ -3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5 ]
--     , [ -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0 ]
--     , [ -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5 ]
--     , [ -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0 ]
--     , [ -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5 ]
--     , [ -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 ]
--     , [ 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5 ]
--     ]
--   </pre>
fromFunctionMidpoint :: (Index ix, Fractional a) => Comp -> ((Int -> a) -> ix -> e) -> a -> a -> Sz ix -> Int -> Array D ix e
