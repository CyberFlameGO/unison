-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-codebase-sqlite
@version 0.0.0

module U.Codebase.Sqlite.Connection
data Connection
Connection :: String -> FilePath -> Connection -> Connection
[name] :: Connection -> String
[file] :: Connection -> FilePath
[underlying] :: Connection -> Connection
showFile :: Bool
showHandle :: Bool
instance GHC.Show.Show U.Codebase.Sqlite.Connection.Connection

module U.Codebase.Sqlite.DbId
newtype ObjectId
ObjectId :: Word64 -> ObjectId
newtype TextId
TextId :: Word64 -> TextId
newtype HashId
HashId :: Word64 -> HashId
newtype PatchObjectId
PatchObjectId :: ObjectId -> PatchObjectId
[unPatchObjectId] :: PatchObjectId -> ObjectId
newtype BranchObjectId
BranchObjectId :: ObjectId -> BranchObjectId
[unBranchObjectId] :: BranchObjectId -> ObjectId
newtype BranchHashId
BranchHashId :: HashId -> BranchHashId
[unBranchHashId] :: BranchHashId -> HashId
newtype CausalHashId
CausalHashId :: HashId -> CausalHashId
[unCausalHashId] :: CausalHashId -> HashId
newtype SchemaVersion
SchemaVersion :: Word64 -> SchemaVersion
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.ObjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.ObjectId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.ObjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.TextId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.TextId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.TextId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.TextId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.TextId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.TextId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.TextId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.TextId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.TextId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.TextId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.HashId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.HashId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.HashId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.HashId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.HashId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.HashId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.HashId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.HashId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.HashId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.HashId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.PatchObjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.PatchObjectId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.PatchObjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.BranchObjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.BranchObjectId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.BranchObjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.BranchHashId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.BranchHashId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.BranchHashId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.CausalHashId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.CausalHashId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.CausalHashId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.SchemaVersion
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.SchemaVersion
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Real.Real U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Num.Num U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Show.Show U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Show.Show U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.PatchObjectId

module U.Codebase.Sqlite.JournalMode
data JournalMode
DELETE :: JournalMode
TRUNCATE :: JournalMode
PERSIST :: JournalMode
MEMORY :: JournalMode
WAL :: JournalMode
OFF :: JournalMode
instance GHC.Show.Show U.Codebase.Sqlite.JournalMode.JournalMode

module U.Codebase.Sqlite.LocalIds

-- | A mapping between index ids that are local to an object and the ids in
--   the database
data LocalIds' t h
LocalIds :: Vector t -> Vector h -> LocalIds' t h
[textLookup] :: LocalIds' t h -> Vector t
[defnLookup] :: LocalIds' t h -> Vector h
type LocalIds = LocalIds' TextId ObjectId
type WatchLocalIds = LocalIds' TextId HashId

-- | represents an index into a textLookup
newtype LocalTextId
LocalTextId :: Word64 -> LocalTextId

-- | represents an index into a defnLookup
newtype LocalDefnId
LocalDefnId :: Word64 -> LocalDefnId

-- | a local index to a hash, used when the corresponding object is allowed
--   to be absent
newtype LocalHashId
LocalHashId :: Word64 -> LocalHashId
newtype LocalPatchObjectId
LocalPatchObjectId :: Word64 -> LocalPatchObjectId
newtype LocalBranchChildId
LocalBranchChildId :: Word64 -> LocalBranchChildId

-- | causal hashes are treated differently from HashIds, which don't have
--   dependencies
newtype LocalCausalHashId
LocalCausalHashId :: Word64 -> LocalCausalHashId
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.LocalIds.LocalIds' t h)
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalTextId
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalDefnId
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalHashId
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance Data.Bitraversable.Bitraversable U.Codebase.Sqlite.LocalIds.LocalIds'
instance Data.Bifoldable.Bifoldable U.Codebase.Sqlite.LocalIds.LocalIds'
instance Data.Bifunctor.Bifunctor U.Codebase.Sqlite.LocalIds.LocalIds'

module U.Codebase.Sqlite.Branch.Full
type LocalBranch = Branch' LocalTextId LocalDefnId LocalPatchObjectId LocalBranchChildId
type DbBranch = Branch' TextId ObjectId PatchObjectId (BranchObjectId, CausalHashId)
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)
data Branch' t h p c
Branch :: Map t (Map (Referent'' t h) (MetadataSetFormat' t h)) -> Map t (Map (Reference' t h) (MetadataSetFormat' t h)) -> Map t p -> Map t c -> Branch' t h p c
[terms] :: Branch' t h p c -> Map t (Map (Referent'' t h) (MetadataSetFormat' t h))
[types] :: Branch' t h p c -> Map t (Map (Reference' t h) (MetadataSetFormat' t h))
[patches] :: Branch' t h p c -> Map t p
[children] :: Branch' t h p c -> Map t c
type LocalMetadataSet = MetadataSetFormat' LocalTextId LocalDefnId
type DbMetadataSet = MetadataSetFormat' TextId ObjectId
data MetadataSetFormat' t h
Inline :: Set (Reference' t h) -> MetadataSetFormat' t h
quadmap :: forall t h p c t' h' p' c'. (Ord t', Ord h') => (t -> t') -> (h -> h') -> (p -> p') -> (c -> c') -> Branch' t h p c -> Branch' t' h' p' c'
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Full.MetadataSetFormat' t h)
instance (GHC.Show.Show t, GHC.Show.Show h, GHC.Show.Show p, GHC.Show.Show c) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Full.Branch' t h p c)

module U.Codebase.Sqlite.Branch.Diff
type LocalDiff = Diff' LocalTextId LocalDefnId LocalPatchObjectId LocalBranchChildId
type Diff = Diff' TextId ObjectId PatchObjectId (BranchObjectId, CausalHashId)
data DefinitionOp' r
RemoveDef :: DefinitionOp' r
AddDefWithMetadata :: Set r -> DefinitionOp' r
AlterDefMetadata :: AddRemove r -> DefinitionOp' r
data PatchOp' p
PatchRemove :: PatchOp' p
PatchAddReplace :: p -> PatchOp' p
data ChildOp' c
ChildRemove :: ChildOp' c
ChildAddReplace :: c -> ChildOp' c
type AddRemove a = Map a Bool
type LocalDefinitionOp = DefinitionOp' (Metadata LocalTextId LocalDefnId)
type LocalPatchOp = PatchOp' LocalPatchObjectId
type LocalChildOp = ChildOp' LocalBranchChildId
type DefinitionOp = DefinitionOp' (Metadata TextId ObjectId)
type PatchOp = PatchOp' PatchObjectId
type ChildOp = ChildOp' (BranchObjectId, CausalHashId)
addsRemoves :: AddRemove a -> ([a], [a])
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)
data Diff' t h p c
Diff :: Map t (Map (Referent'' t h) (DefinitionOp' (Metadata t h))) -> Map t (Map (Reference' t h) (DefinitionOp' (Metadata t h))) -> Map t (PatchOp' p) -> Map t (ChildOp' c) -> Diff' t h p c
[terms] :: Diff' t h p c -> Map t (Map (Referent'' t h) (DefinitionOp' (Metadata t h)))
[types] :: Diff' t h p c -> Map t (Map (Reference' t h) (DefinitionOp' (Metadata t h)))
[patches] :: Diff' t h p c -> Map t (PatchOp' p)
[children] :: Diff' t h p c -> Map t (ChildOp' c)
type Metadata t h = Reference' t h
quadmap :: (Ord t', Ord h') => (t -> t') -> (h -> h') -> (p -> p') -> (c -> c') -> Diff' t h p c -> Diff' t' h' p' c'
instance GHC.Show.Show p => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.PatchOp' p)
instance GHC.Base.Functor U.Codebase.Sqlite.Branch.Diff.PatchOp'
instance GHC.Show.Show c => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.ChildOp' c)
instance GHC.Base.Functor U.Codebase.Sqlite.Branch.Diff.ChildOp'
instance GHC.Show.Show r => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.DefinitionOp' r)
instance (GHC.Show.Show t, GHC.Show.Show h, GHC.Show.Show p, GHC.Show.Show c) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.Diff' t h p c)

module U.Codebase.Sqlite.Branch.Format

-- | you can use the exact same <a>BranchLocalIds</a> when converting
--   between <a>Full</a> and <a>Diff</a>
data BranchFormat
Full :: BranchLocalIds -> LocalBranch -> BranchFormat
Diff :: BranchObjectId -> BranchLocalIds -> LocalDiff -> BranchFormat
data BranchLocalIds
LocalIds :: Vector TextId -> Vector ObjectId -> Vector PatchObjectId -> Vector (BranchObjectId, CausalHashId) -> BranchLocalIds
[branchTextLookup] :: BranchLocalIds -> Vector TextId
[branchDefnLookup] :: BranchLocalIds -> Vector ObjectId
[branchPatchLookup] :: BranchLocalIds -> Vector PatchObjectId
[branchChildLookup] :: BranchLocalIds -> Vector (BranchObjectId, CausalHashId)
data SyncBranchFormat
SyncFull :: BranchLocalIds -> ByteString -> SyncBranchFormat
SyncDiff :: BranchObjectId -> BranchLocalIds -> ByteString -> SyncBranchFormat
instance GHC.Show.Show U.Codebase.Sqlite.Branch.Format.BranchLocalIds
instance GHC.Show.Show U.Codebase.Sqlite.Branch.Format.BranchFormat

module U.Codebase.Sqlite.ObjectType

-- | Don't reorder these, they are part of the database, and the ToField
--   and FromField implementation currently depends on the derived Enum
--   implementation.
data ObjectType
TermComponent :: ObjectType
DeclComponent :: ObjectType
Namespace :: ObjectType
Patch :: ObjectType
instance GHC.Enum.Enum U.Codebase.Sqlite.ObjectType.ObjectType
instance GHC.Show.Show U.Codebase.Sqlite.ObjectType.ObjectType
instance GHC.Classes.Ord U.Codebase.Sqlite.ObjectType.ObjectType
instance GHC.Classes.Eq U.Codebase.Sqlite.ObjectType.ObjectType
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.ObjectType.ObjectType
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.ObjectType.ObjectType

module U.Codebase.Sqlite.Patch.TermEdit
type TermEdit = TermEdit' TextId ObjectId
type LocalTermEdit = TermEdit' LocalTextId LocalDefnId
type Referent' t h = Referent' (Reference' t h) (Reference' t h)
data TermEdit' t h
Replace :: Referent' t h -> Typing -> TermEdit' t h
Deprecate :: TermEdit' t h
data Typing
Same :: Typing
Subtype :: Typing
Different :: Typing
instance GHC.Show.Show U.Codebase.Sqlite.Patch.TermEdit.Typing
instance GHC.Classes.Ord U.Codebase.Sqlite.Patch.TermEdit.Typing
instance GHC.Classes.Eq U.Codebase.Sqlite.Patch.TermEdit.Typing
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.Patch.TermEdit.TermEdit' t h)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h) => GHC.Classes.Ord (U.Codebase.Sqlite.Patch.TermEdit.TermEdit' t h)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h) => GHC.Classes.Eq (U.Codebase.Sqlite.Patch.TermEdit.TermEdit' t h)
instance Data.Bifunctor.Bifunctor U.Codebase.Sqlite.Patch.TermEdit.TermEdit'
instance Data.Bifoldable.Bifoldable U.Codebase.Sqlite.Patch.TermEdit.TermEdit'
instance Data.Bitraversable.Bitraversable U.Codebase.Sqlite.Patch.TermEdit.TermEdit'

module U.Codebase.Sqlite.Patch.TypeEdit
type LocalTypeEdit = TypeEdit' LocalTextId LocalDefnId
type TypeEdit = TypeEdit' TextId ObjectId
data TypeEdit' t h
Replace :: Reference' t h -> TypeEdit' t h
Deprecate :: TypeEdit' t h
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit' t h)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h) => GHC.Classes.Ord (U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit' t h)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h) => GHC.Classes.Eq (U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit' t h)
instance Data.Bifunctor.Bifunctor U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit'
instance Data.Bifoldable.Bifoldable U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit'
instance Data.Bitraversable.Bitraversable U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit'

module U.Codebase.Sqlite.Patch.Full
type Patch = Patch' TextId HashId ObjectId
type LocalPatch = Patch' LocalTextId LocalHashId LocalDefnId
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)
data Patch' t h o
Patch :: Map (Referent'' t h) (Set (TermEdit' t o)) -> Map (Reference' t h) (Set (TypeEdit' t o)) -> Patch' t h o
[termEdits] :: Patch' t h o -> Map (Referent'' t h) (Set (TermEdit' t o))
[typeEdits] :: Patch' t h o -> Map (Reference' t h) (Set (TypeEdit' t o))
trimap :: (Ord t', Ord h', Ord o') => (t -> t') -> (h -> h') -> (o -> o') -> Patch' t h o -> Patch' t' h' o'

module U.Codebase.Sqlite.Patch.Diff
type PatchDiff = PatchDiff' TextId HashId ObjectId
type LocalPatchDiff = PatchDiff' LocalTextId LocalHashId LocalDefnId
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)

-- | diff. = min. - sub.
data PatchDiff' t h d
PatchDiff :: Map (Referent'' t h) (Set (TermEdit' t d)) -> Map (Reference' t h) (Set (TypeEdit' t d)) -> Map (Referent'' t h) (Set (TermEdit' t d)) -> Map (Reference' t h) (Set (TypeEdit' t d)) -> PatchDiff' t h d

-- | elements present in min. but absent in sub.
[addedTermEdits] :: PatchDiff' t h d -> Map (Referent'' t h) (Set (TermEdit' t d))
[addedTypeEdits] :: PatchDiff' t h d -> Map (Reference' t h) (Set (TypeEdit' t d))

-- | elements missing in min. but present in sub.
[removedTermEdits] :: PatchDiff' t h d -> Map (Referent'' t h) (Set (TermEdit' t d))
[removedTypeEdits] :: PatchDiff' t h d -> Map (Reference' t h) (Set (TypeEdit' t d))
trimap :: (Ord t', Ord h', Ord d') => (t -> t') -> (h -> h') -> (d -> d') -> PatchDiff' t h d -> PatchDiff' t' h' d'
instance (GHC.Show.Show t, GHC.Show.Show h, GHC.Show.Show d) => GHC.Show.Show (U.Codebase.Sqlite.Patch.Diff.PatchDiff' t h d)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h, GHC.Classes.Ord d) => GHC.Classes.Ord (U.Codebase.Sqlite.Patch.Diff.PatchDiff' t h d)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h, GHC.Classes.Eq d) => GHC.Classes.Eq (U.Codebase.Sqlite.Patch.Diff.PatchDiff' t h d)

module U.Codebase.Sqlite.Patch.Format
data PatchFormat
Full :: PatchLocalIds -> LocalPatch -> PatchFormat
Diff :: PatchObjectId -> PatchLocalIds -> LocalPatchDiff -> PatchFormat
data PatchLocalIds
LocalIds :: Vector TextId -> Vector HashId -> Vector ObjectId -> PatchLocalIds
[patchTextLookup] :: PatchLocalIds -> Vector TextId
[patchHashLookup] :: PatchLocalIds -> Vector HashId
[patchDefnLookup] :: PatchLocalIds -> Vector ObjectId
data SyncPatchFormat
SyncFull :: PatchLocalIds -> ByteString -> SyncPatchFormat
SyncDiff :: PatchObjectId -> PatchLocalIds -> ByteString -> SyncPatchFormat

module U.Codebase.Sqlite.Reference
type Reference = Reference' TextId ObjectId
type Id = Id' ObjectId
type LocalReferenceH = Reference' LocalTextId LocalHashId
type LocalReference = Reference' LocalTextId LocalDefnId
type LocalId = Id' LocalDefnId
type ReferenceH = Reference' TextId HashId
type IdH = Id' HashId
referenceFromRow' :: (FromField t, FromField h, Show t, Show h) => RowParser (Reference' t h)
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Reference' U.Codebase.Sqlite.DbId.TextId U.Codebase.Sqlite.DbId.HashId)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Reference' U.Codebase.Sqlite.DbId.TextId U.Codebase.Sqlite.DbId.HashId)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Reference' U.Codebase.Sqlite.DbId.TextId U.Codebase.Sqlite.DbId.ObjectId)
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Reference' U.Codebase.Sqlite.DbId.TextId U.Codebase.Sqlite.DbId.ObjectId)
instance Database.SQLite.Simple.ToField.ToField h => Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Id' h)
instance Database.SQLite.Simple.FromField.FromField h => Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Id' h)

module U.Codebase.Sqlite.Referent
type Referent = Referent' Reference Reference
type ReferentH = Referent' ReferenceH ReferenceH
type Id = Id' ObjectId ObjectId
type LocalReferent = Referent' LocalReference LocalReference
type LocalReferentH = Referent' LocalReferenceH LocalReferenceH
instance Database.SQLite.Simple.ToRow.ToRow U.Codebase.Sqlite.Referent.Id
instance Database.SQLite.Simple.FromRow.FromRow U.Codebase.Sqlite.Referent.Id

module U.Codebase.Sqlite.Queries
type DB m = (MonadIO m, MonadReader Connection m)
type EDB m = (DB m, Err m)
type Err m = (MonadError Integrity m, HasCallStack)
debugQuery :: Bool
debugThread :: Bool
debugConnection :: Bool
alwaysTraceOnCrash :: Bool
crashOnError :: Bool
throwError :: Err m => Integrity -> m c
data Integrity
UnknownHashId :: HashId -> Integrity
UnknownTextId :: TextId -> Integrity
UnknownObjectId :: ObjectId -> Integrity
UnknownCausalHashId :: CausalHashId -> Integrity
UnknownHash :: Hash -> Integrity
NoObjectForHashId :: HashId -> Integrity
NoObjectForPrimaryHashId :: HashId -> Integrity
NoNamespaceRoot :: Integrity
MultipleNamespaceRoots :: [CausalHashId] -> Integrity
NoSchemaVersion :: Integrity
MultipleSchemaVersions :: [SchemaVersion] -> Integrity
NoTypeIndexForTerm :: Id -> Integrity
orError :: Err m => Integrity -> Maybe b -> m b
type TypeHashReference = Reference' TextId HashId
createSchema :: (DB m, MonadUnliftIO m) => m ()
setJournalMode :: DB m => JournalMode -> m ()
setFlags :: DB m => m ()
schemaVersion :: DB m => m SchemaVersion
saveHash :: DB m => Base32Hex -> m HashId
saveHashHash :: DB m => Hash -> m HashId
loadHashId :: DB m => Base32Hex -> m (Maybe HashId)
loadHashIdByHash :: DB m => Hash -> m (Maybe HashId)
saveCausalHash :: DB m => CausalHash -> m CausalHashId
saveBranchHash :: DB m => BranchHash -> m BranchHashId
loadCausalHashIdByCausalHash :: DB m => CausalHash -> m (Maybe CausalHashId)
loadCausalByCausalHash :: DB m => CausalHash -> m (Maybe (CausalHashId, BranchHashId))
expectHashIdByHash :: EDB m => Hash -> m HashId
loadHashHashById :: EDB m => HashId -> m Hash
loadHashById :: EDB m => HashId -> m Base32Hex
saveText :: DB m => Text -> m TextId
loadText :: DB m => Text -> m (Maybe TextId)
loadTextById :: EDB m => TextId -> m Text
saveHashObject :: DB m => HashId -> ObjectId -> Int -> m ()
saveObject :: DB m => HashId -> ObjectType -> ByteString -> m ObjectId
loadObjectById :: EDB m => ObjectId -> m ByteString
loadObjectWithTypeById :: EDB m => ObjectId -> m (ObjectType, ByteString)
loadObjectWithHashIdAndTypeById :: EDB m => ObjectId -> m (HashId, ObjectType, ByteString)

-- | Not all hashes have corresponding objects; e.g., hashes of term types
expectObjectIdForPrimaryHashId :: EDB m => HashId -> m ObjectId
maybeObjectIdForPrimaryHashId :: DB m => HashId -> m (Maybe ObjectId)
expectObjectIdForAnyHashId :: EDB m => HashId -> m ObjectId
maybeObjectIdForAnyHashId :: DB m => HashId -> m (Maybe ObjectId)

-- | All objects have corresponding hashes.
loadPrimaryHashByObjectId :: EDB m => ObjectId -> m Base32Hex
hashIdsForObject :: DB m => ObjectId -> m (NonEmpty HashId)
hashIdWithVersionForObject :: DB m => ObjectId -> m [(HashId, Int)]
updateObjectBlob :: DB m => ObjectId -> ByteString -> m ()

-- | Maybe we would generalize this to something other than NamespaceHash
--   if we end up wanting to store other kinds of Causals here too.
saveCausal :: DB m => CausalHashId -> BranchHashId -> m ()

-- | ]
loadCausalValueHashId :: EDB m => CausalHashId -> m BranchHashId
loadCausalHash :: EDB m => CausalHashId -> m CausalHash
loadMaybeCausalValueHashId :: DB m => HashId -> m (Maybe BranchHashId)
isCausalHash :: DB m => HashId -> m Bool
loadBranchObjectIdByCausalHashId :: EDB m => CausalHashId -> m (Maybe BranchObjectId)
saveCausalParents :: DB m => CausalHashId -> [CausalHashId] -> m ()
loadCausalParents :: DB m => CausalHashId -> m [CausalHashId]
newtype DataVersion
DataVersion :: Int -> DataVersion
dataVersion :: DB m => m DataVersion
loadNamespaceRoot :: EDB m => m CausalHashId
loadMaybeNamespaceRoot :: EDB m => m (Maybe CausalHashId)
setNamespaceRoot :: forall m. DB m => CausalHashId -> m ()
saveWatch :: DB m => WatchKind -> IdH -> ByteString -> m ()
loadWatch :: DB m => WatchKind -> IdH -> m (Maybe ByteString)
loadWatchKindsByReference :: DB m => IdH -> m [WatchKind]
loadWatchesByWatchKind :: DB m => WatchKind -> m [IdH]
clearWatches :: DB m => m ()
addToTypeIndex :: DB m => Reference' TextId HashId -> Id -> m ()
getReferentsByType :: DB m => Reference' TextId HashId -> m [Id]
getTypeReferenceForReferent :: EDB m => Id -> m (Reference' TextId HashId)
getTypeReferencesForComponent :: EDB m => ObjectId -> m [(Reference' TextId HashId, Id)]
addToTypeMentionsIndex :: DB m => Reference' TextId HashId -> Id -> m ()
getReferentsByTypeMention :: DB m => Reference' TextId HashId -> m [Id]
getTypeMentionsReferencesForComponent :: EDB m => ObjectId -> m [(Reference' TextId HashId, Id)]
fixupTypeIndexRow :: (Reference' TextId HashId :. Id) -> (Reference' TextId HashId, Id)
addToDependentsIndex :: DB m => Reference -> Id -> m ()
getDependentsForDependency :: DB m => Reference -> m [Id]
getDependenciesForDependent :: DB m => Id -> m [Reference]
getDependencyIdsForDependent :: DB m => Id -> m [Id]
objectIdByBase32Prefix :: DB m => ObjectType -> Text -> m [ObjectId]
causalHashIdByBase32Prefix :: DB m => Text -> m [CausalHashId]
namespaceHashIdByBase32Prefix :: DB m => Text -> m [BranchHashId]
before :: DB m => CausalHashId -> CausalHashId -> m Bool
lca :: CausalHashId -> CausalHashId -> Connection -> Connection -> IO (Maybe CausalHashId)
ancestorSql :: String

-- | composite input, atomic List output
queryAtoms :: (DB f, ToRow q, FromField b, Show q, Show b) => Query -> q -> f [b]

-- | no input, atomic List output
queryAtoms_ :: (DB f, FromField b, Show b) => Query -> f [b]

-- | composite input, composite Maybe output
queryMaybe :: (DB f, ToRow q, FromRow b, Show q, Show b) => Query -> q -> f (Maybe b)

-- | composite input, atomic Maybe output
queryAtom :: (DB f, ToRow q, FromField b, Show q, Show b) => Query -> q -> f (Maybe b)

-- | Just output
queryOne :: Functor f => f (Maybe b) -> f b

-- | composite input, composite List output
query :: (DB m, ToRow q, FromRow r, Show q, Show r) => Query -> q -> m [r]

-- | no input, composite List output
query_ :: (DB m, FromRow r, Show r) => Query -> m [r]
debugHeader :: DB m => m String
queryTrace :: (MonadUnliftIO m, Show q, Show a) => String -> Query -> q -> m a -> m a
queryTrace_ :: (MonadUnliftIO m, Show a) => String -> Query -> m a -> m a
traceConnectionFile :: DB m => m ()
execute :: (DB m, ToRow q, Show q) => Query -> q -> m ()
execute_ :: DB m => Query -> m ()
executeMany :: (DB m, ToRow q, Show q) => Query -> [q] -> m ()

-- | transaction that blocks
withImmediateTransaction :: (DB m, MonadUnliftIO m) => m a -> m a

-- | low-level transaction stuff
savepoint :: DB m => String -> m ()

-- | low-level transaction stuff
release :: DB m => String -> m ()

-- | low-level transaction stuff
rollbackTo :: DB m => String -> m ()

-- | low-level transaction stuff
rollbackRelease :: DB m => String -> m ()
instance GHC.Show.Show U.Codebase.Sqlite.Queries.Integrity
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.Queries.DataVersion
instance GHC.Show.Show U.Codebase.Sqlite.Queries.DataVersion
instance GHC.Classes.Ord U.Codebase.Sqlite.Queries.DataVersion
instance GHC.Classes.Eq U.Codebase.Sqlite.Queries.DataVersion
instance Database.SQLite.Simple.ToField.ToField U.Util.Base32Hex.Base32Hex
instance Database.SQLite.Simple.FromField.FromField U.Util.Base32Hex.Base32Hex
instance Database.SQLite.Simple.ToField.ToField U.Codebase.WatchKind.WatchKind
instance Database.SQLite.Simple.FromField.FromField U.Codebase.WatchKind.WatchKind

module U.Codebase.Sqlite.Symbol
data Symbol
Symbol :: !Word64 -> !Text -> Symbol
instance GHC.Show.Show U.Codebase.Sqlite.Symbol.Symbol
instance GHC.Classes.Ord U.Codebase.Sqlite.Symbol.Symbol
instance GHC.Classes.Eq U.Codebase.Sqlite.Symbol.Symbol
instance U.Core.ABT.Var.Var U.Codebase.Sqlite.Symbol.Symbol

module U.Codebase.Sqlite.Decl.Format

-- | Add new formats here
data DeclFormat
Decl :: LocallyIndexedComponent -> DeclFormat

-- | V1: Decls included <tt>Hash</tt>es inline V2: Instead of
--   <tt>Hash</tt>, we use a smaller index.
data LocallyIndexedComponent
LocallyIndexedComponent :: Vector (LocalIds, Decl Symbol) -> LocallyIndexedComponent
type Decl v = DeclR TypeRef v
type Type v = Term F v ()
type F = F' TypeRef
type TypeRef = Reference' LocalTextId (Maybe LocalDefnId)
instance GHC.Show.Show U.Codebase.Sqlite.Decl.Format.LocallyIndexedComponent
instance GHC.Show.Show U.Codebase.Sqlite.Decl.Format.DeclFormat

module U.Codebase.Sqlite.Term.Format
type TermRef = Reference' LocalTextId (Maybe LocalDefnId)
type TypeRef = Reference' LocalTextId LocalDefnId
type TermLink = Referent' TermRef TypeRef
type TypeLink = TypeRef
type LocallyIndexedComponent = LocallyIndexedComponent' TextId ObjectId
newtype LocallyIndexedComponent' t d
LocallyIndexedComponent :: Vector (LocalIds' t d, Term, Type) -> LocallyIndexedComponent' t d
type F = F' LocalTextId TermRef TypeRef TermLink TypeLink Symbol
type FT = F' TypeRef
type Term = Term F Symbol ()
type Type = Term FT Symbol ()
type FTT = F' Reference
type TypeOfTerm = Term FTT Symbol ()
data TermFormat
Term :: LocallyIndexedComponent -> TermFormat
data WatchResultFormat
WatchResult :: WatchLocalIds -> Term -> WatchResultFormat
data SyncWatchResultFormat
SyncWatchResult :: WatchLocalIds -> ByteString -> SyncWatchResultFormat
instance (GHC.Show.Show t, GHC.Show.Show d) => GHC.Show.Show (U.Codebase.Sqlite.Term.Format.LocallyIndexedComponent' t d)

module U.Codebase.Sqlite.Serialization
debug :: Bool
putABT :: (MonadPut m, Foldable f, Functor f, Ord v) => (v -> m ()) -> (a -> m ()) -> (forall x. (x -> m ()) -> f x -> m ()) -> Term f v a -> m ()
getABT :: (MonadGet m, Foldable f, Functor f, Ord v) => m v -> m a -> (forall x. m x -> m (f x)) -> m (Term f v a)
putLocalIds :: (MonadPut m, Integral t, Bits t, Integral d, Bits d) => LocalIds' t d -> m ()
getLocalIds :: MonadGet m => m LocalIds
getWatchLocalIds :: MonadGet m => m WatchLocalIds
putUnit :: Applicative m => () -> m ()
getUnit :: Applicative m => m ()
putWatchResultFormat :: MonadPut m => WatchResultFormat -> m ()
getWatchResultFormat :: MonadGet m => m WatchResultFormat
putTermFormat :: MonadPut m => TermFormat -> m ()
getTermFormat :: MonadGet m => m TermFormat
putTermComponent :: MonadPut m => LocallyIndexedComponent -> m ()
putTerm :: MonadPut m => Term -> m ()
getTermComponent :: MonadGet m => m LocallyIndexedComponent
getTerm :: MonadGet m => m Term
lookupTermElement :: MonadGet m => Pos -> m (LocalIds, Term, Type)
lookupTermElementDiscardingType :: MonadGet m => Pos -> m (LocalIds, Term)
lookupTermElementDiscardingTerm :: MonadGet m => Pos -> m (LocalIds, Type)
getTType :: MonadGet m => m Type
getType :: MonadGet m => m r -> m (TypeR r Symbol)
putDeclFormat :: MonadPut m => DeclFormat -> m ()
getDeclFormat :: MonadGet m => m DeclFormat
getDeclElement :: MonadGet m => m (Decl Symbol)
lookupDeclElement :: MonadGet m => Pos -> m (LocalIds, Decl Symbol)
putBranchFormat :: MonadPut m => BranchFormat -> m ()
putBranchLocalIds :: MonadPut m => BranchLocalIds -> m ()
putPatchFormat :: MonadPut m => PatchFormat -> m ()
getPatchFormat :: MonadGet m => m PatchFormat
getPatchLocalIds :: MonadGet m => m PatchLocalIds
putPatchFull :: MonadPut m => LocalPatch -> m ()
putPatchDiff :: MonadPut m => LocalPatchDiff -> m ()
putPatchLocalIds :: MonadPut m => PatchLocalIds -> m ()
putTermEdit :: MonadPut m => LocalTermEdit -> m ()
putTypeEdit :: MonadPut m => LocalTypeEdit -> m ()
getBranchFormat :: MonadGet m => m BranchFormat
getBranchLocalIds :: MonadGet m => m BranchLocalIds
decomposeComponent :: MonadGet m => m [(LocalIds, ByteString)]
recomposeComponent :: MonadPut m => [(LocalIds, ByteString)] -> m ()
decomposeWatchFormat :: MonadGet m => m SyncWatchResultFormat
recomposeWatchFormat :: MonadPut m => SyncWatchResultFormat -> m ()
decomposePatchFormat :: MonadGet m => m SyncPatchFormat
recomposePatchFormat :: MonadPut m => SyncPatchFormat -> m ()
decomposeBranchFormat :: MonadGet m => m SyncBranchFormat
recomposeBranchFormat :: MonadPut m => SyncBranchFormat -> m ()
getSymbol :: MonadGet m => m Symbol
putSymbol :: MonadPut m => Symbol -> m ()
putReferent :: (MonadPut m, Integral t1, Integral h1, Bits t1, Bits h1, Integral t2, Integral h2, Bits t2, Bits h2) => Referent' (Reference' t1 h1) (Reference' t2 h2) -> m ()
putReferent' :: MonadPut m => (r1 -> m ()) -> (r2 -> m ()) -> Referent' r1 r2 -> m ()
putReference :: (MonadPut m, Integral t, Bits t, Integral r, Bits r) => Reference' t r -> m ()
getReferent' :: MonadGet m => m r1 -> m r2 -> m (Referent' r1 r2)
getReferent :: (MonadGet m, Integral t1, Integral h1, Bits t1, Bits h1, Integral t2, Integral h2, Bits t2, Bits h2) => m (Referent' (Reference' t1 h1) (Reference' t2 h2))
getReference :: (MonadGet m, Integral t, Bits t, Integral r, Bits r) => m (Reference' t r)
putRecursiveReference :: (MonadPut m, Integral t, Bits t, Integral r, Bits r) => Reference' t (Maybe r) -> m ()
getRecursiveReference :: (MonadGet m, Integral t, Bits t, Integral r, Bits r) => m (Reference' t (Maybe r))
putInt :: MonadPut m => Int64 -> m ()
getInt :: MonadGet m => m Int64
putNat :: MonadPut m => Word64 -> m ()
getNat :: MonadGet m => m Word64
putFloat :: MonadPut m => Double -> m ()
getFloat :: MonadGet m => m Double
putBoolean :: MonadPut m => Bool -> m ()
getBoolean :: MonadGet m => m Bool
putTType :: MonadPut m => Type -> m ()
putDType :: MonadPut m => Type Symbol -> m ()
putType :: (MonadPut m, Ord v) => (r -> m ()) -> (v -> m ()) -> TypeR r v -> m ()
putChar :: MonadPut m => Char -> m ()
getChar :: MonadGet m => m Char
putMaybe :: MonadPut m => (a -> m ()) -> Maybe a -> m ()
getMaybe :: MonadGet m => m a -> m (Maybe a)
unknownTag :: (MonadGet m, Show a) => String -> a -> m x

module U.Codebase.Sqlite.Sync22
data Entity
O :: ObjectId -> Entity
C :: CausalHashId -> Entity
W :: WatchKind -> IdH -> Entity
data DbTag
SrcDb :: DbTag
DestDb :: DbTag
data DecodeError
ErrTermComponent :: DecodeError
ErrDeclComponent :: DecodeError
ErrBranchFormat :: DecodeError
ErrPatchFormat :: DecodeError
ErrWatchResult :: DecodeError
type ErrString = String
data Error
DbIntegrity :: Integrity -> Error
DecodeError :: DecodeError -> ByteString -> ErrString -> Error

-- | hashes corresponding to a single object in source codebase correspond
--   to multiple objects in destination codebase
HashObjectCorrespondence :: ObjectId -> [HashId] -> [HashId] -> [ObjectId] -> Error
SourceDbNotExist :: Error
data Env
Env :: Connection -> Connection -> Word -> Env
[srcDB] :: Env -> Connection
[destDB] :: Env -> Connection

-- | there are three caches of this size
[idCacheSize] :: Env -> Word
debug :: Bool
sync22 :: (MonadIO m, MonadError Error m, MonadReader Env m) => m (Sync m Entity)
trySync :: forall m. (MonadIO m, MonadError Error m, MonadReader Env m) => Cache TextId TextId -> Cache HashId HashId -> Cache ObjectId ObjectId -> Cache CausalHashId CausalHashId -> Entity -> m (TrySyncResult Entity)
runSrc :: (MonadError Error m, MonadReader Env m) => ReaderT Connection (ExceptT Integrity m) a -> m a
runDest :: (MonadError Error m, MonadReader Env m) => ReaderT Connection (ExceptT Integrity m) a -> m a
runDB :: MonadError Error m => Connection -> ReaderT Connection (ExceptT Integrity m) a -> m a
instance GHC.Show.Show U.Codebase.Sqlite.Sync22.Entity
instance GHC.Classes.Ord U.Codebase.Sqlite.Sync22.Entity
instance GHC.Classes.Eq U.Codebase.Sqlite.Sync22.Entity
instance GHC.Show.Show U.Codebase.Sqlite.Sync22.DecodeError
instance GHC.Show.Show U.Codebase.Sqlite.Sync22.Error

module U.Codebase.Sqlite.Operations
throwError :: Err m => Error -> m a
debug :: Bool

-- | crashOnError can be helpful for debugging. If it is False, the errors
--   will be delivered to the user elsewhere.
crashOnError :: Bool
type Err m = (MonadError Error m, HasCallStack)
type EDB m = (Err m, DB m)
type ErrString = String
data DecodeError
ErrTermElement :: Word64 -> DecodeError
ErrDeclElement :: Word64 -> DecodeError
ErrFramedArrayLen :: DecodeError
ErrTypeOfTerm :: Id -> DecodeError
ErrWatch :: WatchKind -> Id -> DecodeError
ErrBranch :: BranchObjectId -> DecodeError
ErrPatch :: PatchObjectId -> DecodeError
ErrObjectDependencies :: ObjectType -> ObjectId -> DecodeError
data Error
DecodeError :: DecodeError -> ByteString -> ErrString -> Error
DatabaseIntegrityError :: Integrity -> Error
UnknownDependency :: Hash -> Error
UnknownText :: Text -> Error
ExpectedBranch :: CausalHash -> BranchHash -> Error
ExpectedBranch' :: CausalHashId -> Error
LegacyUnknownCycleLen :: Hash -> Error
LegacyUnknownConstructorType :: Hash -> Pos -> Error
NeedTypeForBuiltinMetadata :: Text -> Error
getFromBytesOr :: Err m => DecodeError -> Get a -> ByteString -> m a
liftQ :: Err m => ExceptT Integrity m a -> m a
lookupTextId :: EDB m => Text -> m TextId
loadTextById :: EDB m => TextId -> m Text

-- | look up an existing object by its primary hash
primaryHashToExistingObjectId :: EDB m => Hash -> m ObjectId
primaryHashToMaybeObjectId :: DB m => Hash -> m (Maybe ObjectId)
primaryHashToMaybePatchObjectId :: EDB m => PatchHash -> m (Maybe PatchObjectId)
objectExistsForHash :: DB m => Hash -> m Bool
loadHashByObjectId :: EDB m => ObjectId -> m Hash
loadHashByHashId :: EDB m => HashId -> m Hash
loadCausalHashById :: EDB m => CausalHashId -> m CausalHash
loadValueHashByCausalHashId :: EDB m => CausalHashId -> m BranchHash
loadRootCausalHash :: EDB m => m CausalHash
loadMaybeRootCausalHash :: EDB m => m (Maybe CausalHash)
c2sReference :: EDB m => Reference -> m Reference
s2cReference :: EDB m => Reference -> m Reference
c2sReferenceId :: EDB m => Id -> m Id
s2cReferenceId :: EDB m => Id -> m Id
h2cReferenceId :: EDB m => IdH -> m Id
h2cReference :: EDB m => ReferenceH -> m Reference
c2hReference :: DB m => Reference -> MaybeT m ReferenceH
s2cReferent :: EDB m => Referent -> m Referent
s2cReferentId :: EDB m => Id -> m Id
c2sReferentId :: EDB m => Id -> m Id
h2cReferent :: EDB m => ReferentH -> m Referent
s2cTermEdit :: EDB m => TermEdit -> m TermEdit
s2cTyping :: Typing -> Typing
c2sTyping :: Typing -> Typing
s2cTypeEdit :: EDB m => TypeEdit -> m TypeEdit

-- | assumes that all relevant values are already in the DB
c2lPatch :: EDB m => Patch -> m (PatchLocalIds, LocalPatch)

-- | produces a diff diff = full - ref; full = diff + ref
diffPatch :: LocalPatch -> LocalPatch -> LocalPatchDiff
decodeComponentLengthOnly :: Err m => ByteString -> m Word64
decodeTermElementWithType :: Err m => Pos -> ByteString -> m (LocalIds, Term, Type)
decodeTermElementDiscardingTerm :: Err m => Pos -> ByteString -> m (LocalIds, Type)
decodeTermElementDiscardingType :: Err m => Pos -> ByteString -> m (LocalIds, Term)
decodeDeclElement :: Err m => Word64 -> ByteString -> m (LocalIds, Decl Symbol)
getCycleLen :: EDB m => Hash -> m Word64
getDeclTypeByReference :: EDB m => Id -> m DeclType
componentByObjectId :: EDB m => ObjectId -> m [Id]
saveTermComponent :: EDB m => Hash -> [(Term Symbol, Type Symbol)] -> m ObjectId

-- | Save the text and hash parts of a Reference to the database and
--   substitute their ids.
saveReferenceH :: DB m => Reference' Text Hash -> m (Reference' TextId HashId)

-- | implementation detail of c2{s,w}Term The Type is optional, because we
--   don't store them for watch expression results.
c2xTerm :: forall m t d. Monad m => (Text -> m t) -> (Hash -> m d) -> Term Symbol -> Maybe (Type Symbol) -> m (LocalIds' t d, Term, Maybe Type)
loadTermWithTypeByReference :: EDB m => Id -> MaybeT m (Term Symbol, Type Symbol)
loadTermByReference :: EDB m => Id -> MaybeT m (Term Symbol)
loadTypeOfTermByTermReference :: EDB m => Id -> MaybeT m (Type Symbol)
s2cTermWithType :: EDB m => LocalIds -> Term -> Type -> m (Term Symbol, Type Symbol)
s2cTerm :: EDB m => LocalIds -> Term -> m (Term Symbol)
s2cTypeOfTerm :: EDB m => LocalIds -> Type -> m (Type Symbol)

-- | implementation detail of {s,w}2c*Term*
localIdsToLookups :: Monad m => (t -> m Text) -> (d -> m Hash) -> LocalIds' t d -> m (LocalTextId -> Text, LocalDefnId -> Hash)

-- | implementation detail of {s,w}2c*Term*
x2cTerm :: (LocalTextId -> Text) -> (LocalDefnId -> Hash) -> Term -> Term Symbol

-- | implementation detail of {s,w}2c*Term*
x2cTType :: (LocalTextId -> Text) -> (LocalDefnId -> Hash) -> Type -> Type Symbol
lookupText :: forall m s w t. (MonadState s m, MonadWriter w m, Field1' s (Map t LocalTextId), Field1' w (Seq t), Ord t) => t -> m LocalTextId
lookupDefn :: forall m s w d. (MonadState s m, MonadWriter w m, Field2' s (Map d LocalDefnId), Field2' w (Seq d), Ord d) => d -> m LocalDefnId

-- | shared implementation of lookupTextHelper and lookupDefnHelper Look up
--   a value in the LUT, or append it.
lookup_ :: (MonadState s m, MonadWriter w m, Ord t) => Lens' s (Map t t') -> Lens' w (Seq t) -> (Word64 -> t') -> t -> m t'
c2sTerm :: EDB m => Term Symbol -> Type Symbol -> m (LocalIds, Term, Type)
listWatches :: EDB m => WatchKind -> m [Id]

-- | returns Nothing if the expression isn't cached.
loadWatch :: EDB m => WatchKind -> Id -> MaybeT m (Term Symbol)
saveWatch :: EDB m => WatchKind -> Id -> Term Symbol -> m ()
clearWatches :: DB m => m ()
c2wTerm :: EDB m => Term Symbol -> m (WatchLocalIds, Term)
w2cTerm :: EDB m => WatchLocalIds -> Term -> m (Term Symbol)
saveDeclComponent :: EDB m => Hash -> [Decl Symbol] -> m ObjectId
c2sDecl :: forall m t d. EDB m => (Text -> m t) -> (Hash -> m d) -> Decl Symbol -> m (LocalIds' t d, Decl Symbol)
loadDeclByReference :: EDB m => Id -> MaybeT m (Decl Symbol)
s2cBranch :: EDB m => DbBranch -> m (Branch m)
type BranchSavingState = (Map Text LocalTextId, Map Hash LocalDefnId, Map PatchObjectId LocalPatchObjectId, Map (BranchObjectId, CausalHashId) LocalBranchChildId)
type BranchSavingWriter = (Seq Text, Seq Hash, Seq PatchObjectId, Seq (BranchObjectId, CausalHashId))
type BranchSavingConstraint m = (MonadState BranchSavingState m, MonadWriter BranchSavingWriter m)
type BranchSavingMonad m = StateT BranchSavingState (WriterT BranchSavingWriter m)
saveRootBranch :: EDB m => Causal m -> m (BranchObjectId, CausalHashId)
saveBranch :: EDB m => Causal m -> m (BranchObjectId, CausalHashId)
loadRootCausal :: EDB m => m (Causal m)
dataVersion :: DB m => m DataVersion
loadCausalBranchByCausalHash :: EDB m => CausalHash -> m (Maybe (Causal m))
loadCausalByCausalHashId :: EDB m => CausalHashId -> m (Causal m)

-- | is this even a thing? loading a branch by causal hash? yes I guess so.
loadBranchByCausalHashId :: EDB m => CausalHashId -> m (Maybe (Branch m))
loadBranchByObjectId :: EDB m => BranchObjectId -> m (Branch m)
loadPatchById :: EDB m => PatchObjectId -> m Patch
savePatch :: EDB m => PatchHash -> Patch -> m PatchObjectId
s2cPatch :: EDB m => Patch -> m Patch
deserializePatchObject :: EDB m => PatchObjectId -> m PatchFormat
lca :: EDB m => CausalHash -> CausalHash -> Connection -> Connection -> m (Maybe CausalHash)
before :: DB m => CausalHash -> CausalHash -> m (Maybe Bool)
termsHavingType :: EDB m => Reference -> m (Set Id)
typeReferenceForTerm :: EDB m => Id -> m ReferenceH
termsMentioningType :: EDB m => Reference -> m (Set Id)
addTypeToIndexForTerm :: EDB m => Id -> Reference -> m ()
addTypeMentionsToIndexForTerm :: EDB m => Id -> Set Reference -> m ()
componentReferencesByPrefix :: EDB m => ObjectType -> Text -> Maybe Pos -> m [Id]
termReferencesByPrefix :: EDB m => Text -> Maybe Word64 -> m [Id]
declReferencesByPrefix :: EDB m => Text -> Maybe Word64 -> m [Id]
termReferentsByPrefix :: EDB m => Text -> Maybe Word64 -> m [Id]
declReferentsByPrefix :: EDB m => Text -> Maybe Pos -> Maybe ConstructorId -> m [(Hash, Pos, Word64, DeclType, [ConstructorId])]
branchHashesByPrefix :: EDB m => ShortBranchHash -> m (Set BranchHash)
causalHashesByPrefix :: EDB m => ShortBranchHash -> m (Set CausalHash)

-- | returns a list of known definitions referencing <tt>r</tt>
dependents :: EDB m => Reference -> m (Set Id)

-- | returns empty set for unknown inputs; doesn't distinguish between term
--   and decl
derivedDependencies :: EDB m => Id -> m (Set Id)
instance GHC.Show.Show U.Codebase.Sqlite.Operations.DecodeError
instance GHC.Show.Show U.Codebase.Sqlite.Operations.Error
