-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-codebase-sqlite
@version 0.0.0

module U.Codebase.Sqlite.DbId
newtype HashVersion
HashVersion :: Word64 -> HashVersion
newtype ObjectId
ObjectId :: Word64 -> ObjectId
newtype TextId
TextId :: Word64 -> TextId
newtype HashId
HashId :: Word64 -> HashId
newtype PatchObjectId
PatchObjectId :: ObjectId -> PatchObjectId
[unPatchObjectId] :: PatchObjectId -> ObjectId
newtype BranchObjectId
BranchObjectId :: ObjectId -> BranchObjectId
[unBranchObjectId] :: BranchObjectId -> ObjectId
newtype BranchHashId
BranchHashId :: HashId -> BranchHashId
[unBranchHashId] :: BranchHashId -> HashId
newtype CausalHashId
CausalHashId :: HashId -> CausalHashId
[unCausalHashId] :: CausalHashId -> HashId
newtype SchemaVersion
SchemaVersion :: Word64 -> SchemaVersion
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.HashVersion
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.HashVersion
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Real.Real U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Num.Num U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Show.Show U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.HashVersion
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.ObjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.ObjectId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.ObjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.TextId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.TextId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.TextId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.TextId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.TextId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.TextId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.TextId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.TextId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.TextId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.TextId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.HashId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.HashId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.HashId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.HashId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.HashId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.HashId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.HashId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.HashId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.HashId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.HashId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.PatchObjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.PatchObjectId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.PatchObjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.BranchObjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.BranchObjectId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.BranchObjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.BranchHashId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.BranchHashId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.BranchHashId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.CausalHashId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.CausalHashId
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.CausalHashId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.SchemaVersion
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.SchemaVersion
instance Data.Bits.Bits U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Real.Real U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Num.Num U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Show.Show U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Show.Show U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.PatchObjectId

module U.Codebase.Sqlite.Causal
data GDbCausal causalHash valueHash
DbCausal :: causalHash -> valueHash -> Set causalHash -> GDbCausal causalHash valueHash
[selfHash] :: GDbCausal causalHash valueHash -> causalHash
[valueHash] :: GDbCausal causalHash valueHash -> valueHash
[parents] :: GDbCausal causalHash valueHash -> Set causalHash
type DbCausal = GDbCausal CausalHashId BranchHashId

module U.Codebase.Sqlite.LocalIds

-- | A mapping between index ids that are local to an object and the ids in
--   the database
data LocalIds' t h
LocalIds :: Vector t -> Vector h -> LocalIds' t h
[textLookup] :: LocalIds' t h -> Vector t
[defnLookup] :: LocalIds' t h -> Vector h
type LocalIds = LocalIds' TextId ObjectId
type WatchLocalIds = LocalIds' TextId HashId

-- | represents an index into a textLookup
newtype LocalTextId
LocalTextId :: Word64 -> LocalTextId

-- | represents an index into a defnLookup
--   
--   In this context, "definition" means an object that is either a term
--   component or a (type) decl component, not a patch, namespace, or any
--   other kind of object.
newtype LocalDefnId
LocalDefnId :: Word64 -> LocalDefnId

-- | a local index to a hash, used when the corresponding object is allowed
--   to be absent
newtype LocalHashId
LocalHashId :: Word64 -> LocalHashId
newtype LocalPatchObjectId
LocalPatchObjectId :: Word64 -> LocalPatchObjectId
newtype LocalBranchChildId
LocalBranchChildId :: Word64 -> LocalBranchChildId

-- | causal hashes are treated differently from HashIds, which don't have
--   dependencies
newtype LocalCausalHashId
LocalCausalHashId :: Word64 -> LocalCausalHashId
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.LocalIds.LocalIds' t h)
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalTextId
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalDefnId
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalHashId
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance Data.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance Data.Bitraversable.Bitraversable U.Codebase.Sqlite.LocalIds.LocalIds'
instance Data.Bifoldable.Bifoldable U.Codebase.Sqlite.LocalIds.LocalIds'
instance Data.Bifunctor.Bifunctor U.Codebase.Sqlite.LocalIds.LocalIds'

module U.Codebase.Sqlite.Branch.Full

-- | <pre>
--   Branch
--     { terms :: Map LocalTextId (Map LocalReferent LocalMetadataSet),
--       types :: Map LocalTextId (Map LocalReference LocalMetadataSet),
--       patches :: Map LocalTextId LocalPatchObjectId,
--       children :: Map LocalTextId LocalBranchChildId
--     }
--   </pre>
type LocalBranch = Branch' LocalTextId LocalDefnId LocalPatchObjectId LocalBranchChildId

-- | <pre>
--   Branch
--     { terms :: Map TextId (Map Referent DbMetadataSet),
--       types :: Map TextId (Map Reference DbMetadataSet),
--       patches :: Map TextId PatchObjectId,
--       children :: Map TextId (BranchObjectId, CausalHashId)
--     }
--   </pre>
type DbBranch = Branch' TextId ObjectId PatchObjectId (BranchObjectId, CausalHashId)
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)
data Branch' t h p c
Branch :: Map t (Map (Referent'' t h) (MetadataSetFormat' t h)) -> Map t (Map (Reference' t h) (MetadataSetFormat' t h)) -> Map t p -> Map t c -> Branch' t h p c
[terms] :: Branch' t h p c -> Map t (Map (Referent'' t h) (MetadataSetFormat' t h))
[types] :: Branch' t h p c -> Map t (Map (Reference' t h) (MetadataSetFormat' t h))
[patches] :: Branch' t h p c -> Map t p
[children] :: Branch' t h p c -> Map t c
emptyBranch :: Branch' t h p c
branchHashes_ :: (Ord h', Ord t, Ord h) => Traversal (Branch' t h p c) (Branch' t h' p c) h h'
patches_ :: Traversal (Branch' t h p c) (Branch' t h p' c) p p'
childrenHashes_ :: Traversal (Branch' t h p c) (Branch' t h p c') c c'
branchCausalHashes_ :: Traversal (Branch' t h p c) (Branch' t h p c') c c'
type LocalMetadataSet = MetadataSetFormat' LocalTextId LocalDefnId
type DbMetadataSet = MetadataSetFormat' TextId ObjectId
data MetadataSetFormat' t h
Inline :: Set (Reference' t h) -> MetadataSetFormat' t h
metadataSetFormatReferences_ :: (Ord t, Ord h, Ord h') => Traversal (MetadataSetFormat' t h) (MetadataSetFormat' t h') (Reference' t h) (Reference' t h')
quadmap :: forall t h p c t' h' p' c'. (Ord t', Ord h') => (t -> t') -> (h -> h') -> (p -> p') -> (c -> c') -> Branch' t h p c -> Branch' t' h' p' c'
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Full.MetadataSetFormat' t h)
instance GHC.Generics.Generic (U.Codebase.Sqlite.Branch.Full.Branch' t h p c)
instance (GHC.Show.Show t, GHC.Show.Show h, GHC.Show.Show p, GHC.Show.Show c) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Full.Branch' t h p c)

module U.Codebase.Sqlite.Branch.Diff
type LocalDiff = Diff' LocalTextId LocalDefnId LocalPatchObjectId LocalBranchChildId
type Diff = Diff' TextId ObjectId PatchObjectId (BranchObjectId, CausalHashId)
data DefinitionOp' r
RemoveDef :: DefinitionOp' r
AddDefWithMetadata :: Set r -> DefinitionOp' r
AlterDefMetadata :: AddRemove r -> DefinitionOp' r
data PatchOp' p
PatchRemove :: PatchOp' p
PatchAddReplace :: p -> PatchOp' p
data ChildOp' c
ChildRemove :: ChildOp' c
ChildAddReplace :: c -> ChildOp' c
type AddRemove a = Map a Bool
type LocalDefinitionOp = DefinitionOp' (Metadata LocalTextId LocalDefnId)
type LocalPatchOp = PatchOp' LocalPatchObjectId
type LocalChildOp = ChildOp' LocalBranchChildId
type DefinitionOp = DefinitionOp' (Metadata TextId ObjectId)
type PatchOp = PatchOp' PatchObjectId
type ChildOp = ChildOp' (BranchObjectId, CausalHashId)
addsRemoves :: AddRemove a -> ([a], [a])
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)
data Diff' t h p c
Diff :: Map t (Map (Referent'' t h) (DefinitionOp' (Metadata t h))) -> Map t (Map (Reference' t h) (DefinitionOp' (Metadata t h))) -> Map t (PatchOp' p) -> Map t (ChildOp' c) -> Diff' t h p c
[terms] :: Diff' t h p c -> Map t (Map (Referent'' t h) (DefinitionOp' (Metadata t h)))
[types] :: Diff' t h p c -> Map t (Map (Reference' t h) (DefinitionOp' (Metadata t h)))
[patches] :: Diff' t h p c -> Map t (PatchOp' p)
[children] :: Diff' t h p c -> Map t (ChildOp' c)
type Metadata t h = Reference' t h
quadmap :: (Ord t', Ord h') => (t -> t') -> (h -> h') -> (p -> p') -> (c -> c') -> Diff' t h p c -> Diff' t' h' p' c'
instance GHC.Show.Show p => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.PatchOp' p)
instance GHC.Base.Functor U.Codebase.Sqlite.Branch.Diff.PatchOp'
instance GHC.Show.Show c => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.ChildOp' c)
instance GHC.Base.Functor U.Codebase.Sqlite.Branch.Diff.ChildOp'
instance GHC.Show.Show r => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.DefinitionOp' r)
instance (GHC.Show.Show t, GHC.Show.Show h, GHC.Show.Show p, GHC.Show.Show c) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.Diff' t h p c)

module U.Codebase.Sqlite.Branch.Format

-- | A <a>BranchFormat</a> is a deserialized namespace object
--   (<tt>object.bytes</tt>).
--   
--   you can use the exact same <a>BranchLocalIds</a> when converting
--   between <a>Full</a> and <a>Diff</a>
data BranchFormat
Full :: BranchLocalIds -> LocalBranch -> BranchFormat
Diff :: BranchObjectId -> BranchLocalIds -> LocalDiff -> BranchFormat

-- | A <a>BranchLocalIds</a> is a mapping between local ids (local to this
--   object) encoded as offsets, and actual database ids.
--   
--   For example, a <tt>branchTextLookup</tt> vector of <tt>[50, 74]</tt>
--   means "local id 0 corresponds to database text id 50, and local id 1
--   corresponds to database text id 74".
data BranchLocalIds
LocalIds :: Vector TextId -> Vector ObjectId -> Vector PatchObjectId -> Vector (BranchObjectId, CausalHashId) -> BranchLocalIds
[branchTextLookup] :: BranchLocalIds -> Vector TextId
[branchDefnLookup] :: BranchLocalIds -> Vector ObjectId
[branchPatchLookup] :: BranchLocalIds -> Vector PatchObjectId
[branchChildLookup] :: BranchLocalIds -> Vector (BranchObjectId, CausalHashId)
data SyncBranchFormat
SyncFull :: BranchLocalIds -> ByteString -> SyncBranchFormat
SyncDiff :: BranchObjectId -> BranchLocalIds -> ByteString -> SyncBranchFormat
localToDbBranch :: BranchLocalIds -> LocalBranch -> DbBranch
localToDbDiff :: BranchLocalIds -> LocalDiff -> Diff
instance GHC.Show.Show U.Codebase.Sqlite.Branch.Format.BranchLocalIds
instance GHC.Show.Show U.Codebase.Sqlite.Branch.Format.BranchFormat

module U.Codebase.Sqlite.NamedRef
type ReversedSegments = NonEmpty Text
data ConstructorType
DataConstructor :: ConstructorType
EffectConstructor :: ConstructorType
data NamedRef ref
NamedRef :: ReversedSegments -> ref -> NamedRef ref
[reversedSegments] :: NamedRef ref -> ReversedSegments
[ref] :: NamedRef ref -> ref
instance Data.Traversable.Traversable U.Codebase.Sqlite.NamedRef.NamedRef
instance Data.Foldable.Foldable U.Codebase.Sqlite.NamedRef.NamedRef
instance GHC.Base.Functor U.Codebase.Sqlite.NamedRef.NamedRef
instance GHC.Show.Show ref => GHC.Show.Show (U.Codebase.Sqlite.NamedRef.NamedRef ref)
instance Database.SQLite.Simple.ToRow.ToRow ref => Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Sqlite.NamedRef.NamedRef ref)
instance Database.SQLite.Simple.FromRow.FromRow ref => Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Sqlite.NamedRef.NamedRef ref)
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.NamedRef.ConstructorType
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.NamedRef.ConstructorType

module U.Codebase.Sqlite.ObjectType

-- | Don't reorder these, they are part of the database, and the ToField
--   and FromField implementation currently depends on the derived Enum
--   implementation.
data ObjectType
TermComponent :: ObjectType
DeclComponent :: ObjectType
Namespace :: ObjectType
Patch :: ObjectType
instance GHC.Enum.Enum U.Codebase.Sqlite.ObjectType.ObjectType
instance GHC.Show.Show U.Codebase.Sqlite.ObjectType.ObjectType
instance GHC.Classes.Ord U.Codebase.Sqlite.ObjectType.ObjectType
instance GHC.Classes.Eq U.Codebase.Sqlite.ObjectType.ObjectType
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.ObjectType.ObjectType
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.ObjectType.ObjectType

module U.Codebase.Sqlite.Orphans
newtype AsSqlite a
AsSqlite :: a -> AsSqlite a
[fromSQLite] :: AsSqlite a -> a
instance GHC.Show.Show a => GHC.Show.Show (U.Codebase.Sqlite.Orphans.AsSqlite a)
instance Database.SQLite.Simple.ToField.ToField U.Util.Base32Hex.Base32Hex
instance Database.SQLite.Simple.FromField.FromField U.Util.Base32Hex.Base32Hex
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Sqlite.Orphans.AsSqlite U.Codebase.Reference.Reference)
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Sqlite.Orphans.AsSqlite U.Codebase.Referent.Referent)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Sqlite.Orphans.AsSqlite U.Codebase.Referent.Referent)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Sqlite.Orphans.AsSqlite U.Codebase.Reference.Reference)
instance Database.SQLite.Simple.ToField.ToField (U.Codebase.Sqlite.Orphans.AsSqlite U.Util.Hash.Hash)
instance Database.SQLite.Simple.FromField.FromField (U.Codebase.Sqlite.Orphans.AsSqlite U.Util.Hash.Hash)
instance Database.SQLite.Simple.ToField.ToField U.Codebase.WatchKind.WatchKind
instance Database.SQLite.Simple.FromField.FromField U.Codebase.WatchKind.WatchKind

module U.Codebase.Sqlite.Patch.TermEdit
type TermEdit = TermEdit' TextId ObjectId
type LocalTermEdit = TermEdit' LocalTextId LocalDefnId
type Referent' t h = Referent' (Reference' t h) (Reference' t h)
data TermEdit' t h
Replace :: Referent' t h -> Typing -> TermEdit' t h
Deprecate :: TermEdit' t h
_Replace :: Prism (TermEdit' t h) (TermEdit' t' h') (Referent' t h, Typing) (Referent' t' h', Typing)
h_ :: Traversal (TermEdit' t h) (TermEdit' t h') h h'
data Typing
Same :: Typing
Subtype :: Typing
Different :: Typing
instance GHC.Show.Show U.Codebase.Sqlite.Patch.TermEdit.Typing
instance GHC.Classes.Ord U.Codebase.Sqlite.Patch.TermEdit.Typing
instance GHC.Classes.Eq U.Codebase.Sqlite.Patch.TermEdit.Typing
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.Patch.TermEdit.TermEdit' t h)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h) => GHC.Classes.Ord (U.Codebase.Sqlite.Patch.TermEdit.TermEdit' t h)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h) => GHC.Classes.Eq (U.Codebase.Sqlite.Patch.TermEdit.TermEdit' t h)
instance Data.Bifunctor.Bifunctor U.Codebase.Sqlite.Patch.TermEdit.TermEdit'
instance Data.Bifoldable.Bifoldable U.Codebase.Sqlite.Patch.TermEdit.TermEdit'
instance Data.Bitraversable.Bitraversable U.Codebase.Sqlite.Patch.TermEdit.TermEdit'

module U.Codebase.Sqlite.Patch.TypeEdit
type LocalTypeEdit = TypeEdit' LocalTextId LocalDefnId
type TypeEdit = TypeEdit' TextId ObjectId
data TypeEdit' t h
Replace :: Reference' t h -> TypeEdit' t h
Deprecate :: TypeEdit' t h
_Replace :: Prism (TypeEdit' t h) (TypeEdit' t' h') (Reference' t h) (Reference' t' h')
h_ :: Traversal (TypeEdit' t h) (TypeEdit' t h') h h'
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit' t h)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h) => GHC.Classes.Ord (U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit' t h)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h) => GHC.Classes.Eq (U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit' t h)
instance Data.Bifunctor.Bifunctor U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit'
instance Data.Bifoldable.Bifoldable U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit'
instance Data.Bitraversable.Bitraversable U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit'

module U.Codebase.Sqlite.Patch.Full

-- | <pre>
--   LocalPatch
--     { termEdits :: Map ReferentH (Set TermEdit),
--       typeEdits :: Map ReferenceH (Set TypeEdit)
--     }
--   </pre>
type Patch = Patch' TextId HashId ObjectId

-- | <pre>
--   LocalPatch
--     { termEdits :: Map LocalReferentH (Set LocalTermEdit),
--       typeEdits :: Map LocalReferenceH (Set LocalTypeEdit)
--     }
--   </pre>
type LocalPatch = Patch' LocalTextId LocalHashId LocalDefnId
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)
data Patch' t h o
Patch :: Map (Referent'' t h) (Set (TermEdit' t o)) -> Map (Reference' t h) (Set (TypeEdit' t o)) -> Patch' t h o
[termEdits] :: Patch' t h o -> Map (Referent'' t h) (Set (TermEdit' t o))
[typeEdits] :: Patch' t h o -> Map (Reference' t h) (Set (TypeEdit' t o))
patchH_ :: (Ord t, Ord h') => Traversal (Patch' t h o) (Patch' t h' o) h h'
patchO_ :: (Ord t, Ord o') => Traversal (Patch' t h o) (Patch' t h o') o o'
trimap :: (Ord t', Ord h', Ord o') => (t -> t') -> (h -> h') -> (o -> o') -> Patch' t h o -> Patch' t' h' o'

module U.Codebase.Sqlite.Patch.Diff
type PatchDiff = PatchDiff' TextId HashId ObjectId
type LocalPatchDiff = PatchDiff' LocalTextId LocalHashId LocalDefnId
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)

-- | diff. = min. - sub.
data PatchDiff' t h d
PatchDiff :: Map (Referent'' t h) (Set (TermEdit' t d)) -> Map (Reference' t h) (Set (TypeEdit' t d)) -> Map (Referent'' t h) (Set (TermEdit' t d)) -> Map (Reference' t h) (Set (TypeEdit' t d)) -> PatchDiff' t h d

-- | elements present in min. but absent in sub.
[addedTermEdits] :: PatchDiff' t h d -> Map (Referent'' t h) (Set (TermEdit' t d))
[addedTypeEdits] :: PatchDiff' t h d -> Map (Reference' t h) (Set (TypeEdit' t d))

-- | elements missing in min. but present in sub.
[removedTermEdits] :: PatchDiff' t h d -> Map (Referent'' t h) (Set (TermEdit' t d))
[removedTypeEdits] :: PatchDiff' t h d -> Map (Reference' t h) (Set (TypeEdit' t d))
trimap :: (Ord t', Ord h', Ord d') => (t -> t') -> (h -> h') -> (d -> d') -> PatchDiff' t h d -> PatchDiff' t' h' d'
instance (GHC.Show.Show t, GHC.Show.Show h, GHC.Show.Show d) => GHC.Show.Show (U.Codebase.Sqlite.Patch.Diff.PatchDiff' t h d)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h, GHC.Classes.Ord d) => GHC.Classes.Ord (U.Codebase.Sqlite.Patch.Diff.PatchDiff' t h d)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h, GHC.Classes.Eq d) => GHC.Classes.Eq (U.Codebase.Sqlite.Patch.Diff.PatchDiff' t h d)

module U.Codebase.Sqlite.Patch.Format
data PatchFormat
Full :: PatchLocalIds -> LocalPatch -> PatchFormat
Diff :: PatchObjectId -> PatchLocalIds -> LocalPatchDiff -> PatchFormat
data PatchLocalIds
LocalIds :: Vector TextId -> Vector HashId -> Vector ObjectId -> PatchLocalIds
[patchTextLookup] :: PatchLocalIds -> Vector TextId
[patchHashLookup] :: PatchLocalIds -> Vector HashId
[patchDefnLookup] :: PatchLocalIds -> Vector ObjectId
data SyncPatchFormat
SyncFull :: PatchLocalIds -> ByteString -> SyncPatchFormat
SyncDiff :: PatchObjectId -> PatchLocalIds -> ByteString -> SyncPatchFormat

-- | Apply a list of patch diffs to a patch, left to right.
applyPatchDiffs :: Patch -> [PatchDiff] -> Patch
localPatchToPatch :: PatchLocalIds -> LocalPatch -> Patch
localPatchDiffToPatchDiff :: PatchLocalIds -> LocalPatchDiff -> PatchDiff

module U.Codebase.Sqlite.Reference
type Reference = Reference' TextId ObjectId

-- | The name lookup table uses this because normalizing/denormalizing
--   hashes to ids is slower than we'd like when writing/reading the entire
--   name lookup table.
type TextReference = Reference' Text Base32Hex
type Id = Id' ObjectId
type LocalReferenceH = Reference' LocalTextId LocalHashId
type LocalReference = Reference' LocalTextId LocalDefnId
type LocalId = Id' LocalDefnId
type ReferenceH = Reference' TextId HashId
type IdH = Id' HashId
referenceToRow :: (ToField t, ToField h) => Reference' t h -> [SQLData]
referenceFromRow' :: (FromField t, FromField h, Show t, Show h) => RowParser (Reference' t h)
instance Database.SQLite.Simple.ToRow.ToRow U.Codebase.Sqlite.Reference.Reference
instance Database.SQLite.Simple.FromRow.FromRow U.Codebase.Sqlite.Reference.Reference
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Reference' Data.Text.Internal.Text U.Util.Base32Hex.Base32Hex)
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Reference' U.Codebase.Sqlite.DbId.TextId U.Codebase.Sqlite.DbId.HashId)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Reference' U.Codebase.Sqlite.DbId.TextId U.Codebase.Sqlite.DbId.HashId)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Reference' Data.Text.Internal.Text U.Util.Base32Hex.Base32Hex)
instance Database.SQLite.Simple.ToField.ToField h => Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Id' h)
instance Database.SQLite.Simple.FromField.FromField h => Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Id' h)

module U.Codebase.Sqlite.Referent
type Referent = Referent' Reference Reference

-- | The name lookup table uses this because normalizing/denormalizing
--   hashes to ids is slower than we'd like when writing/reading the entire
--   name lookup table.
type TextReferent = Referent' TextReference TextReference
type ReferentH = Referent' ReferenceH ReferenceH
type Id = Id' ObjectId ObjectId
type LocalReferent = Referent' LocalReference LocalReference
type LocalReferentH = Referent' LocalReferenceH LocalReferenceH
instance Database.SQLite.Simple.ToRow.ToRow U.Codebase.Sqlite.Referent.Id
instance Database.SQLite.Simple.FromRow.FromRow U.Codebase.Sqlite.Referent.Id
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Reference' t h) => Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Referent.Referent' (U.Codebase.Reference.Reference' t h) (U.Codebase.Reference.Reference' t h))
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Reference' t h) => Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Referent.Referent' (U.Codebase.Reference.Reference' t h) (U.Codebase.Reference.Reference' t h))


-- | Some naming conventions used in this module:
--   
--   <ul>
--   <li><tt>32</tt>: the base32 representation of a hash</li>
--   <li><tt>expect</tt>: retrieve something that's known to exist</li>
--   <li><tt>load</tt>: retrieve something that's not known to exist (so
--   the return type is a Maybe, or another container that could be
--   empty)</li>
--   <li><tt>save</tt>: idempotent (on conflict do nothing) insert, and
--   return the id of the thing (usually)</li>
--   </ul>
module U.Codebase.Sqlite.Queries
saveText :: Text -> Transaction TextId
loadTextId :: Text -> Transaction (Maybe TextId)
expectTextId :: Text -> Transaction TextId
expectText :: TextId -> Transaction Text
expectTextCheck :: SqliteExceptionReason e => TextId -> (Text -> Either e a) -> Transaction a
saveHash :: Base32Hex -> Transaction HashId
saveHashHash :: Hash -> Transaction HashId
loadHashId :: Base32Hex -> Transaction (Maybe HashId)
expectHash :: HashId -> Transaction Hash
expectHash32 :: HashId -> Transaction Base32Hex
loadHashIdByHash :: Hash -> Transaction (Maybe HashId)
expectHashIdByHash :: Hash -> Transaction HashId
saveCausalHash :: CausalHash -> Transaction CausalHashId
expectCausalHash :: CausalHashId -> Transaction CausalHash
saveBranchHash :: BranchHash -> Transaction BranchHashId
saveHashObject :: HashId -> ObjectId -> HashVersion -> Transaction ()
expectHashIdsForObject :: ObjectId -> Transaction (NonEmpty HashId)
hashIdWithVersionForObject :: ObjectId -> Transaction [(HashId, HashVersion)]
loadObjectIdForPrimaryHashId :: HashId -> Transaction (Maybe ObjectId)

-- | Not all hashes have corresponding objects; e.g., hashes of term types
expectObjectIdForPrimaryHashId :: HashId -> Transaction ObjectId
loadObjectIdForPrimaryHash :: Hash -> Transaction (Maybe ObjectId)
expectObjectIdForPrimaryHash :: Hash -> Transaction ObjectId
loadPatchObjectIdForPrimaryHash :: PatchHash -> Transaction (Maybe PatchObjectId)
loadObjectIdForAnyHash :: Hash -> Transaction (Maybe ObjectId)
loadObjectIdForAnyHashId :: HashId -> Transaction (Maybe ObjectId)
expectObjectIdForAnyHashId :: HashId -> Transaction ObjectId

-- | <tt>recordObjectRehash old new</tt> records that object <tt>old</tt>
--   was rehashed and inserted as a new object, <tt>new</tt>.
--   
--   This function rewrites <tt>old</tt>'s <tt>hash_object</tt> rows in
--   place to point at the new object.
recordObjectRehash :: ObjectId -> ObjectId -> Transaction ()
saveObject :: HashId -> ObjectType -> ByteString -> Transaction ObjectId
expectObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction a

-- | All objects have corresponding hashes.
expectPrimaryHashByObjectId :: ObjectId -> Transaction Hash
expectPrimaryHashIdForObject :: ObjectId -> Transaction HashId
expectObjectWithHashIdAndType :: ObjectId -> Transaction (HashId, ObjectType, ByteString)

-- | Expect a decl component object.
expectDeclObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction a

-- | Load a decl component object.
loadDeclObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction (Maybe a)

-- | Expect a namespace object.
expectNamespaceObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction a

-- | Load a namespace object.
loadNamespaceObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction (Maybe a)

-- | Expect a patch object.
expectPatchObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction a

-- | Load a patch object.
loadPatchObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction (Maybe a)

-- | Load a term component object.
loadTermObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction (Maybe a)

-- | Expect a term component object.
expectTermObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction a
loadNamespaceRoot :: Transaction (Maybe CausalHashId)
setNamespaceRoot :: CausalHashId -> Transaction ()
expectNamespaceRoot :: Transaction CausalHashId

-- | Maybe we would generalize this to something other than NamespaceHash
--   if we end up wanting to store other kinds of Causals here too.
saveCausal :: CausalHashId -> BranchHashId -> Transaction ()
isCausalHash :: HashId -> Transaction Bool
loadCausalHashIdByCausalHash :: CausalHash -> Transaction (Maybe CausalHashId)
expectCausalHashIdByCausalHash :: CausalHash -> Transaction CausalHashId

-- | ]
expectCausalValueHashId :: CausalHashId -> Transaction BranchHashId
loadCausalByCausalHash :: CausalHash -> Transaction (Maybe (CausalHashId, BranchHashId))
expectCausalByCausalHash :: CausalHash -> Transaction (CausalHashId, BranchHashId)
loadBranchObjectIdByCausalHashId :: CausalHashId -> Transaction (Maybe BranchObjectId)
expectBranchObjectIdByCausalHashId :: CausalHashId -> Transaction BranchObjectId
saveCausalParents :: CausalHashId -> [CausalHashId] -> Transaction ()
loadCausalParents :: CausalHashId -> Transaction [CausalHashId]
before :: CausalHashId -> CausalHashId -> Transaction Bool
lca :: CausalHashId -> CausalHashId -> Transaction (Maybe CausalHashId)
saveWatch :: WatchKind -> IdH -> ByteString -> Transaction ()
loadWatch :: SqliteExceptionReason e => WatchKind -> IdH -> (ByteString -> Either e a) -> Transaction (Maybe a)
loadWatchesByWatchKind :: WatchKind -> Transaction [IdH]
loadWatchKindsByReference :: IdH -> Transaction [WatchKind]
clearWatches :: Transaction ()
addToDependentsIndex :: Reference -> Id -> Transaction ()

-- | Get non-self, user-defined dependents of a dependency.
getDependentsForDependency :: Reference -> Transaction [Id]
getDependentsForDependencyComponent :: ObjectId -> Transaction [Id]

-- | Get non-self dependencies of a user-defined dependent.
getDependenciesForDependent :: Id -> Transaction [Reference]

-- | Get non-self, user-defined dependencies of a user-defined dependent.
getDependencyIdsForDependent :: Id -> Transaction [Id]
countObjects :: Transaction Int
countCausals :: Transaction Int
countWatches :: Transaction Int

-- | Finds all causals that refer to a branch for which we don't have an
--   object stored. Although there are plans to support this in the future,
--   currently all such cases are the result of database inconsistencies
--   and are unexpected.
getCausalsWithoutBranchObjects :: Transaction [CausalHashId]

-- | Delete all hash objects of a given hash version. Leaves the
--   corresponding <tt>hash</tt>es in the hash table alone.
removeHashObjectsByHashingVersion :: HashVersion -> Transaction ()
addToTypeIndex :: Reference' TextId HashId -> Id -> Transaction ()
getReferentsByType :: Reference' TextId HashId -> Transaction [Id]
getTypeReferenceForReferent :: Id -> Transaction (Reference' TextId HashId)
getTypeReferencesForComponent :: ObjectId -> Transaction [(Reference' TextId HashId, Id)]
addToTypeMentionsIndex :: Reference' TextId HashId -> Id -> Transaction ()
getReferentsByTypeMention :: Reference' TextId HashId -> Transaction [Id]
getTypeMentionsReferencesForComponent :: ObjectId -> Transaction [(Reference' TextId HashId, Id)]
objectIdByBase32Prefix :: ObjectType -> Text -> Transaction [ObjectId]
namespaceHashIdByBase32Prefix :: Text -> Transaction [BranchHashId]
causalHashIdByBase32Prefix :: Text -> Transaction [CausalHashId]

-- | Drop and recreate the name lookup tables. Use this when resetting
--   names to a new branch.
resetNameLookupTables :: Transaction ()

-- | Insert the given set of term names into the name lookup table
insertTermNames :: [NamedRef (TextReferent, Maybe ConstructorType)] -> Transaction ()

-- | Insert the given set of type names into the name lookup table
insertTypeNames :: [NamedRef TextReference] -> Transaction ()

-- | Get the list of a term names in the root namespace according to the
--   name lookup index
rootTermNames :: Transaction [NamedRef (TextReferent, Maybe ConstructorType)]

-- | Get the list of a type names in the root namespace according to the
--   name lookup index
rootTypeNames :: Transaction [NamedRef TextReference]

-- | Delete objects without hashes. An object typically *would* have a
--   hash, but (for example) during a migration in which an object's hash
--   may change, its corresponding hash_object row may be updated to point
--   at a new version of that object. This procedure clears out all
--   references to objects that do not have any corresponding hash_object
--   rows.
garbageCollectObjectsWithoutHashes :: Transaction ()

-- | Delete all
garbageCollectWatchesWithoutObjects :: Transaction ()
createSchema :: Transaction ()
schemaVersion :: Transaction SchemaVersion

-- | Expect the given schema version.
expectSchemaVersion :: SchemaVersion -> Transaction ()
setSchemaVersion :: SchemaVersion -> Transaction ()
instance Unison.Sqlite.Exception.SqliteExceptionReason U.Codebase.Sqlite.Queries.UnexpectedSchemaVersion
instance GHC.Show.Show U.Codebase.Sqlite.Queries.UnexpectedSchemaVersion


-- | This module facilitates the creation of "localized" versions of
--   objects, suitable for storage.
--   
--   Localization is a stateful process in which the real database
--   identifiers contained within an object, e.g. <a>DbBranch</a>, are
--   canonicalized as local identifiers counting up from 0 in the order
--   they are encountered in the object. The association between real and
--   local identifier is captured in a vector, where the <tt>ith</tt> index
--   maps local identifier <tt>i</tt> to the real identifier it corresponds
--   to.
--   
--   For example, consider a branch object that refers to terms
--   <tt>#foo</tt> and <tt>#bar</tt>. In totally made-up syntax,
--   
--   <pre>
--   branch = {
--     terms = [#foo, #bar]
--   }
--   </pre>
--   
--   The localized version of this branch would be
--   
--   <pre>
--   branch = {
--     terms = [0, 1]
--   }
--   terms = [#foo, #bar]
--   </pre>
--   
--   where all terms, types, etc. within the <tt>branch</tt> structure
--   refer to offsets in the associated vectors.
module U.Codebase.Sqlite.LocalizeObject

-- | Localize a branch object.
localizeBranch :: DbBranch -> (BranchLocalIds, LocalBranch)

-- | Localize a patch object.
localizePatch :: Patch -> (PatchLocalIds, LocalPatch)

module U.Codebase.Sqlite.Symbol
data Symbol
Symbol :: !Word64 -> !Text -> Symbol
instance GHC.Show.Show U.Codebase.Sqlite.Symbol.Symbol
instance GHC.Classes.Ord U.Codebase.Sqlite.Symbol.Symbol
instance GHC.Classes.Eq U.Codebase.Sqlite.Symbol.Symbol
instance U.Core.ABT.Var.Var U.Codebase.Sqlite.Symbol.Symbol

module U.Codebase.Sqlite.Decl.Format

-- | Add new formats here
data DeclFormat
Decl :: LocallyIndexedComponent -> DeclFormat

-- | V1: Decls included <tt>Hash</tt>es inline V2: Instead of
--   <tt>Hash</tt>, we use a smaller index.
newtype LocallyIndexedComponent
LocallyIndexedComponent :: Vector (LocalIds, Decl Symbol) -> LocallyIndexedComponent
type Decl v = DeclR TypeRef v
type Type v = Term F v ()
type F = F' TypeRef
type TypeRef = Reference' LocalTextId (Maybe LocalDefnId)
instance GHC.Show.Show U.Codebase.Sqlite.Decl.Format.LocallyIndexedComponent
instance GHC.Show.Show U.Codebase.Sqlite.Decl.Format.DeclFormat

module U.Codebase.Sqlite.Term.Format

-- | <ul>
--   <li>Builtin terms are represented as local text ids.</li>
--   <li>Non-builtin terms are represented as local definition ids, with an
--   added distinguished element (here <tt>Nothing</tt>) which represents a
--   self-reference.</li>
--   </ul>
type TermRef = Reference' LocalTextId (Maybe LocalDefnId)

-- | <ul>
--   <li>Builtin types are represented as a local text id.</li>
--   <li>Non-builtin types are represented by a local definition id.</li>
--   </ul>
type TypeRef = Reference' LocalTextId LocalDefnId
type TermLink = Referent' TermRef TypeRef
type TypeLink = TypeRef

-- | A <a>LocallyIndexedComponent</a> is a vector that has one element per
--   member of the component (invariant: 1+).
--   
--   Each element is a term, which is represented as:
--   
--   <ul>
--   <li>Lookup vectors that map local ids to database ids for texts and
--   objects referenced by the term.</li>
--   <li>The term itself, with internal references to local ids (offsets
--   into the lookup vectors).</li>
--   <li>The term's type, also with internal references to local id.</li>
--   </ul>
type LocallyIndexedComponent = LocallyIndexedComponent' TextId ObjectId
newtype LocallyIndexedComponent' t d
LocallyIndexedComponent :: Vector (LocalIds' t d, Term, Type) -> LocallyIndexedComponent' t d
type F = F' LocalTextId TermRef TypeRef TermLink TypeLink Symbol
type FT = F' TypeRef
type Term = Term F Symbol ()
type Type = Term FT Symbol ()
type FTT = F' Reference
type TypeOfTerm = Term FTT Symbol ()
data TermFormat
Term :: LocallyIndexedComponent -> TermFormat
data WatchResultFormat
WatchResult :: WatchLocalIds -> Term -> WatchResultFormat
data SyncWatchResultFormat
SyncWatchResult :: WatchLocalIds -> ByteString -> SyncWatchResultFormat
instance (GHC.Show.Show t, GHC.Show.Show d) => GHC.Show.Show (U.Codebase.Sqlite.Term.Format.LocallyIndexedComponent' t d)

module U.Codebase.Sqlite.Serialization
debug :: Bool
putABT :: (MonadPut m, Foldable f, Functor f, Ord v) => (v -> m ()) -> (a -> m ()) -> (forall x. (x -> m ()) -> f x -> m ()) -> Term f v a -> m ()
getABT :: (MonadGet m, Foldable f, Functor f, Ord v) => m v -> m a -> (forall x. m x -> m (f x)) -> m (Term f v a)
putLocalIds :: (MonadPut m, Integral t, Bits t, Integral d, Bits d) => LocalIds' t d -> m ()
getLocalIds :: MonadGet m => m LocalIds
getWatchLocalIds :: MonadGet m => m WatchLocalIds
putUnit :: Applicative m => () -> m ()
getUnit :: Applicative m => m ()
putWatchResultFormat :: MonadPut m => WatchResultFormat -> m ()
getWatchResultFormat :: MonadGet m => m WatchResultFormat
putTermFormat :: MonadPut m => TermFormat -> m ()
getTermFormat :: MonadGet m => m TermFormat
putTermComponent :: MonadPut m => LocallyIndexedComponent -> m ()
putTerm :: MonadPut m => Term -> m ()
getTermComponent :: MonadGet m => m LocallyIndexedComponent
getTerm :: MonadGet m => m Term
lookupTermElement :: MonadGet m => Pos -> m (LocalIds, Term, Type)
lookupTermElementDiscardingType :: MonadGet m => Pos -> m (LocalIds, Term)
lookupTermElementDiscardingTerm :: MonadGet m => Pos -> m (LocalIds, Type)
getTType :: MonadGet m => m Type
getType :: forall m r. MonadGet m => m r -> m (TypeR r Symbol)
putDeclFormat :: MonadPut m => DeclFormat -> m ()
getDeclFormat :: MonadGet m => m DeclFormat
getDeclElement :: MonadGet m => m (Decl Symbol)
lookupDeclElement :: MonadGet m => Pos -> m (LocalIds, Decl Symbol)
putBranchFormat :: MonadPut m => BranchFormat -> m ()
putBranchLocalIds :: MonadPut m => BranchLocalIds -> m ()
putPatchFormat :: MonadPut m => PatchFormat -> m ()
getPatchFormat :: MonadGet m => m PatchFormat
getPatchLocalIds :: MonadGet m => m PatchLocalIds
putPatchFull :: MonadPut m => LocalPatch -> m ()
putPatchDiff :: MonadPut m => LocalPatchDiff -> m ()
putPatchLocalIds :: MonadPut m => PatchLocalIds -> m ()
putTermEdit :: MonadPut m => LocalTermEdit -> m ()
putTypeEdit :: MonadPut m => LocalTypeEdit -> m ()
getBranchFormat :: MonadGet m => m BranchFormat
getBranchLocalIds :: MonadGet m => m BranchLocalIds
decomposeComponent :: MonadGet m => m [(LocalIds, ByteString)]
recomposeComponent :: MonadPut m => [(LocalIds, ByteString)] -> m ()
decomposeWatchFormat :: MonadGet m => m SyncWatchResultFormat
recomposeWatchFormat :: MonadPut m => SyncWatchResultFormat -> m ()
decomposePatchFormat :: MonadGet m => m SyncPatchFormat
recomposePatchFormat :: MonadPut m => SyncPatchFormat -> m ()
decomposeBranchFormat :: MonadGet m => m SyncBranchFormat
recomposeBranchFormat :: MonadPut m => SyncBranchFormat -> m ()
getSymbol :: MonadGet m => m Symbol
putSymbol :: MonadPut m => Symbol -> m ()
putReferent :: (MonadPut m, Integral t1, Integral h1, Bits t1, Bits h1, Integral t2, Integral h2, Bits t2, Bits h2) => Referent' (Reference' t1 h1) (Reference' t2 h2) -> m ()
putReferent' :: MonadPut m => (r1 -> m ()) -> (r2 -> m ()) -> Referent' r1 r2 -> m ()
putReference :: (MonadPut m, Integral t, Bits t, Integral r, Bits r) => Reference' t r -> m ()
getReferent' :: MonadGet m => m r1 -> m r2 -> m (Referent' r1 r2)
getReferent :: (MonadGet m, Integral t1, Integral h1, Bits t1, Bits h1, Integral t2, Integral h2, Bits t2, Bits h2) => m (Referent' (Reference' t1 h1) (Reference' t2 h2))
getReference :: (MonadGet m, Integral t, Bits t, Integral r, Bits r) => m (Reference' t r)
putRecursiveReference :: (MonadPut m, Integral t, Bits t, Integral r, Bits r) => Reference' t (Maybe r) -> m ()
getRecursiveReference :: (MonadGet m, Integral t, Bits t, Integral r, Bits r) => m (Reference' t (Maybe r))
putInt :: MonadPut m => Int64 -> m ()
getInt :: MonadGet m => m Int64
putNat :: MonadPut m => Word64 -> m ()
getNat :: MonadGet m => m Word64
putFloat :: MonadPut m => Double -> m ()
getFloat :: MonadGet m => m Double
putBoolean :: MonadPut m => Bool -> m ()
getBoolean :: MonadGet m => m Bool
putTType :: MonadPut m => Type -> m ()
putDType :: MonadPut m => Type Symbol -> m ()
putType :: forall m r v. (MonadPut m, Ord v) => (r -> m ()) -> (v -> m ()) -> TypeR r v -> m ()
putChar :: MonadPut m => Char -> m ()
getChar :: MonadGet m => m Char
putMaybe :: MonadPut m => (a -> m ()) -> Maybe a -> m ()
getMaybe :: MonadGet m => m a -> m (Maybe a)
unknownTag :: (MonadGet m, Show a) => String -> a -> m x

module U.Codebase.Sqlite.Sync22
data Entity
O :: ObjectId -> Entity
C :: CausalHashId -> Entity
W :: WatchKind -> IdH -> Entity
data DecodeError
ErrTermComponent :: DecodeError
ErrDeclComponent :: DecodeError
ErrBranchFormat :: DecodeError
ErrPatchFormat :: DecodeError
ErrWatchResult :: DecodeError
type ErrString = String
data Error
DecodeError :: DecodeError -> ByteString -> ErrString -> Error

-- | hashes corresponding to a single object in source codebase correspond
--   to multiple objects in destination codebase
HashObjectCorrespondence :: ObjectId -> [HashId] -> [HashId] -> [ObjectId] -> Error
SourceDbNotExist :: Error
data Env m
Env :: (forall a. Transaction a -> m a) -> (forall a. Transaction a -> m a) -> Word -> Env m
[runSrc] :: Env m -> forall a. Transaction a -> m a
[runDest] :: Env m -> forall a. Transaction a -> m a

-- | there are three caches of this size
[idCacheSize] :: Env m -> Word
hoistEnv :: (forall x. m x -> n x) -> Env m -> Env n
debug :: Bool
sync22 :: (MonadIO m, MonadError Error m) => Env m -> IO (Sync m Entity)
trySync :: forall m. (MonadIO m, MonadError Error m) => (forall a. Transaction a -> m a) -> (forall a. Transaction a -> m a) -> Cache TextId TextId -> Cache HashId HashId -> Cache ObjectId ObjectId -> Cache CausalHashId CausalHashId -> Entity -> m (TrySyncResult Entity)
instance GHC.Show.Show U.Codebase.Sqlite.Sync22.Entity
instance GHC.Classes.Ord U.Codebase.Sqlite.Sync22.Entity
instance GHC.Classes.Eq U.Codebase.Sqlite.Sync22.Entity
instance GHC.Show.Show U.Codebase.Sqlite.Sync22.DecodeError
instance GHC.Show.Show U.Codebase.Sqlite.Sync22.Error

module U.Codebase.Sqlite.Operations
saveRootBranch :: CausalBranch Transaction -> Transaction (BranchObjectId, CausalHashId)
loadRootCausalHash :: Transaction (Maybe CausalHash)
expectRootCausalHash :: Transaction CausalHash
expectRootCausal :: Transaction (CausalBranch Transaction)
saveBranch :: CausalBranch Transaction -> Transaction (BranchObjectId, CausalHashId)
loadCausalBranchByCausalHash :: CausalHash -> Transaction (Maybe (CausalBranch Transaction))
expectCausalBranchByCausalHash :: CausalHash -> Transaction (CausalBranch Transaction)
saveTermComponent :: Hash -> [(Term Symbol, Type Symbol)] -> Transaction ObjectId
loadTermComponent :: Hash -> MaybeT Transaction [(Term Symbol, Type Symbol)]
loadTermByReference :: Id -> MaybeT Transaction (Term Symbol)
loadTypeOfTermByTermReference :: Id -> MaybeT Transaction (Type Symbol)
saveDeclComponent :: Hash -> [Decl Symbol] -> Transaction ObjectId
loadDeclComponent :: Hash -> MaybeT Transaction [Decl Symbol]
loadDeclByReference :: Id -> MaybeT Transaction (Decl Symbol)

-- | Get the <a>DeclType</a> of a <a>Id</a>.
expectDeclTypeById :: Id -> Transaction DeclType
getCycleLen :: Hash -> Transaction (Maybe Word64)
savePatch :: PatchHash -> Patch -> Transaction PatchObjectId
expectPatch :: PatchObjectId -> Transaction Patch
objectExistsForHash :: Hash -> Transaction Bool
saveWatch :: WatchKind -> Id -> Term Symbol -> Transaction ()

-- | returns Nothing if the expression isn't cached.
loadWatch :: WatchKind -> Id -> MaybeT Transaction (Term Symbol)
listWatches :: WatchKind -> Transaction [Id]
clearWatches :: Transaction ()
before :: CausalHash -> CausalHash -> Transaction (Maybe Bool)
lca :: CausalHash -> CausalHash -> Transaction (Maybe CausalHash)
componentReferencesByPrefix :: ObjectType -> Text -> Maybe Pos -> Transaction [Id]
termReferentsByPrefix :: Text -> Maybe Word64 -> Transaction [Id]
declReferentsByPrefix :: Text -> Maybe Pos -> Maybe ConstructorId -> Transaction [(Hash, Pos, DeclType, [ConstructorId])]
causalHashesByPrefix :: ShortBranchHash -> Transaction (Set CausalHash)

-- | returns a list of known definitions referencing <tt>r</tt>
dependents :: Reference -> Transaction (Set Id)

-- | returns a list of known definitions referencing <tt>h</tt>
dependentsOfComponent :: Hash -> Transaction (Set Id)
addTypeToIndexForTerm :: Id -> Reference -> Transaction ()
termsHavingType :: Reference -> Transaction (Set Id)
addTypeMentionsToIndexForTerm :: Id -> Set Reference -> Transaction ()
termsMentioningType :: Reference -> Transaction (Set Id)

-- | Given the list of term and type names from the root branch, rebuild
--   the name lookup table.
rebuildNameIndex :: [NamedRef (Referent, Maybe ConstructorType)] -> [NamedRef Reference] -> Transaction ()

-- | Get all the term and type names for the root namespace from the lookup
--   table.
rootBranchNames :: Transaction ([NamedRef (Referent, Maybe ConstructorType)], [NamedRef Reference])
expectDbBranch :: BranchObjectId -> Transaction DbBranch
expectDbPatch :: PatchObjectId -> Transaction Patch
saveBranchObject :: BranchHashId -> BranchLocalIds -> LocalBranch -> Transaction BranchObjectId
saveDbPatch :: PatchHash -> PatchFormat -> Transaction PatchObjectId
c2sReferenceId :: Id -> Transaction Id
c2sReferentId :: Id -> Transaction Id

-- | produces a diff diff = full - ref; full = diff + ref
diffPatch :: LocalPatch -> LocalPatch -> LocalPatchDiff
decodeTermElementWithType :: Pos -> ByteString -> Either DecodeError (LocalIds, Term, Type)
loadTermWithTypeByReference :: Id -> MaybeT Transaction (Term Symbol, Type Symbol)
s2cTermWithType :: LocalIds -> Term -> Type -> Transaction (Term Symbol, Type Symbol)
declReferencesByPrefix :: Text -> Maybe Word64 -> Transaction [Id]
branchHashesByPrefix :: ShortBranchHash -> Transaction (Set BranchHash)

-- | returns empty set for unknown inputs; doesn't distinguish between term
--   and decl
derivedDependencies :: Id -> Transaction (Set Id)
instance Unison.Sqlite.Exception.SqliteExceptionReason U.Codebase.Sqlite.Operations.DecodeError
instance GHC.Show.Show U.Codebase.Sqlite.Operations.DecodeError
instance Unison.Sqlite.Exception.SqliteExceptionReason U.Codebase.Sqlite.Operations.NeedTypeForBuiltinMetadata
instance GHC.Show.Show U.Codebase.Sqlite.Operations.NeedTypeForBuiltinMetadata
