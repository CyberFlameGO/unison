<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Optics.Label</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">optics-core-0.3.0.1: Optics as an abstract interface: core definitions</span><ul class="links" id="page-menu"><li><a href="src/Optics.Label.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Optics.Label</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">How to use labels as optics to make working with Haskell's records more convenient</a><ul><li><a href="#g:2">The problem</a></li><li><a href="#g:3">The solution</a></li><li><a href="#g:4">The result</a></li></ul></li><li><a href="#g:5">Sample usage</a></li><li><a href="#g:6">Technical details</a><ul><li><a href="#g:7"><code>LabelOptic</code> type class</a></li><li><a href="#g:8">Structure of <code>LabelOptic</code> instances</a></li><li><a href="#g:9">Limitations arising from functional dependencies</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Overloaded labels are a solution to Haskell's namespace problem for records.
 The <code>-XOverloadedLabels</code> extension allows a new expression syntax for labels,
 a prefix <code>#</code> sign followed by an identifier, e.g. <code>#foo</code>.  These expressions
 can then be given an interpretation that depends on the type at which they
 are used and the text of the label.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="#t:LabelOptic">LabelOptic</a> (name :: <a href="../base-4.14.3.0/GHC-TypeLits.html#t:Symbol" title="GHC.TypeLits">Symbol</a>) k s t a b | name s -&gt; k a, name t -&gt; k b, name s b -&gt; t, name t a -&gt; s <span class="keyword">where</span><ul class="subs"><li><a href="#v:labelOptic">labelOptic</a> :: <a href="Optics-Optic.html#t:Optic" title="Optics.Optic">Optic</a> k <a href="Optics-Optic.html#t:NoIx" title="Optics.Optic">NoIx</a> s t a b</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:LabelOptic-39-">LabelOptic'</a> name k s a = <a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a> name k s s a a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>How to use labels as optics to make working with Haskell's records more convenient</h1></a><a href="#g:2" id="g:2"><h2>The problem</h2></a><div class="doc"><p>Standard Haskell records are a common source of frustration amongst seasoned
 Haskell programmers. Their main issues are:</p><ol><li>Inability to define multiple data types sharing field names in the same
     module.</li><li>Pollution of global namespace as every field accessor is also a top-level
     function.</li><li>Clunky update syntax, especially when nested fields get involved.</li></ol><p>Over the years multiple language extensions were proposed and implemented to
 alleviate these issues. We're quite close to having a reasonable solution
 with the following trifecta:</p><ul><li><code><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DuplicateRecordFields">DuplicateRecordFields</a></code> - introduced in GHC 8.0.1, addresses (1)</li><li><code><a href="https://github.com/ghc-proposals/ghc-proposals/pull/160">NoFieldSelectors</a></code> - accepted GHC proposal, addresses (2)</li><li><code><a href="https://github.com/ghc-proposals/ghc-proposals/pull/282">RecordDotSyntax</a></code> - accepted GHC proposal, addresses (3)</li></ul><p>It needs to be noted however that both <code>NoFieldSelectors</code> and
 <code>RecordDotSyntax</code> are not yet implemented, with the latter depending on
 adding <code>setField</code> to <code>HasField</code>
 (<a href="https://gitlab.haskell.org/ghc/ghc/issues/16232">ghc/16232</a>), not yet
 merged.</p><p>Is there no hope then for people who would like to work with records in a
 reasonable way without waiting for these extensions? Not necessarily, as by
 following a couple of simple patterns we can get pretty much the same (and
 more) features with labels as optics, just with a slightly more verbose
 syntax.</p></div><a href="#g:3" id="g:3"><h2>The solution</h2></a><div class="doc"><h3>Prefixless fields with <code>DuplicateRecordFields</code></h3><p>We necessarily want field names to be prefixless, i.e. <code>field</code> to be a field
 name and <code>#field</code> to be an overloaded label that becomes an optic refering to
 this field in the appropriate context.  With this approach we get working
 autocompletion and jump-to-definition in editors supporting <code>ctags</code>/<code>etags</code>
 in combination with <code><a href="https://hackage.haskell.org/package/hasktags">hasktags</a></code>,
 both of which (especially the latter) are very important for developer's
 productivity in real-world code bases.</p><p>Let's look at data types defined with this approach in mind:</p><pre>{-# LANGUAGE DuplicateRecordFields #-}

import Data.Time

data User = User { id     :: Int
                 , name   :: String
                 , joined :: UTCTime
                 , movies :: [Movie]
                 }

data Movie = Movie { id          :: Int
                   , name        :: String
                   , releaseDate :: UTCTime
                   }
</pre><p>Then appropriate <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> instances can be either written by hand or
 generated using Template Haskell functions (defined in
 <code><a href="https://hackage.haskell.org/package/optics-th/docs/Optics-TH.html">Optics.TH</a></code>
 module from <code><a href="https://hackage.haskell.org/package/optics-th">optics-th</a></code> package)
 with</p><pre>makeFieldLabelsWith noPrefixFieldLabels ''User
makeFieldLabelsWith noPrefixFieldLabels ''Movie
</pre><p><em>Note:</em> there exists a similar approach that involves prefixing field names
 with the underscore and generation of lenses as ordinary functions so that
 <code>_field</code> is the ordinary field name and <code>field</code> is the lens referencing
 it. The drawback of such solution is inability to get working
 jump-to-definition for field names, which makes navigation in unfamiliar code
 bases significantly harder, so it's not recommended.</p><h3>Emulation of <code>NoFieldSelectors</code></h3><p>Prefixless fields (especially ones with common names such as <code>id</code> or <code>name</code>)
 leak into global namespace as accessor functions and can generate a lot of
 name clashes. Before <code>NoFieldSelectors</code> is available, this can be alleviated by
 splitting modules defining types into two, namely:</p><ol><li>A private one that exports full type definitions, i.e. with their fields
     and constructors.</li><li>A public one that exports only constructors (or no constructors at all if
     the data type in question is opaque).</li></ol><p>There is no notion of private and public modules within a single cabal
 target, but we can hint at it e.g. by naming the public module <code>T</code> and
 private <code>T.Internal</code>.</p><p>An example:</p><p>Private module:</p><pre>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}
module User.Internal (User(..)) where

import Optics.TH

data User = User { id   :: Int
                 , name :: String
                 }

makeFieldLabelsWith noPrefixFieldLabels ''User

...
</pre><p>Public module:</p><pre>module User (User(User)) where

import User.Internal

...
</pre><p>Then, whenever we're dealing with a value of type <code>User</code> and want to read or
 modify its fields, we can use corresponding labels without having to import
 <code>User.Internal</code>. Importing <code>User</code> is enough because it provides appropriate
 <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> instances through <code>User.Internal</code> which enables labels to be
 interpreted as optics in the appropriate context.</p><p><em>Note:</em> if you plan to completely hide (some of) the fields of a data type,
 you need to skip defining the corresponding <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> instances for them
 (in case you want fields to be read only, you can make the optic kind of the
 coresponding <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> <code><a href="Optics-Getter.html#t:A_Getter" title="Optics.Getter">A_Getter</a></code> instead of <code><a href="Optics-IxLens.html#t:A_Lens" title="Optics.IxLens">A_Lens</a></code>). It's because
 Haskell makes it impossible to selectively hide instances, so once a
 <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> instance is defined, it'll always be possible to use a label
 that desugars to its usage whenever a module with its definition is
 (transitively) imported.</p><pre>{-# LANGUAGE OverloadedLabels #-}

import Optics
import User

greetUser :: User -&gt; String
greetUser user = &quot;Hello &quot; ++ user ^. #name ++ &quot;!&quot;

addSurname :: String -&gt; User -&gt; User
addSurname surname user = user &amp; #name %~ (++ &quot; &quot; ++ surname)
</pre><p>But what if we want to create a new <code>User</code> with the record syntax? Importing
 <code>User</code> module is not sufficient since it doesn't export <code>User</code>'s
 fields. However, if we import <code>User.Internal</code> <em>fully qualified</em> and make use
 of the fact that field names used within the record syntax don't have to be
 prefixed when <code>DisambiguateRecordFields</code> language extension is enabled, it
 works out:</p><pre>{-# LANGUAGE DisambiguateRecordFields #-}

import User
import qualified User.Internal

newUser :: User
newUser = User { id   = 1     -- not User.Internal.id
               , name = &quot;Ian&quot; -- not User.Internal.name
               }
</pre><p>This way top-level field accessor functions stay in their own qualified
 namespace and don't generate name clashes, yet they can be used without
 prefix within the record syntax.</p></div><a href="#g:4" id="g:4"><h2>The result</h2></a><div class="doc"><p>When we follow the above conventions for data types in our application, we
 get:</p><ol><li>Prefixless field names that don't pollute global namespace (with the
     internal module qualification trick).</li><li>Working tags based jump-to-definition for field names (as <code>field</code> is the
     ordinary field, whereas <code>#field</code> is the lens referencing it).</li><li>The full power of optics at our disposal, should we ever need it.</li></ol></div><a href="#g:5" id="g:5"><h1>Sample usage</h1></a><div class="doc"><p><a id="usage"></a>
 An example showing how overloaded labels can be used as optics.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XDataKinds
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XDuplicateRecordFields
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XFlexibleInstances
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XMultiParamTypeClasses
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedLabels
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XTypeFamilies
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XUndecidableInstances
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>data Human = Human
  { name :: String
  , age  :: Integer
  , pets :: [Pet]
  } deriving Show
data Pet
  = Cat  { name :: String, age :: Int, lazy :: Bool }
  | Fish { name :: String, age :: Int }
  deriving Show
:}
</pre><p>The following instances can be generated by <code>makeFieldLabelsWith
 noPrefixFieldLabels</code> from
 <code><a href="https://hackage.haskell.org/package/optics-th/docs/Optics-TH.html">Optics.TH</a></code>
 in the <code><a href="https://hackage.haskell.org/package/optics-th">optics-th</a></code> package:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>instance (k ~ A_Lens, a ~ String, b ~ String) =&gt; LabelOptic &quot;name&quot; k Human Human a b where
  labelOptic = lensVL $ \f (Human name age pets) -&gt; (\name' -&gt; Human name' age pets) &lt;$&gt; f name
instance (k ~ A_Lens, a ~ Integer, b ~ Integer) =&gt; LabelOptic &quot;age&quot; k Human Human a b where
  labelOptic = lensVL $ \f (Human name age pets) -&gt; (\age' -&gt; Human name age' pets) &lt;$&gt; f age
instance (k ~ A_Lens, a ~ [Pet], b ~ [Pet]) =&gt; LabelOptic &quot;pets&quot; k Human Human a b where
  labelOptic = lensVL $ \f (Human name age pets) -&gt; (\pets' -&gt; Human name age pets') &lt;$&gt; f pets
instance (k ~ A_Lens, a ~ String, b ~ String) =&gt; LabelOptic &quot;name&quot; k Pet Pet a b where
  labelOptic = lensVL $ \f s -&gt; case s of
    Cat  name age lazy -&gt; (\name' -&gt; Cat  name' age lazy) &lt;$&gt; f name
    Fish name age      -&gt; (\name' -&gt; Fish name' age     ) &lt;$&gt; f name
instance (k ~ A_Lens, a ~ Int, b ~ Int) =&gt; LabelOptic &quot;age&quot; k Pet Pet a b where
  labelOptic = lensVL $ \f s -&gt; case s of
    Cat  name age lazy -&gt; (\age' -&gt; Cat  name age' lazy) &lt;$&gt; f age
    Fish name age      -&gt; (\age' -&gt; Fish name age'     ) &lt;$&gt; f age
instance (k ~ An_AffineTraversal, a ~ Bool, b ~ Bool) =&gt; LabelOptic &quot;lazy&quot; k Pet Pet a b where
  labelOptic = atraversalVL $ \point f s -&gt; case s of
    Cat name age lazy -&gt; (\lazy' -&gt; Cat name age lazy') &lt;$&gt; f lazy
    _                 -&gt; point s
:}
</pre><p>Here is some test data:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>peter :: Human
peter = Human { name = &quot;Peter&quot;
              , age  = 13
              , pets = [ Fish { name = &quot;Goldie&quot;
                              , age  = 1
                              }
                       , Cat { name = &quot;Loopy&quot;
                             , age  = 3
                             , lazy = False
                             }
                       , Cat { name = &quot;Sparky&quot;
                             , age  = 2
                             , lazy = True
                             }
                       ]
             }
:}
</pre><p>Now we can ask for Peter's name:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>view #name peter
</code></strong>&quot;Peter&quot;
</pre><p>or for names of his pets:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toListOf (#pets % folded % #name) peter
</code></strong>[&quot;Goldie&quot;,&quot;Loopy&quot;,&quot;Sparky&quot;]
</pre><p>We can check whether any of his pets is lazy:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>orOf (#pets % folded % #lazy) peter
</code></strong>True
</pre><p>or how things might be be a year from now:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>peter &amp; over #age (+1) &amp; over (#pets % mapped % #age) (+1)
</code></strong>Human {name = &quot;Peter&quot;, age = 14, pets = [Fish {name = &quot;Goldie&quot;, age = 2},Cat {name = &quot;Loopy&quot;, age = 4, lazy = False},Cat {name = &quot;Sparky&quot;, age = 3, lazy = True}]}
</pre><p>Perhaps Peter is going on vacation and needs to leave his pets at home:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>peter &amp; set #pets []
</code></strong>Human {name = &quot;Peter&quot;, age = 13, pets = []}
</pre></div><a href="#g:6" id="g:6"><h1>Technical details</h1></a><a href="#g:7" id="g:7"><h2><code>LabelOptic</code> type class</h2></a><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:LabelOptic" class="def">LabelOptic</a> (name :: <a href="../base-4.14.3.0/GHC-TypeLits.html#t:Symbol" title="GHC.TypeLits">Symbol</a>) k s t a b | name s -&gt; k a, name t -&gt; k b, name s b -&gt; t, name t a -&gt; s <span class="keyword">where</span> <a href="src/Optics.Internal.Optic.html#LabelOptic" class="link">Source</a> <a href="#t:LabelOptic" class="selflink">#</a></p><div class="doc"><p>Support for overloaded labels as optics. An overloaded label <code>#foo</code> can be
 used as an optic if there is an instance of <code><code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> &quot;foo&quot; k s t a b</code>.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:labelOptic" class="def">labelOptic</a> :: <a href="Optics-Optic.html#t:Optic" title="Optics.Optic">Optic</a> k <a href="Optics-Optic.html#t:NoIx" title="Optics.Optic">NoIx</a> s t a b <a href="src/Optics.Internal.Optic.html#labelOptic" class="link">Source</a> <a href="#v:labelOptic" class="selflink">#</a></p><div class="doc"><p>Used to interpret overloaded label syntax.  An overloaded label <code>#foo</code>
 corresponds to <code><code><a href="Optics-Label.html#v:labelOptic" title="Optics.Label">labelOptic</a></code> @&quot;foo&quot;</code>.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:LabelOptic">Instances</h4><details id="i:LabelOptic" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:LabelOptic:LabelOptic:1"></span> (<a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a> name k s t a b, <a href="Optics-Internal-Optic.html#t:GeneralLabelOptic" title="Optics.Internal.Optic">GeneralLabelOptic</a> name k s t a b (<a href="Optics-Internal-Optic-TypeLevel.html#t:AnyHasRep" title="Optics.Internal.Optic.TypeLevel">AnyHasRep</a> (<a href="../base-4.14.3.0/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> s) (<a href="../base-4.14.3.0/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> t))) =&gt; <a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a> name k s t a b</span> <a href="src/Optics.Internal.Optic.html#line-249" class="link">Source</a> <a href="#t:LabelOptic" class="selflink">#</a></td><td class="doc"><p>If no instance matches, fall back on <code><a href="Optics-Internal-Optic.html#t:GeneralLabelOptic" title="Optics.Internal.Optic">GeneralLabelOptic</a></code>.</p></td></tr><tr><td colspan="2"><details id="i:ic:LabelOptic:LabelOptic:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Optics-Internal-Optic.html">Optics.Internal.Optic</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:labelOptic">labelOptic</a> :: <a href="Optics-Optic.html#t:Optic" title="Optics.Optic">Optic</a> k <a href="Optics-Optic.html#t:NoIx" title="Optics.Optic">NoIx</a> s t a b <a href="src/Optics.Internal.Optic.html#labelOptic" class="link">Source</a> <a href="#v:labelOptic" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:LabelOptic-39-" class="def">LabelOptic'</a> name k s a = <a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a> name k s s a a <a href="src/Optics.Internal.Optic.html#LabelOptic%27" class="link">Source</a> <a href="#t:LabelOptic-39-" class="selflink">#</a></p><div class="doc"><p>Type synonym for a type-preserving optic as overloaded label.</p></div></div><a href="#g:8" id="g:8"><h2>Structure of <code>LabelOptic</code> instances</h2></a><div class="doc"><p>You might wonder why instances above are written in form</p><pre>instance (k ~ A_Lens, a ~ [Pet], b ~ [Pet]) =&gt; LabelOptic &quot;pets&quot; k Human Human a b where
</pre><p>instead of</p><pre>instance LabelOptic &quot;pets&quot; A_Lens Human Human [Pet] [Pet] where
</pre><p>The reason is that using the first form ensures that it is enough for GHC to
 match on the instance if either <code>s</code> or <code>t</code> is known (as type equalities are
 verified after the instance matches), which not only makes type inference
 better, but also allows it to generate better error messages.</p><p>For example, if you try to write <code>peter &amp; set #pets []</code> with the appropriate
 <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> instance in the second form, you get the following:</p><pre><a href="interactive">interactive</a>:16:1: error:
   &#8226; No instance for LabelOptic &quot;pets&quot; &#8216;A_Lens&#8217; &#8216;Human&#8217; &#8216;()&#8217; &#8216;[Pet]&#8217; &#8216;[a0]&#8217;
       (maybe you forgot to define it or misspelled a name?)
   &#8226; In the first argument of &#8216;print&#8217;, namely &#8216;it&#8217;
     In a stmt of an interactive GHCi command: print it
</pre><p>That's because empty list doesn't have type <code>[Pet]</code>, it has type <code>[r]</code> and
 GHC doesn't have enough information to match on the instance we
 provided. We'd need to either annotate the list: <code>peter &amp; set #pets
 ([]::[Pet])</code> or the result type: <code>peter &amp; set #pets [] :: Human</code>, which is
 suboptimal.</p><p>Here are more examples of confusing error messages if the instance for
 <code>LabelOptic &quot;age&quot;</code> is written without type equalities:</p><pre>&#955;&gt; view #age peter :: Char

<a href="interactive">interactive</a>:28:6: error:
    &#8226; No instance for LabelOptic &quot;age&quot; &#8216;k0&#8217; &#8216;Human&#8217; &#8216;Human&#8217; &#8216;Char&#8217; &#8216;Char&#8217;
        (maybe you forgot to define it or misspelled a name?)
    &#8226; In the first argument of &#8216;view&#8217;, namely &#8216;#age&#8217;
      In the expression: view #age peter :: Char
      In an equation for &#8216;it&#8217;: it = view #age peter :: Char
&#955;&gt; peter &amp; set #age &quot;hi&quot;

<a href="interactive">interactive</a>:29:1: error:
    &#8226; No instance for LabelOptic &quot;age&quot; &#8216;k&#8217; &#8216;Human&#8217; &#8216;b&#8217; &#8216;a&#8217; &#8216;[Char]&#8217;
        (maybe you forgot to define it or misspelled a name?)
    &#8226; When checking the inferred type
        it :: forall k b a. ((TypeError ...), Is k A_Setter) =&gt; b

&#955;&gt; age = #age :: Iso' Human Int

<a href="interactive">interactive</a>:7:7: error:
    &#8226; No instance for LabelOptic &quot;age&quot; &#8216;An_Iso&#8217; &#8216;Human&#8217; &#8216;Human&#8217; &#8216;Int&#8217; &#8216;Int&#8217;
        (maybe you forgot to define it or misspelled a name?)
    &#8226; In the expression: #age :: Iso' Human Int
      In an equation for &#8216;age&#8217;: age = #age :: Iso' Human Int
</pre><p>If we use the first form, error messages become more accurate:</p><pre>&#955;&gt; view #age peter :: Char
<a href="interactive">interactive</a>:31:6: error:
    &#8226; Couldn't match type &#8216;Char&#8217; with &#8216;Integer&#8217;
        arising from the overloaded label &#8216;#age&#8217;
    &#8226; In the first argument of &#8216;view&#8217;, namely &#8216;#age&#8217;
      In the expression: view #age peter :: Char
      In an equation for &#8216;it&#8217;: it = view #age peter :: Char
&#955;&gt; peter &amp; set #age &quot;hi&quot;

<a href="interactive">interactive</a>:32:13: error:
    &#8226; Couldn't match type &#8216;[Char]&#8217; with &#8216;Integer&#8217;
        arising from the overloaded label &#8216;#age&#8217;
    &#8226; In the first argument of &#8216;set&#8217;, namely &#8216;#age&#8217;
      In the second argument of &#8216;(&amp;)&#8217;, namely &#8216;set #age &quot;hi&quot;&#8217;
      In the expression: peter &amp; set #age &quot;hi&quot;
&#955;&gt; age = #age :: Iso' Human Int

<a href="interactive">interactive</a>:9:7: error:
    &#8226; Couldn't match type &#8216;An_Iso&#8217; with &#8216;A_Lens&#8217;
        arising from the overloaded label &#8216;#age&#8217;
    &#8226; In the expression: #age :: Iso' Human Int
      In an equation for &#8216;age&#8217;: age = #age :: Iso' Human Int
</pre></div><a href="#g:9" id="g:9"><h2>Limitations arising from functional dependencies</h2></a><div class="doc"><p><a id="limitations"></a></p><p><code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> uses the following functional dependencies to guarantee good
 type inference:</p><ol><li><code>name s -&gt; k a</code> (the optic for the field <code>name</code> in <code>s</code> is of type <code>k</code> and
 focuses on <code>a</code>)</li><li><code>name t -&gt; k b</code> (the optic for the field <code>name</code> in <code>t</code> is of type <code>k</code> and
 focuses on <code>b</code>)</li><li><code>name s b -&gt; t</code> (replacing the field <code>name</code> in <code>s</code> with <code>b</code> yields <code>t</code>)</li><li><code>name t a -&gt; s</code> (replacing the field <code>name</code> in <code>t</code> with <code>a</code> yields <code>s</code>)</li></ol><p>Dependencies (1) and (2) ensure that when we compose two optics, the middle
 type is unambiguous. The consequence is that it's not possible to create
 label optics with <code>a</code> or <code>b</code> referencing type variables not referenced in <code>s</code>
 or <code>t</code>, i.e. getters for fields of rank 2 type or reviews for constructors
 with existentially quantified types inside.</p><p>Dependencies (3) and (4) ensure that when we perform a chain of updates, the
 middle type is unambiguous. The consequence is that it's not possible to
 define label optics that:</p><ul><li>Modify phantom type parameters of type <code>s</code> or <code>t</code>.</li><li>Modify type parameters of type <code>s</code> or <code>t</code> if <code>a</code> or <code>b</code> contain ambiguous
   applications of type families to these type parameters.</li></ul></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>