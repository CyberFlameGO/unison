-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-codebase
@version 0.0.0

module U.Codebase.Causal
data Causal m hc he e
Causal :: hc -> he -> Map hc (m (Causal m hc he e)) -> m e -> Causal m hc he e
[causalHash] :: Causal m hc he e -> hc
[valueHash] :: Causal m hc he e -> he
[parents] :: Causal m hc he e -> Map hc (m (Causal m hc he e))
[value] :: Causal m hc he e -> m e

module U.Codebase.HashTags
newtype BranchHash
BranchHash :: Hash -> BranchHash
[unBranchHash] :: BranchHash -> Hash
newtype CausalHash
CausalHash :: Hash -> CausalHash
[unCausalHash] :: CausalHash -> Hash
newtype EditHash
EditHash :: Hash -> EditHash
[unEditHash] :: EditHash -> Hash
newtype PatchHash
PatchHash :: Hash -> PatchHash
[unPatchHash] :: PatchHash -> Hash
newtype DefnHash
DefnHash :: Hash -> DefnHash
[unDefnHash] :: DefnHash -> Hash
instance GHC.Classes.Ord U.Codebase.HashTags.BranchHash
instance GHC.Classes.Eq U.Codebase.HashTags.BranchHash
instance GHC.Classes.Ord U.Codebase.HashTags.CausalHash
instance GHC.Classes.Eq U.Codebase.HashTags.CausalHash
instance GHC.Classes.Ord U.Codebase.HashTags.EditHash
instance GHC.Classes.Eq U.Codebase.HashTags.EditHash
instance GHC.Classes.Ord U.Codebase.HashTags.PatchHash
instance GHC.Classes.Eq U.Codebase.HashTags.PatchHash
instance GHC.Classes.Ord U.Codebase.HashTags.DefnHash
instance GHC.Classes.Eq U.Codebase.HashTags.DefnHash
instance GHC.Show.Show U.Codebase.HashTags.DefnHash
instance GHC.Show.Show U.Codebase.HashTags.PatchHash
instance GHC.Show.Show U.Codebase.HashTags.EditHash
instance GHC.Show.Show U.Codebase.HashTags.CausalHash
instance GHC.Show.Show U.Codebase.HashTags.BranchHash

module U.Codebase.Kind
data Kind
Star :: Kind
Arrow :: Kind -> Kind -> Kind
instance GHC.Show.Show U.Codebase.Kind.Kind
instance GHC.Read.Read U.Codebase.Kind.Kind
instance GHC.Classes.Ord U.Codebase.Kind.Kind
instance GHC.Classes.Eq U.Codebase.Kind.Kind

module U.Codebase.Reference

-- | This is the canonical representation of Reference
type Reference = Reference' Text Hash
type Id = Id' Hash
data Reference' t h
ReferenceBuiltin :: t -> Reference' t h
ReferenceDerived :: Id' h -> Reference' t h
pattern Derived :: h -> Pos -> Reference' t h
type Pos = Word64
data Id' h
Id :: h -> Pos -> Id' h
t :: Traversal (Reference' t h) (Reference' t' h) t t'
h :: Traversal (Reference' t h) (Reference' t h') h h'
idH :: Lens (Id' h) (Id' h') h h'
instance Data.Traversable.Traversable U.Codebase.Reference.Id'
instance Data.Foldable.Foldable U.Codebase.Reference.Id'
instance GHC.Base.Functor U.Codebase.Reference.Id'
instance GHC.Show.Show h => GHC.Show.Show (U.Codebase.Reference.Id' h)
instance GHC.Classes.Ord h => GHC.Classes.Ord (U.Codebase.Reference.Id' h)
instance GHC.Classes.Eq h => GHC.Classes.Eq (U.Codebase.Reference.Id' h)
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Reference.Reference' t h)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h) => GHC.Classes.Ord (U.Codebase.Reference.Reference' t h)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h) => GHC.Classes.Eq (U.Codebase.Reference.Reference' t h)
instance Data.Bifunctor.Bifunctor U.Codebase.Reference.Reference'
instance Data.Bifoldable.Bifoldable U.Codebase.Reference.Reference'
instance Data.Bitraversable.Bitraversable U.Codebase.Reference.Reference'

module U.Codebase.Reflog
data Entry
Entry :: BranchHash -> BranchHash -> Text -> Entry
[from] :: Entry -> BranchHash
[to] :: Entry -> BranchHash
[reason] :: Entry -> Text

module U.Codebase.ShortHash
data ShortHash
Builtin :: Text -> ShortHash
ShortHash :: Text -> Maybe Word64 -> Maybe Word64 -> ShortHash
[prefix] :: ShortHash -> Text
[cycle] :: ShortHash -> Maybe Word64
[cid] :: ShortHash -> Maybe Word64
data ShortBranchHash
ShortBranchHash :: Text -> ShortBranchHash
[toText] :: ShortBranchHash -> Text
instance GHC.Show.Show U.Codebase.ShortHash.ShortHash
instance GHC.Classes.Ord U.Codebase.ShortHash.ShortHash
instance GHC.Classes.Eq U.Codebase.ShortHash.ShortHash
instance GHC.Show.Show U.Codebase.ShortHash.ShortBranchHash
instance GHC.Classes.Ord U.Codebase.ShortHash.ShortBranchHash
instance GHC.Classes.Eq U.Codebase.ShortHash.ShortBranchHash

module U.Codebase.Type

-- | For standalone types, like those in Term.Ann
type FT = F' Reference

-- | For potentially recursive types, like those in DataDeclaration
type FD = F' (Reference' Text (Maybe Hash))
data F' r a
Ref :: r -> F' r a
Arrow :: a -> a -> F' r a
Ann :: a -> Kind -> F' r a
App :: a -> a -> F' r a
Effect :: a -> a -> F' r a
Effects :: [a] -> F' r a
Forall :: a -> F' r a
IntroOuter :: a -> F' r a

-- | Non-recursive type
type TypeT v = Term FT v ()

-- | Potentially-recursive type
type TypeD v = Term FD v ()
type TypeR r v = Term (F' r) v ()
rmap :: Ord v => (r -> r') -> Term (F' r) v a -> Term (F' r') v a
typeD2T :: Ord v => Hash -> TypeD v -> TypeT v
dependencies :: (Ord v, Ord r) => Term (F' r) v a -> Set r
instance Data.Traversable.Traversable (U.Codebase.Type.F' r)
instance (GHC.Show.Show r, GHC.Show.Show a) => GHC.Show.Show (U.Codebase.Type.F' r a)
instance (GHC.Classes.Ord r, GHC.Classes.Ord a) => GHC.Classes.Ord (U.Codebase.Type.F' r a)
instance (GHC.Classes.Eq r, GHC.Classes.Eq a) => GHC.Classes.Eq (U.Codebase.Type.F' r a)
instance GHC.Base.Functor (U.Codebase.Type.F' r)
instance Data.Foldable.Foldable (U.Codebase.Type.F' r)

module U.Codebase.Decl
type ConstructorId = Word64
data DeclType
Data :: DeclType
Effect :: DeclType
type Decl v = DeclR TypeRef v
type TypeRef = Reference' Text (Maybe Hash)
type Type v = TypeR TypeRef v
data Modifier
Structural :: Modifier
Unique :: Text -> Modifier
data DeclR r v
DataDeclaration :: DeclType -> Modifier -> [v] -> [TypeR r v] -> DeclR r v
[declType] :: DeclR r v -> DeclType
[modifier] :: DeclR r v -> Modifier
[bound] :: DeclR r v -> [v]
[constructorTypes] :: DeclR r v -> [TypeR r v]
dependencies :: (Ord r, Ord v) => DeclR r v -> Set r
data V v
Bound :: v -> V v
Ctor :: Int -> V v
data F a
Type :: FD a -> F a
LetRec :: [a] -> a -> F a
Constructors :: [a] -> F a
Modified :: DeclType -> Modifier -> a -> F a
instance GHC.Enum.Enum U.Codebase.Decl.DeclType
instance GHC.Show.Show U.Codebase.Decl.DeclType
instance GHC.Classes.Ord U.Codebase.Decl.DeclType
instance GHC.Classes.Eq U.Codebase.Decl.DeclType
instance GHC.Show.Show U.Codebase.Decl.Modifier
instance GHC.Classes.Ord U.Codebase.Decl.Modifier
instance GHC.Classes.Eq U.Codebase.Decl.Modifier
instance (GHC.Show.Show v, GHC.Show.Show r) => GHC.Show.Show (U.Codebase.Decl.DeclR r v)
instance GHC.Show.Show a => GHC.Show.Show (U.Codebase.Decl.F a)
instance Data.Foldable.Foldable U.Codebase.Decl.F
instance GHC.Base.Functor U.Codebase.Decl.F

module U.Codebase.Referent
type Referent = Referent' Reference Reference
type ReferentH = Referent' (Reference' Text (Maybe Hash)) (Reference' Text Hash)
data Referent' rTm rTp
Ref :: rTm -> Referent' rTm rTp
Con :: rTp -> ConstructorId -> Referent' rTm rTp
type Id = Id' Hash Hash
data Id' hTm hTp
RefId :: Id' hTm -> Id' hTm hTp
ConId :: Id' hTp -> ConstructorId -> Id' hTm hTp
instance (GHC.Show.Show rTm, GHC.Show.Show rTp) => GHC.Show.Show (U.Codebase.Referent.Referent' rTm rTp)
instance (GHC.Classes.Ord rTm, GHC.Classes.Ord rTp) => GHC.Classes.Ord (U.Codebase.Referent.Referent' rTm rTp)
instance (GHC.Classes.Eq rTm, GHC.Classes.Eq rTp) => GHC.Classes.Eq (U.Codebase.Referent.Referent' rTm rTp)
instance (GHC.Show.Show hTm, GHC.Show.Show hTp) => GHC.Show.Show (U.Codebase.Referent.Id' hTm hTp)
instance (GHC.Classes.Ord hTm, GHC.Classes.Ord hTp) => GHC.Classes.Ord (U.Codebase.Referent.Id' hTm hTp)
instance (GHC.Classes.Eq hTm, GHC.Classes.Eq hTp) => GHC.Classes.Eq (U.Codebase.Referent.Id' hTm hTp)
instance Data.Bifunctor.Bifunctor U.Codebase.Referent.Id'
instance Data.Bifoldable.Bifoldable U.Codebase.Referent.Id'
instance Data.Bitraversable.Bitraversable U.Codebase.Referent.Id'
instance Data.Bifunctor.Bifunctor U.Codebase.Referent.Referent'
instance Data.Bifoldable.Bifoldable U.Codebase.Referent.Referent'
instance Data.Bitraversable.Bitraversable U.Codebase.Referent.Referent'

module U.Codebase.TermEdit
data TermEdit
Replace :: Referent -> Typing -> TermEdit
Deprecate :: TermEdit
data Typing
Same :: Typing
Subtype :: Typing
Different :: Typing
instance GHC.Show.Show U.Codebase.TermEdit.Typing
instance GHC.Classes.Ord U.Codebase.TermEdit.Typing
instance GHC.Classes.Eq U.Codebase.TermEdit.Typing
instance GHC.Show.Show U.Codebase.TermEdit.TermEdit
instance GHC.Classes.Ord U.Codebase.TermEdit.TermEdit
instance GHC.Classes.Eq U.Codebase.TermEdit.TermEdit

module U.Codebase.Term
type ConstructorId = Word64
type Term v = Term (F v) v ()
type Type v = TypeR TypeRef v
type TermRef = Reference' Text (Maybe Hash)
type TypeRef = Reference
type TermLink = Referent' (Reference' Text (Maybe Hash)) (Reference' Text Hash)
type TypeLink = Reference

-- | Base functor for terms in the Unison codebase
type F vt = F' Text TermRef TypeRef TermLink TypeLink vt

-- | Generalized version. We could generalize further to allow sharing
--   within terms.
data F' text termRef typeRef termLink typeLink vt a
Int :: Int64 -> F' text termRef typeRef termLink typeLink vt a
Nat :: Word64 -> F' text termRef typeRef termLink typeLink vt a
Float :: Double -> F' text termRef typeRef termLink typeLink vt a
Boolean :: Bool -> F' text termRef typeRef termLink typeLink vt a
Text :: text -> F' text termRef typeRef termLink typeLink vt a
Char :: Char -> F' text termRef typeRef termLink typeLink vt a
Ref :: termRef -> F' text termRef typeRef termLink typeLink vt a
Constructor :: typeRef -> ConstructorId -> F' text termRef typeRef termLink typeLink vt a
Request :: typeRef -> ConstructorId -> F' text termRef typeRef termLink typeLink vt a
Handle :: a -> a -> F' text termRef typeRef termLink typeLink vt a
App :: a -> a -> F' text termRef typeRef termLink typeLink vt a
Ann :: a -> TypeR typeRef vt -> F' text termRef typeRef termLink typeLink vt a
List :: Seq a -> F' text termRef typeRef termLink typeLink vt a
If :: a -> a -> a -> F' text termRef typeRef termLink typeLink vt a
And :: a -> a -> F' text termRef typeRef termLink typeLink vt a
Or :: a -> a -> F' text termRef typeRef termLink typeLink vt a
Lam :: a -> F' text termRef typeRef termLink typeLink vt a
LetRec :: [a] -> a -> F' text termRef typeRef termLink typeLink vt a
Let :: a -> a -> F' text termRef typeRef termLink typeLink vt a
Match :: a -> [MatchCase text typeRef a] -> F' text termRef typeRef termLink typeLink vt a
TermLink :: termLink -> F' text termRef typeRef termLink typeLink vt a
TypeLink :: typeLink -> F' text termRef typeRef termLink typeLink vt a
data MatchCase t r a
MatchCase :: Pattern t r -> Maybe a -> a -> MatchCase t r a
data Pattern t r
PUnbound :: Pattern t r
PVar :: Pattern t r
PBoolean :: !Bool -> Pattern t r
PInt :: !Int64 -> Pattern t r
PNat :: !Word64 -> Pattern t r
PFloat :: !Double -> Pattern t r
PText :: !t -> Pattern t r
PChar :: !Char -> Pattern t r
PConstructor :: !r -> !Int -> [Pattern t r] -> Pattern t r
PAs :: Pattern t r -> Pattern t r
PEffectPure :: Pattern t r -> Pattern t r
PEffectBind :: !r -> !Int -> [Pattern t r] -> Pattern t r -> Pattern t r
PSequenceLiteral :: [Pattern t r] -> Pattern t r
PSequenceOp :: Pattern t r -> !SeqOp -> Pattern t r -> Pattern t r
data SeqOp
PCons :: SeqOp
PSnoc :: SeqOp
PConcat :: SeqOp
extraMap :: forall text termRef typeRef termLink typeLink vt text' termRef' typeRef' termLink' typeLink' vt' v a. (Ord v, Ord vt') => (text -> text') -> (termRef -> termRef') -> (typeRef -> typeRef') -> (termLink -> termLink') -> (typeLink -> typeLink') -> (vt -> vt') -> Term (F' text termRef typeRef termLink typeLink vt) v a -> Term (F' text' termRef' typeRef' termLink' typeLink' vt') v a
rmapPattern :: (t -> t') -> (r -> r') -> Pattern t r -> Pattern t' r'
dependencies :: (Ord termRef, Ord typeRef, Ord termLink, Ord typeLink, Ord v) => Term (F' text termRef typeRef termLink typeLink vt) v a -> (Set termRef, Set typeRef, Set termLink, Set typeLink)
instance GHC.Show.Show U.Codebase.Term.SeqOp
instance GHC.Classes.Eq U.Codebase.Term.SeqOp
instance (GHC.Show.Show t, GHC.Show.Show r) => GHC.Show.Show (U.Codebase.Term.Pattern t r)
instance Data.Traversable.Traversable (U.Codebase.Term.Pattern t)
instance Data.Foldable.Foldable (U.Codebase.Term.Pattern t)
instance GHC.Base.Functor (U.Codebase.Term.Pattern t)
instance GHC.Generics.Generic (U.Codebase.Term.Pattern t r)
instance (GHC.Show.Show t, GHC.Show.Show r, GHC.Show.Show a) => GHC.Show.Show (U.Codebase.Term.MatchCase t r a)
instance Data.Traversable.Traversable (U.Codebase.Term.MatchCase t r)
instance GHC.Generics.Generic1 (U.Codebase.Term.MatchCase t r)
instance GHC.Generics.Generic (U.Codebase.Term.MatchCase t r a)
instance GHC.Base.Functor (U.Codebase.Term.MatchCase t r)
instance Data.Foldable.Foldable (U.Codebase.Term.MatchCase t r)
instance (GHC.Show.Show text, GHC.Show.Show termRef, GHC.Show.Show a, GHC.Show.Show vt, GHC.Show.Show termLink, GHC.Show.Show typeLink, GHC.Show.Show typeRef) => GHC.Show.Show (U.Codebase.Term.F' text termRef typeRef termLink typeLink vt a)
instance Data.Traversable.Traversable (U.Codebase.Term.F' text termRef typeRef termLink typeLink vt)
instance GHC.Base.Functor (U.Codebase.Term.F' text termRef typeRef termLink typeLink vt)
instance Data.Foldable.Foldable (U.Codebase.Term.F' text termRef typeRef termLink typeLink vt)

module U.Codebase.TypeEdit
data TypeEdit
Replace :: Reference -> TypeEdit
Deprecate :: TypeEdit
instance GHC.Show.Show U.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Ord U.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Eq U.Codebase.TypeEdit.TypeEdit

module U.Codebase.Branch
newtype NameSegment
NameSegment :: Text -> NameSegment
type MetadataType = Reference
type MetadataValue = Reference
data MdValues
MdValues :: Map MetadataValue MetadataType -> MdValues
type Causal m = Causal m CausalHash BranchHash (Branch m)

-- | V2.Branch is like V1.Branch0; I would rename it, at least temporarily,
--   but too hard.
data Branch m
Branch :: Map NameSegment (Map Referent (m MdValues)) -> Map NameSegment (Map Reference (m MdValues)) -> Map NameSegment (PatchHash, m Patch) -> Map NameSegment (Causal m) -> Branch m
[terms] :: Branch m -> Map NameSegment (Map Referent (m MdValues))
[types] :: Branch m -> Map NameSegment (Map Reference (m MdValues))
[patches] :: Branch m -> Map NameSegment (PatchHash, m Patch)
[children] :: Branch m -> Map NameSegment (Causal m)
data Patch
Patch :: Map Referent (Set TermEdit) -> Map Reference (Set TypeEdit) -> Patch
[termEdits] :: Patch -> Map Referent (Set TermEdit)
[typeEdits] :: Patch -> Map Reference (Set TypeEdit)
instance GHC.Show.Show U.Codebase.Branch.NameSegment
instance GHC.Classes.Ord U.Codebase.Branch.NameSegment
instance GHC.Classes.Eq U.Codebase.Branch.NameSegment
instance GHC.Show.Show U.Codebase.Branch.MdValues
instance GHC.Classes.Ord U.Codebase.Branch.MdValues
instance GHC.Classes.Eq U.Codebase.Branch.MdValues
instance GHC.Show.Show (U.Codebase.Branch.Branch m)

module U.Codebase.WatchKind
data WatchKind
RegularWatch :: WatchKind
TestWatch :: WatchKind
instance GHC.Show.Show U.Codebase.WatchKind.WatchKind
instance GHC.Classes.Ord U.Codebase.WatchKind.WatchKind
instance GHC.Classes.Eq U.Codebase.WatchKind.WatchKind
