-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-cli
@version 0.0.0

module Compat

-- | Constructs a default interrupt handler which builds an interrupt
--   handler which throws a UserInterrupt exception to the thread in which
--   the setup was initially called.
defaultInterruptHandler :: IO (IO ())

-- | Replaces any existing interrupt handlers with the provided IO action
--   while the provided action is running, restoring any existing handlers
--   afterwards.
withInterruptHandler :: IO () -> IO a -> IO a

module Unison.Auth.Types
data DiscoveryDoc
DiscoveryDoc :: URI -> URI -> URI -> URI -> DiscoveryDoc
[$sel:issuer:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:authorizationEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:tokenEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:userInfoEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
data Tokens
Tokens :: AccessToken -> Maybe IDToken -> Maybe RefreshToken -> TokenType -> NominalDiffTime -> Scopes -> Tokens
[$sel:accessToken:Tokens] :: Tokens -> AccessToken
[$sel:idToken:Tokens] :: Tokens -> Maybe IDToken
[$sel:refreshToken:Tokens] :: Tokens -> Maybe RefreshToken
[$sel:tokenType:Tokens] :: Tokens -> TokenType
[$sel:expiresIn:Tokens] :: Tokens -> NominalDiffTime
[$sel:scopes:Tokens] :: Tokens -> Scopes
data Credentials
Credentials :: Map ProfileName (Map CodeserverId CodeserverCredentials) -> ProfileName -> Credentials
[$sel:credentials:Credentials] :: Credentials -> Map ProfileName (Map CodeserverId CodeserverCredentials)
[$sel:activeProfile:Credentials] :: Credentials -> ProfileName
type Code = Text
type AccessToken = Text
type RefreshToken = Text
type IDToken = Text
type OAuthState = ByteString
type PKCEVerifier = ByteString
type PKCEChallenge = ByteString
type ProfileName = Text
data CredentialFailure
ReauthRequired :: CodeserverId -> CredentialFailure
CredentialParseFailure :: FilePath -> Text -> CredentialFailure
InvalidDiscoveryDocument :: URI -> Text -> CredentialFailure
InvalidJWT :: Text -> CredentialFailure
RefreshFailure :: Text -> CredentialFailure
InvalidTokenResponse :: URI -> Text -> CredentialFailure
InvalidHost :: CodeserverURI -> CredentialFailure

-- | Credentials for a specific codeserver
data CodeserverCredentials
CodeserverCredentials :: Tokens -> URI -> CodeserverCredentials
[$sel:tokens:CodeserverCredentials] :: CodeserverCredentials -> Tokens
[$sel:discoveryURI:CodeserverCredentials] :: CodeserverCredentials -> URI
getCodeserverCredentials :: CodeserverId -> Credentials -> Either CredentialFailure CodeserverCredentials
setCodeserverCredentials :: CodeserverId -> CodeserverCredentials -> Credentials -> Credentials
codeserverCredentials :: URI -> Tokens -> CodeserverCredentials
emptyCredentials :: Credentials
instance GHC.Exception.Type.Exception Unison.Auth.Types.CredentialFailure
instance GHC.Classes.Eq Unison.Auth.Types.CredentialFailure
instance GHC.Show.Show Unison.Auth.Types.CredentialFailure
instance GHC.Classes.Ord Unison.Auth.Types.Scopes
instance GHC.Classes.Eq Unison.Auth.Types.Scopes
instance GHC.Show.Show Unison.Auth.Types.Scopes
instance GHC.Show.Show Unison.Auth.Types.DiscoveryDoc
instance GHC.Show.Show Unison.Auth.Types.Tokens
instance GHC.Classes.Eq Unison.Auth.Types.Tokens
instance GHC.Classes.Eq Unison.Auth.Types.CodeserverCredentials
instance GHC.Classes.Eq Unison.Auth.Types.Credentials
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Credentials
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Credentials
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.CodeserverCredentials
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.CodeserverCredentials
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.URIParam
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.DiscoveryDoc
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Tokens
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Tokens
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Scopes
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Scopes

module Unison.Auth.Discovery
discoveryURIForCodeserver :: CodeserverURI -> URI
fetchDiscoveryDoc :: MonadIO m => URI -> m (Either CredentialFailure DiscoveryDoc)

module Unison.Auth.CredentialFile

-- | Atomically update the credential storage file. Creates an empty file
--   automatically if one doesn't exist.
atomicallyModifyCredentialsFile :: MonadIO m => (Credentials -> Credentials) -> m Credentials

module Unison.Auth.CredentialManager

-- | Saves credentials to the active profile.
saveCredentials :: MonadUnliftIO m => CredentialManager -> CodeserverId -> CodeserverCredentials -> m ()

-- | A <a>CredentialManager</a> knows how to load, save, and cache
--   credentials. It's thread-safe and safe for use across multiple UCM
--   clients. Note: Currently the in-memory cache is _not_ updated if a
--   different UCM updates the credentials file, however this shouldn't
--   pose any problems, since auth will still be refreshed if we encounter
--   any auth failures on requests.
data CredentialManager
newCredentialManager :: MonadIO m => m CredentialManager
getCredentials :: MonadIO m => CredentialManager -> CodeserverId -> m (Either CredentialFailure CodeserverCredentials)

module Unison.Codebase.Editor.AuthorInfo
data AuthorInfo v a
AuthorInfo :: (Id, Term v a, Type v a) -> AuthorInfo v a
[$sel:guid:AuthorInfo, $sel:author:AuthorInfo, $sel:copyrightHolder:AuthorInfo] :: AuthorInfo v a -> (Id, Term v a, Type v a)
createAuthorInfo :: forall m v a. MonadIO m => Var v => a -> Text -> m (AuthorInfo v a)

module Unison.Codebase.Editor.Input
data Input
ForkLocalBranchI :: Either ShortBranchHash Path' -> Path' -> Input
MergeLocalBranchI :: Path' -> Path' -> MergeMode -> Input
PreviewMergeLocalBranchI :: Path' -> Path' -> Input
DiffNamespaceI :: BranchId -> BranchId -> Input
PullRemoteBranchI :: Maybe ReadRemoteNamespace -> Path' -> SyncMode -> PullMode -> Verbosity -> Input
PushRemoteBranchI :: PushRemoteBranchInput -> Input
CreatePullRequestI :: ReadRemoteNamespace -> ReadRemoteNamespace -> Input
LoadPullRequestI :: ReadRemoteNamespace -> ReadRemoteNamespace -> Path' -> Input
ResetRootI :: Either ShortBranchHash Path' -> Input
CreateMessage :: Pretty ColorText -> Input
SwitchBranchI :: Maybe Path' -> Input
UpI :: Input
PopBranchI :: Input
NamesI :: IsGlobal -> HashQualified Name -> Input
AliasTermI :: HashOrHQSplit' -> Split' -> Input
AliasTypeI :: HashOrHQSplit' -> Split' -> Input
AliasManyI :: [HQSplit] -> Path' -> Input
MoveTermI :: HQSplit' -> Split' -> Input
MoveTypeI :: HQSplit' -> Split' -> Input
MoveBranchI :: Maybe Split' -> Split' -> Input
MovePatchI :: Split' -> Split' -> Input
CopyPatchI :: Split' -> Split' -> Input
DeleteI :: HQSplit' -> Input
DeleteTermI :: HQSplit' -> Input
DeleteTypeI :: HQSplit' -> Input
DeleteBranchI :: Insistence -> Maybe Split' -> Input
DeletePatchI :: Split' -> Input
ResolveTermNameI :: HQSplit' -> Input
ResolveTypeNameI :: HQSplit' -> Input
LoadI :: Maybe FilePath -> Input
AddI :: Set Name -> Input
PreviewAddI :: Set Name -> Input
UpdateI :: OptionalPatch -> Set Name -> Input
PreviewUpdateI :: Set Name -> Input
TodoI :: Maybe PatchPath -> Path' -> Input
PropagatePatchI :: PatchPath -> Path' -> Input
ListEditsI :: Maybe PatchPath -> Input
DeprecateTermI :: PatchPath -> HQSplit' -> Input
DeprecateTypeI :: PatchPath -> HQSplit' -> Input
ReplaceI :: HashQualified Name -> HashQualified Name -> Maybe PatchPath -> Input
RemoveTermReplacementI :: HashQualified Name -> Maybe PatchPath -> Input
RemoveTypeReplacementI :: HashQualified Name -> Maybe PatchPath -> Input
UndoI :: Input
HistoryI :: Maybe Int -> Maybe Int -> BranchId -> Input
ExecuteI :: String -> [String] -> Input
IOTestI :: HashQualified Name -> Input
MakeStandaloneI :: String -> HashQualified Name -> Input
TestI :: TestInput -> Input
LinkI :: HashQualified Name -> [HQSplit'] -> Input
UnlinkI :: HashQualified Name -> [HQSplit'] -> Input
LinksI :: HQSplit' -> Maybe String -> Input
CreateAuthorI :: NameSegment -> Text -> Input
DisplayI :: OutputLocation -> [HashQualified Name] -> Input
DocsI :: [HQSplit'] -> Input
FindI :: Bool -> FindScope -> [String] -> Input
FindShallowI :: Path' -> Input
FindPatchI :: Input
ShowDefinitionI :: OutputLocation -> [HashQualified Name] -> Input
ShowDefinitionByPrefixI :: OutputLocation -> [HashQualified Name] -> Input
ShowReflogI :: Input
UpdateBuiltinsI :: Input
MergeBuiltinsI :: Input
MergeIOBuiltinsI :: Input
ListDependenciesI :: HashQualified Name -> Input
ListDependentsI :: HashQualified Name -> Input

-- | List all external dependencies of a given namespace, or the current
--   namespace if no path is provided.
NamespaceDependenciesI :: Maybe Path' -> Input
DebugNumberedArgsI :: Input
DebugTypecheckedUnisonFileI :: Input
DebugDumpNamespacesI :: Input
DebugDumpNamespaceSimpleI :: Input
DebugClearWatchI :: Input
DebugDoctorI :: Input
QuitI :: Input
ApiI :: Input
UiI :: Input
DocsToHtmlI :: Path' -> FilePath -> Input
GistI :: GistInput -> Input
AuthLoginI :: Input
VersionI :: Input

-- | <tt>"push.gist repo"</tt> pushes the contents of the current namespace
--   to <tt>repo</tt>.
data GistInput
GistInput :: WriteGitRepo -> GistInput
[$sel:repo:GistInput] :: GistInput -> WriteGitRepo
data PushRemoteBranchInput
PushRemoteBranchInput :: Path' -> Maybe WriteRemotePath -> PushBehavior -> SyncMode -> PushRemoteBranchInput

-- | The local path to push. If relative, it's resolved relative to the
--   current path (<tt>cd</tt>).
[$sel:localPath:PushRemoteBranchInput] :: PushRemoteBranchInput -> Path'

-- | The repo to push to. If missing, it is looked up in `.unisonConfig`.
[$sel:maybeRemoteRepo:PushRemoteBranchInput] :: PushRemoteBranchInput -> Maybe WriteRemotePath

-- | The push behavior (whether the remote branch is required to be empty
--   or non-empty).
[$sel:pushBehavior:PushRemoteBranchInput] :: PushRemoteBranchInput -> PushBehavior
[$sel:syncMode:PushRemoteBranchInput] :: PushRemoteBranchInput -> SyncMode
data TestInput
TestInput :: Bool -> Bool -> Bool -> TestInput

-- | Should we run tests in the <tt>lib</tt> namespace?
[$sel:includeLibNamespace:TestInput] :: TestInput -> Bool
[$sel:showFailures:TestInput] :: TestInput -> Bool
[$sel:showSuccesses:TestInput] :: TestInput -> Bool
data Event
UnisonFileChanged :: SourceName -> Source -> Event
IncomingRootBranch :: Set CausalHash -> Event
data OutputLocation
ConsoleLocation :: OutputLocation
LatestFileLocation :: OutputLocation
FileLocation :: FilePath -> OutputLocation
type PatchPath = Split'
type BranchId = Either ShortBranchHash Path'
type AbsBranchId = Either ShortBranchHash Absolute
parseBranchId :: String -> Either String BranchId
type HashOrHQSplit' = Either ShortHash HQSplit'

-- | Should we force the operation or not?
data Insistence
Force :: Insistence
Try :: Insistence
data PullMode
PullWithHistory :: PullMode
PullWithoutHistory :: PullMode
data OptionalPatch
NoPatch :: OptionalPatch
DefaultPatch :: OptionalPatch
UsePatch :: PatchPath -> OptionalPatch
data FindScope
Local :: FindScope
LocalAndDeps :: FindScope
Global :: FindScope
type IsGlobal = Bool
instance GHC.Show.Show Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Ord Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.Insistence
instance GHC.Show.Show Unison.Codebase.Editor.Input.Insistence
instance GHC.Show.Show Unison.Codebase.Editor.Input.PullMode
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PullMode
instance GHC.Show.Show Unison.Codebase.Editor.Input.GistInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.GistInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.PushRemoteBranchInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PushRemoteBranchInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.TestInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.TestInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.OutputLocation
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.OutputLocation
instance GHC.Show.Show Unison.Codebase.Editor.Input.FindScope
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.FindScope
instance GHC.Show.Show Unison.Codebase.Editor.Input.Input
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.Input

module Unison.Codebase.Editor.Output.BranchDiff
data MetadataDiff tm
MetadataDiff :: [tm] -> [tm] -> MetadataDiff tm
[$sel:addedMetadata:MetadataDiff] :: MetadataDiff tm -> [tm]
[$sel:removedMetadata:MetadataDiff] :: MetadataDiff tm -> [tm]
data BranchDiffOutput v a
BranchDiffOutput :: [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> Int -> [PatchDisplay] -> [AddedTypeDisplay v a] -> [AddedTermDisplay v a] -> [PatchDisplay] -> [RemovedTypeDisplay v a] -> [RemovedTermDisplay v a] -> [PatchDisplay] -> [RenameTypeDisplay v a] -> [RenameTermDisplay v a] -> BranchDiffOutput v a
[$sel:updatedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:updatedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:newTypeConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:newTermConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:resolvedTypeConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:resolvedTermConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:propagatedUpdates:BranchDiffOutput] :: BranchDiffOutput v a -> Int
[$sel:updatedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:addedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [AddedTypeDisplay v a]
[$sel:addedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [AddedTermDisplay v a]
[$sel:addedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:removedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [RemovedTypeDisplay v a]
[$sel:removedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [RemovedTermDisplay v a]
[$sel:removedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:renamedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [RenameTypeDisplay v a]
[$sel:renamedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [RenameTermDisplay v a]
isEmpty :: BranchDiffOutput v a -> Bool
type TermDisplay v a = (HashQualified Name, Referent, Maybe (Type v a), MetadataDiff (MetadataDisplay v a))
type TypeDisplay v a = (HashQualified Name, Reference, Maybe (DeclOrBuiltin v a), MetadataDiff (MetadataDisplay v a))
type AddedTermDisplay v a = ([(HashQualified Name, [MetadataDisplay v a])], Referent, Maybe (Type v a))
type AddedTypeDisplay v a = ([(HashQualified Name, [MetadataDisplay v a])], Reference, Maybe (DeclOrBuiltin v a))
type RemovedTermDisplay v a = ([HashQualified Name], Referent, Maybe (Type v a))
type RemovedTypeDisplay v a = ([HashQualified Name], Reference, Maybe (DeclOrBuiltin v a))
type SimpleTermDisplay v a = (HashQualified Name, Referent, Maybe (Type v a))
type SimpleTypeDisplay v a = (HashQualified Name, Reference, Maybe (DeclOrBuiltin v a))
type UpdateTermDisplay v a = (Maybe [SimpleTermDisplay v a], [TermDisplay v a])
type UpdateTypeDisplay v a = (Maybe [SimpleTypeDisplay v a], [TypeDisplay v a])
type MetadataDisplay v a = (HashQualified Name, Referent, Maybe (Type v a))
type RenameTermDisplay v a = (Referent, Maybe (Type v a), Set (HashQualified Name), Set (HashQualified Name))
type RenameTypeDisplay v a = (Reference, Maybe (DeclOrBuiltin v a), Set (HashQualified Name), Set (HashQualified Name))
type PatchDisplay = (Name, PatchDiff)
toOutput :: forall m v a. Monad m => (Referent -> m (Maybe (Type v a))) -> (Reference -> m (Maybe (DeclOrBuiltin v a))) -> Int -> Names -> Names -> PrettyPrintEnv -> BranchDiff -> m (BranchDiffOutput v a)
instance GHC.Show.Show tm => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance Data.Traversable.Traversable Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff
instance Data.Foldable.Foldable Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff
instance GHC.Base.Functor Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff
instance GHC.Classes.Eq tm => GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance GHC.Classes.Ord tm => GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.BranchDiffOutput v a)
instance GHC.Base.Semigroup (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance GHC.Base.Monoid (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)

module Unison.Codebase.Editor.Output.DumpNamespace
data DumpNamespace
DumpNamespace :: Map Referent (Set NameSegment, Set Reference) -> Map Reference (Set NameSegment, Set Reference) -> Map NameSegment EditHash -> Map NameSegment CausalHash -> Set CausalHash -> DumpNamespace
[$sel:terms:DumpNamespace] :: DumpNamespace -> Map Referent (Set NameSegment, Set Reference)
[$sel:types:DumpNamespace] :: DumpNamespace -> Map Reference (Set NameSegment, Set Reference)
[$sel:patches:DumpNamespace] :: DumpNamespace -> Map NameSegment EditHash
[$sel:children:DumpNamespace] :: DumpNamespace -> Map NameSegment CausalHash
[$sel:causalParents:DumpNamespace] :: DumpNamespace -> Set CausalHash
instance GHC.Show.Show Unison.Codebase.Editor.Output.DumpNamespace.DumpNamespace

module Unison.Codebase.Editor.Output.PushPull
data PushPull
Push :: PushPull
Pull :: PushPull
fold :: a -> a -> PushPull -> a
instance GHC.Show.Show Unison.Codebase.Editor.Output.PushPull.PushPull
instance GHC.Classes.Ord Unison.Codebase.Editor.Output.PushPull.PushPull
instance GHC.Classes.Eq Unison.Codebase.Editor.Output.PushPull.PushPull

module Unison.Codebase.Editor.SlurpComponent
data SlurpComponent v
SlurpComponent :: Set v -> Set v -> Set v -> SlurpComponent v
[$sel:types:SlurpComponent] :: SlurpComponent v -> Set v
[$sel:terms:SlurpComponent] :: SlurpComponent v -> Set v
[$sel:ctors:SlurpComponent] :: SlurpComponent v -> Set v
isEmpty :: SlurpComponent v -> Bool
empty :: Ord v => SlurpComponent v
difference :: Ord v => SlurpComponent v -> SlurpComponent v -> SlurpComponent v
intersection :: Ord v => SlurpComponent v -> SlurpComponent v -> SlurpComponent v
closeWithDependencies :: forall v a. Ord v => TypecheckedUnisonFile v a -> SlurpComponent v -> SlurpComponent v
fromTypes :: Ord v => Set v -> SlurpComponent v
fromTerms :: Ord v => Set v -> SlurpComponent v
fromCtors :: Ord v => Set v -> SlurpComponent v
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.SlurpComponent.SlurpComponent v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Codebase.Editor.SlurpComponent.SlurpComponent v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Codebase.Editor.SlurpComponent.SlurpComponent v)
instance GHC.Classes.Ord v => GHC.Base.Semigroup (Unison.Codebase.Editor.SlurpComponent.SlurpComponent v)
instance GHC.Classes.Ord v => GHC.Base.Monoid (Unison.Codebase.Editor.SlurpComponent.SlurpComponent v)

module Unison.Codebase.Editor.SlurpResult
data Aliases
AddAliases :: Set Name -> Aliases
UpdateAliases :: Set Name -> Set Name -> Aliases
[$sel:oldRefNames:AddAliases] :: Aliases -> Set Name
[$sel:newRefNames:AddAliases] :: Aliases -> Set Name
data SlurpResult v
SlurpResult :: TypecheckedUnisonFile v Ann -> SlurpComponent v -> SlurpComponent v -> SlurpComponent v -> SlurpComponent v -> SlurpComponent v -> SlurpComponent v -> Set v -> Set v -> Map v Aliases -> Map v Aliases -> SlurpComponent v -> SlurpResult v
[$sel:originalFile:SlurpResult] :: SlurpResult v -> TypecheckedUnisonFile v Ann
[$sel:extraDefinitions:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:adds:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:duplicates:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:collisions:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:conflicts:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:updates:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:termExistingConstructorCollisions:SlurpResult] :: SlurpResult v -> Set v
[$sel:constructorExistingTermCollisions:SlurpResult] :: SlurpResult v -> Set v
[$sel:termAlias:SlurpResult] :: SlurpResult v -> Map v Aliases
[$sel:typeAlias:SlurpResult] :: SlurpResult v -> Map v Aliases
[$sel:defsWithBlockedDependencies:SlurpResult] :: SlurpResult v -> SlurpComponent v
hasAddsOrUpdates :: Ord v => SlurpResult v -> Bool
data Status
Add :: Status
Update :: Status
Duplicate :: Status
Collision :: Status
Conflicted :: Status
TermExistingConstructorCollision :: Status
ConstructorExistingTermCollision :: Status
ExtraDefinition :: Status
BlockedDependency :: Status
isFailure :: Status -> Bool
prettyStatus :: Status -> Pretty ColorText
type IsPastTense = Bool
prettyVar :: Var v => v -> Pretty ColorText
aliasesToShow :: Int
pretty :: forall v. Var v => IsPastTense -> PrettyPrintEnv -> SlurpResult v -> Pretty ColorText
isOk :: Ord v => SlurpResult v -> Bool
isAllDuplicates :: Ord v => SlurpResult v -> Bool
ex :: Pretty ColorText
instance GHC.Classes.Ord Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Classes.Eq Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Show.Show Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.SlurpResult.SlurpResult v)
instance GHC.Show.Show Unison.Codebase.Editor.SlurpResult.Status
instance GHC.Classes.Eq Unison.Codebase.Editor.SlurpResult.Status
instance GHC.Classes.Ord Unison.Codebase.Editor.SlurpResult.Status

module Unison.Codebase.Editor.Slurp

-- | The operation which is being performed or checked.
data SlurpOp
AddOp :: SlurpOp
UpdateOp :: SlurpOp
CheckOp :: SlurpOp

-- | Analyze a file and determine the status of all of its definitions with
--   respect to a set of vars to analyze and an operation you wish to
--   perform.
slurpFile :: forall v. Var v => TypecheckedUnisonFile v Ann -> Set v -> SlurpOp -> Names -> SlurpResult v
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.SlurpOp
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.SlurpOp
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Slurp.TaggedVar v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Codebase.Editor.Slurp.TaggedVar v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Codebase.Editor.Slurp.TaggedVar v)
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.SlurpOk
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.SlurpOk
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.SlurpOk
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.SlurpErr
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.SlurpErr
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.SlurpErr
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Slurp.SummarizedStatus v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Codebase.Editor.Slurp.SummarizedStatus v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Codebase.Editor.Slurp.SummarizedStatus v)
instance GHC.Classes.Ord v => GHC.Base.Semigroup (Unison.Codebase.Editor.Slurp.SlurpingSummary v)
instance GHC.Classes.Ord v => GHC.Base.Monoid (Unison.Codebase.Editor.Slurp.SlurpingSummary v)

module Unison.Codebase.Editor.TodoOutput
type Score = Int
data TodoOutput v a
TodoOutput :: Score -> ([(Reference, Maybe (Type v a))], [(Reference, DisplayObject () (Decl v a))]) -> ([(Score, Reference, Maybe (Type v a))], [(Score, Reference, DisplayObject () (Decl v a))]) -> Names -> Patch -> TodoOutput v a
[$sel:todoScore:TodoOutput] :: TodoOutput v a -> Score
[$sel:todoFrontier:TodoOutput] :: TodoOutput v a -> ([(Reference, Maybe (Type v a))], [(Reference, DisplayObject () (Decl v a))])
[$sel:todoFrontierDependents:TodoOutput] :: TodoOutput v a -> ([(Score, Reference, Maybe (Type v a))], [(Score, Reference, DisplayObject () (Decl v a))])
[$sel:nameConflicts:TodoOutput] :: TodoOutput v a -> Names
[$sel:editConflicts:TodoOutput] :: TodoOutput v a -> Patch
labeledDependencies :: Ord v => TodoOutput v a -> Set LabeledDependency
noConflicts :: TodoOutput v a -> Bool
noEdits :: TodoOutput v a -> Bool
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Codebase.Editor.TodoOutput.TodoOutput v a)

module Unison.Codebase.Editor.UCMVersion
type UCMVersion = Text

module Unison.Codebase.Editor.UriParser
repoPath :: P ReadRemoteNamespace
writeGitRepo :: P WriteGitRepo

-- | A parser for the deprecated format of git URLs, which may still exist
--   in old GitURL unisonConfigs.
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "/srv/git/project.git:.namespace"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "/srv/git/project.git:branch:.namespace"
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "/srv/git/project.git", branch = Nothing}, path = namespace})
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "/srv/git/project.git", branch = Just "branch"}, path = namespace})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "file:///srv/git/project.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "file:///srv/git/project.git:branch"
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "file:///srv/git/project.git", branch = Nothing}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "file:///srv/git/project.git", branch = Just "branch"}, path = })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "https://example.com/gitproject.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "https://example.com/gitproject.git:base"
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "https://example.com/gitproject.git", branch = Nothing}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "https://example.com/gitproject.git", branch = Just "base"}, path = })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "ssh://user@server/project.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "ssh://user@server/project.git:branch"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "ssh://server/project.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "ssh://server/project.git:branch"
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "ssh://user@server/project.git", branch = Nothing}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "ssh://user@server/project.git", branch = Just "branch"}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "ssh://server/project.git", branch = Nothing}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "ssh://server/project.git", branch = Just "branch"}, path = })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "server:project"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "user@server:project.git:branch"
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "server:project", branch = Nothing}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "user@server:project.git", branch = Just "branch"}, path = })
--   </pre>
deprecatedWriteGitRemotePath :: P WriteGitRemotePath
writeRemotePath :: P WriteRemotePath
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.User
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.User
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.User
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.GitProtocol
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.GitProtocol
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.GitProtocol

module Unison.Codebase.Editor.VersionParser

-- | Parse git version strings into valid unison namespaces.
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe defaultBaseLib "release/M1j"
--   Just (ReadShareRemoteNamespace {server = DefaultCodeserver, repo = "unison", path = public.base.releases._M1j})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe defaultBaseLib "release/M1j.2"
--   Just (ReadShareRemoteNamespace {server = DefaultCodeserver, repo = "unison", path = public.base.releases._M1j_2})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe defaultBaseLib "latest-1234"
--   Just (ReadShareRemoteNamespace {server = DefaultCodeserver, repo = "unison", path = public.base.main})
--   </pre>
--   
--   A version with the <tt>dirty</tt> flag &gt;&gt;&gt; parseMaybe
--   defaultBaseLib "release/M3-409-gbcdf68db3'" Nothing
defaultBaseLib :: Parsec Void Text ReadShareRemoteNamespace


-- | Command-line fuzzy selection of arbitrary values. Shells out to fzf
--   for the actual selection.
module Unison.CommandLine.FuzzySelect

-- | Allows prompting the user to interactively fuzzy-select a result from
--   a list of options, currently shells out to <tt>fzf</tt> under the
--   hood. If fzf is missing, or an error (other than ctrl-c) occurred,
--   returns Nothing.
fuzzySelect :: forall a. Options -> (a -> Text) -> [a] -> IO (Maybe [a])

-- | Fuzzy Selection options
data Options
Options :: Bool -> Options
[$sel:allowMultiSelect:Options] :: Options -> Bool

-- | Default <a>Options</a>
defaultOptions :: Options


-- | Provides Globbing for selecting types, terms and namespaces using
--   wildcards.
module Unison.CommandLine.Globbing

-- | Expand a single glob pattern into all matching targets of the
--   specified types.
expandGlobs :: forall m. Set TargetType -> Branch0 m -> Absolute -> String -> Maybe [String]

-- | Possible targets which a glob may select.
data TargetType
Type :: TargetType
Term :: TargetType
Namespace :: TargetType
instance GHC.Show.Show Unison.CommandLine.Globbing.TargetType
instance GHC.Classes.Ord Unison.CommandLine.Globbing.TargetType
instance GHC.Classes.Eq Unison.CommandLine.Globbing.TargetType
instance GHC.Show.Show Unison.CommandLine.Globbing.GlobArg

module Unison.CommandLine.InputPattern
data IsOptional
Required :: IsOptional
Optional :: IsOptional
ZeroPlus :: IsOptional
OnePlus :: IsOptional
data Visibility
Hidden :: Visibility
Visible :: Visibility
data InputPattern
InputPattern :: String -> [String] -> Visibility -> [(IsOptional, ArgumentType)] -> Pretty ColorText -> ([String] -> Either (Pretty ColorText) Input) -> InputPattern
[$sel:patternName:InputPattern] :: InputPattern -> String
[$sel:aliases:InputPattern] :: InputPattern -> [String]
[$sel:visibility:InputPattern] :: InputPattern -> Visibility
[$sel:argTypes:InputPattern] :: InputPattern -> [(IsOptional, ArgumentType)]
[$sel:help:InputPattern] :: InputPattern -> Pretty ColorText
[$sel:parse:InputPattern] :: InputPattern -> [String] -> Either (Pretty ColorText) Input
data ArgumentType
ArgumentType :: String -> (forall m v a. Monad m => String -> Codebase m v a -> Branch m -> Absolute -> m [Completion]) -> Set TargetType -> ArgumentType
[$sel:typeName:ArgumentType] :: ArgumentType -> String

-- | Generate completion suggestions for this argument type
[$sel:suggestions:ArgumentType] :: ArgumentType -> forall m v a. Monad m => String -> Codebase m v a -> Branch m -> Absolute -> m [Completion]

-- | Select which targets glob patterns may expand into for this argument.
--   An empty set disables globbing.
[$sel:globTargets:ArgumentType] :: ArgumentType -> Set TargetType
argType :: InputPattern -> Int -> Maybe ArgumentType
minArgs :: InputPattern -> Int
maxArgs :: InputPattern -> Maybe Int
noSuggestions :: Monad m => String -> Codebase m v a -> Branch m -> Absolute -> m [Completion]
instance GHC.Classes.Eq Unison.CommandLine.InputPattern.IsOptional
instance GHC.Show.Show Unison.CommandLine.InputPattern.IsOptional
instance GHC.Classes.Ord Unison.CommandLine.InputPattern.Visibility
instance GHC.Classes.Eq Unison.CommandLine.InputPattern.Visibility
instance GHC.Show.Show Unison.CommandLine.InputPattern.Visibility
instance GHC.Show.Show Unison.CommandLine.InputPattern.ArgumentType

module Unison.CommandLine
allow :: FilePath -> Bool
backtick :: IsString s => Pretty s -> Pretty s
aside :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
bigproblem :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
note :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
nothingTodo :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
plural :: Foldable f => f a -> b -> b -> b
plural' :: Integral a => a -> b -> b -> b
problem :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
tip :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
warn :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
warnNote :: String -> String
completion :: String -> Completion
completion' :: String -> Completion

-- | Constructs a list of <tt>Completion</tt>s from a query and completion
--   options by filtering them for prefix matches. A completion will be
--   selected if it's an exact match for a provided option.
exactComplete :: String -> [String] -> [Completion]
fuzzyComplete :: String -> [String] -> [Completion]
fuzzyCompleteHashQualified :: Names -> String -> [Completion]
prefixIncomplete :: String -> [String] -> [Completion]
prettyCompletion :: Bool -> (String, Pretty ColorText) -> Completion
fixupCompletion :: String -> [Completion] -> [Completion]

-- | Completes a list of options, limiting options to the same namespace as
--   the query, or the namespace's children if the query is itself a
--   namespace.
--   
--   E.g. query: "base" would match: ["base", "base.List", "base2"]
--   wouldn't match: ["base.List.map", "contrib", "base2.List"]
completeWithinQueryNamespace :: String -> [String] -> [Completion]
parseInput :: Branch0 m -> Absolute -> [String] -> Map String InputPattern -> [String] -> Either (Pretty ColorText) Input
prompt :: String
watchBranchUpdates :: IO (Branch IO) -> TQueue Event -> Codebase IO v a -> IO (IO ())
watchConfig :: FilePath -> IO (Config, IO ())
watchFileSystem :: TQueue Event -> FilePath -> IO (IO ())

module Unison.CommandLine.InputPatterns
showPatternHelp :: InputPattern -> Pretty ColorText
patternName :: InputPattern -> Pretty ColorText
makeExample :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
makeExampleNoBackticks :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
makeExample' :: InputPattern -> Pretty ColorText
makeExampleEOS :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
helpFor :: InputPattern -> Either (Pretty ColorText) Input
mergeBuiltins :: InputPattern
mergeIOBuiltins :: InputPattern
updateBuiltins :: InputPattern
todo :: InputPattern
load :: InputPattern
add :: InputPattern
previewAdd :: InputPattern
updateNoPatch :: InputPattern
update :: InputPattern
previewUpdate :: InputPattern
patch :: InputPattern
view :: InputPattern
display :: InputPattern
displayTo :: InputPattern
docs :: InputPattern
api :: InputPattern
ui :: InputPattern
undo :: InputPattern
viewByPrefix :: InputPattern
find :: InputPattern
findAll :: InputPattern
findGlobal :: InputPattern
find' :: String -> FindScope -> InputPattern
findShallow :: InputPattern
findVerbose :: InputPattern
findVerboseAll :: InputPattern
findPatch :: InputPattern
renameTerm :: InputPattern
renameType :: InputPattern
delete :: InputPattern
deleteTerm :: InputPattern
deleteType :: InputPattern
deleteTermReplacementCommand :: String
deleteTypeReplacementCommand :: String
deleteReplacement :: Bool -> InputPattern
deleteTermReplacement :: InputPattern
deleteTypeReplacement :: InputPattern
parseHashQualifiedName :: String -> Either (Pretty ColorText) (HashQualified Name)
aliasTerm :: InputPattern
aliasType :: InputPattern
aliasMany :: InputPattern
up :: InputPattern
cd :: InputPattern
back :: InputPattern
deleteNamespace :: InputPattern
deleteNamespaceForce :: InputPattern
deleteNamespaceParser :: Pretty ColorText -> Insistence -> [String] -> Either (Pretty ColorText) Input
deletePatch :: InputPattern
movePatch :: String -> String -> Either (Pretty ColorText) Input
copyPatch' :: String -> String -> Either (Pretty ColorText) Input
copyPatch :: InputPattern
renamePatch :: InputPattern
renameBranch :: InputPattern
history :: InputPattern
forkLocal :: InputPattern
resetRoot :: InputPattern
pullSilent :: InputPattern
pull :: InputPattern
pullWithoutHistory :: InputPattern
pullImpl :: String -> Verbosity -> PullMode -> Pretty ColorText -> InputPattern
pullExhaustive :: InputPattern
push :: InputPattern
pushCreate :: InputPattern
pushForce :: InputPattern
pushExhaustive :: InputPattern
createPullRequest :: InputPattern
loadPullRequest :: InputPattern
parseReadRemoteNamespace :: String -> String -> Either (Pretty ColorText) ReadRemoteNamespace
prettyPrintParseError :: String -> ParseErrorBundle Text Void -> Pretty ColorText
parseWriteGitRepo :: String -> String -> Either (Pretty ColorText) WriteGitRepo
parseWriteRemotePath :: String -> String -> Either (Pretty ColorText) WriteRemotePath
squashMerge :: InputPattern
mergeLocal :: InputPattern
diffNamespace :: InputPattern
previewMergeLocal :: InputPattern
replaceEdit :: (HashQualified Name -> HashQualified Name -> Maybe PatchPath -> Input) -> InputPattern
replace :: InputPattern
viewReflog :: InputPattern
edit :: InputPattern
topicNameArg :: ArgumentType
codebaseServerNameArg :: ArgumentType
helpTopics :: InputPattern
helpTopicsMap :: Map String (Pretty ColorText)
help :: InputPattern
quit :: InputPattern
viewPatch :: InputPattern
link :: InputPattern
links :: InputPattern
unlink :: InputPattern
names :: IsGlobal -> InputPattern
dependents :: InputPattern
dependencies :: InputPattern
namespaceDependencies :: InputPattern
debugNumberedArgs :: InputPattern
debugFileHashes :: InputPattern
debugDumpNamespace :: InputPattern
debugDumpNamespaceSimple :: InputPattern
debugClearWatchCache :: InputPattern
debugDoctor :: InputPattern
test :: InputPattern
testAll :: InputPattern
docsToHtml :: InputPattern
execute :: InputPattern
ioTest :: InputPattern
makeStandalone :: InputPattern
createAuthor :: InputPattern
gist :: InputPattern
authLogin :: InputPattern
printVersion :: InputPattern
validInputs :: [InputPattern]
visibleInputs :: [InputPattern]
commandNames :: [String]
commandNameArg :: ArgumentType
exactDefinitionOrPathArg :: ArgumentType
fuzzyDefinitionQueryArg :: ArgumentType
definitionQueryArg :: ArgumentType
exactDefinitionTypeQueryArg :: ArgumentType
exactDefinitionTermQueryArg :: ArgumentType
typeCompletor :: Applicative m => (String -> [String] -> [Completion]) -> String -> Codebase m v a -> Branch m -> Absolute -> m [Completion]
termCompletor :: Applicative m => (String -> [String] -> [Completion]) -> String -> Codebase m v a -> Branch m -> Absolute -> m [Completion]
patchArg :: ArgumentType
allCompletors :: Monad m => [String -> Codebase m v a -> Branch m -> Absolute -> m [Completion]] -> String -> Codebase m v a -> Branch m -> Absolute -> m [Completion]
bothCompletors :: Monad m => (String -> t2 -> t3 -> t4 -> m [Completion]) -> (String -> t2 -> t3 -> t4 -> m [Completion]) -> String -> t2 -> t3 -> t4 -> m [Completion]

-- | A completer for namespace paths.
pathCompletor :: Applicative f => (String -> [String] -> [Completion]) -> (Branch0 m -> Set Text) -> String -> codebase -> Branch m -> Absolute -> f [Completion]
namespaceArg :: ArgumentType

-- | Recursively collects all names of namespaces which are children of the
--   branch.
allSubNamespaces :: Branch0 m -> [Text]
newNameArg :: ArgumentType
noCompletions :: ArgumentType
gitUrlArg :: ArgumentType

-- | Refers to a namespace on some remote code host.
remoteNamespaceArg :: ArgumentType
collectNothings :: (a -> Maybe b) -> [a] -> [a]
explainRemote :: PushPull -> Pretty ColorText
showErrorFancy :: ShowErrorComponent e => ErrorFancy e -> String
showErrorItem :: ErrorItem (Token Text) -> String

module Unison.Auth.Tokens

-- | Checks whether a JWT access token is expired.
isExpired :: MonadIO m => AccessToken -> m Bool

-- | Given a <a>CodeserverId</a>, provide a valid <a>AccessToken</a> for
--   the associated host. The TokenProvider may automatically refresh
--   access tokens if we have a refresh token.
type TokenProvider = CodeserverId -> IO (Either CredentialFailure AccessToken)

-- | Creates a <a>TokenProvider</a> using the given
--   <a>CredentialManager</a>
newTokenProvider :: CredentialManager -> TokenProvider

-- | Don't yet support automatically refreshing tokens.
--   
--   Specification:
--   <a>https://datatracker.ietf.org/doc/html/rfc6749#section-6</a>
performTokenRefresh :: MonadIO m => URI -> Tokens -> m (Either CredentialFailure Tokens)

module Unison.CommandLine.Welcome
data Welcome
Welcome :: Onboarding -> DownloadBase -> FilePath -> Text -> Welcome
[$sel:onboarding:Welcome] :: Welcome -> Onboarding
[$sel:downloadBase:Welcome] :: Welcome -> DownloadBase
[$sel:watchDir:Welcome] :: Welcome -> FilePath
[$sel:unisonVersion:Welcome] :: Welcome -> Text
data DownloadBase
DownloadBase :: ReadShareRemoteNamespace -> DownloadBase
DontDownloadBase :: DownloadBase
data CodebaseInitStatus
NewlyCreatedCodebase :: CodebaseInitStatus
PreviouslyCreatedCodebase :: CodebaseInitStatus
data Onboarding
Init :: CodebaseInitStatus -> Onboarding
DownloadingBase :: ReadShareRemoteNamespace -> Onboarding
Author :: Onboarding
Finished :: Onboarding
PreviouslyOnboarded :: Onboarding
welcome :: CodebaseInitStatus -> DownloadBase -> FilePath -> Text -> Welcome
pullBase :: ReadShareRemoteNamespace -> Either Event Input
run :: Codebase IO v a -> Welcome -> IO [Either Event Input]
toInput :: Pretty ColorText -> Either Event Input
determineFirstStep :: DownloadBase -> Codebase IO v a -> IO Onboarding
asciiartUnison :: Pretty ColorText
downloading :: Path -> Pretty ColorText
header :: Text -> Pretty ColorText
authorSuggestion :: Pretty ColorText
getStarted :: FilePath -> IO (Pretty ColorText)
instance GHC.Classes.Eq Unison.CommandLine.Welcome.DownloadBase
instance GHC.Show.Show Unison.CommandLine.Welcome.DownloadBase
instance GHC.Classes.Eq Unison.CommandLine.Welcome.CodebaseInitStatus
instance GHC.Show.Show Unison.CommandLine.Welcome.CodebaseInitStatus
instance GHC.Classes.Eq Unison.CommandLine.Welcome.Onboarding
instance GHC.Show.Show Unison.CommandLine.Welcome.Onboarding

module Unison.Share.Codeserver

-- | This is the URI where the share API is based.
defaultCodeserver :: CodeserverURI
resolveCodeserver :: ShareCodeserver -> CodeserverURI


-- | Types used by the UCM client during sync.
module Unison.Share.Sync.Types

-- | Error used by the client when pushing code to Unison Share.
data CheckAndSetPushError
CheckAndSetPushErrorHashMismatch :: HashMismatch -> CheckAndSetPushError
CheckAndSetPushErrorNoWritePermission :: Path -> CheckAndSetPushError
CheckAndSetPushErrorServerMissingDependencies :: NESet Hash32 -> CheckAndSetPushError

-- | An error occurred while fast-forward pushing code to Unison Share.
data FastForwardPushError
FastForwardPushErrorNoHistory :: Path -> FastForwardPushError
FastForwardPushErrorNoReadPermission :: Path -> FastForwardPushError
FastForwardPushErrorNotFastForward :: Path -> FastForwardPushError
FastForwardPushErrorNoWritePermission :: Path -> FastForwardPushError
FastForwardPushErrorServerMissingDependencies :: NESet Hash32 -> FastForwardPushError
FastForwardPushInvalidParentage :: Hash32 -> Hash32 -> FastForwardPushError

-- | An error occurred while pulling code from Unison Share.
data PullError

-- | An error occurred while resolving a repo+path to a causal hash.
PullErrorGetCausalHashByPath :: GetCausalHashByPathError -> PullError
PullErrorNoHistoryAtPath :: Path -> PullError

-- | An error occurred when getting causal hash by path.
data GetCausalHashByPathError

-- | The user does not have permission to read this path.
GetCausalHashByPathErrorNoReadPermission :: Path -> GetCausalHashByPathError

-- | Generic Codeserver transport errors
data CodeserverTransportError
DecodeFailure :: Text -> Response -> CodeserverTransportError
PermissionDenied :: Text -> CodeserverTransportError
RateLimitExceeded :: CodeserverTransportError
Timeout :: CodeserverTransportError
Unauthenticated :: BaseUrl -> CodeserverTransportError
UnexpectedResponse :: Response -> CodeserverTransportError
UnreachableCodeserver :: BaseUrl -> CodeserverTransportError
data SyncError e
TransportError :: CodeserverTransportError -> SyncError e
SyncError :: e -> SyncError e
instance GHC.Show.Show Unison.Share.Sync.Types.CheckAndSetPushError
instance GHC.Show.Show Unison.Share.Sync.Types.FastForwardPushError
instance GHC.Show.Show Unison.Share.Sync.Types.GetCausalHashByPathError
instance GHC.Show.Show Unison.Share.Sync.Types.PullError
instance GHC.Exception.Type.Exception Unison.Share.Sync.Types.CodeserverTransportError
instance GHC.Show.Show Unison.Share.Sync.Types.CodeserverTransportError

module Unison.Codebase.Editor.Output
data Output v
Success :: Output v
NoUnisonFile :: Output v
PrintMessage :: Pretty ColorText -> Output v
InvalidSourceName :: String -> Output v
SourceLoadFailed :: String -> Output v
NoMainFunction :: String -> PrettyPrintEnv -> [Type v Ann] -> Output v
BadMainFunction :: String -> Type v Ann -> PrettyPrintEnv -> [Type v Ann] -> Output v
BranchEmpty :: Either ShortBranchHash Path' -> Output v
BranchNotEmpty :: Path' -> Output v
LoadPullRequest :: ReadRemoteNamespace -> ReadRemoteNamespace -> Path' -> Path' -> Path' -> Path' -> Output v
CreatedNewBranch :: Absolute -> Output v
BranchAlreadyExists :: Path' -> Output v
FindNoLocalMatches :: Output v
PatchAlreadyExists :: Split' -> Output v
NoExactTypeMatches :: Output v
TypeAlreadyExists :: Split' -> Set Reference -> Output v
TypeParseError :: String -> Err v -> Output v
ParseResolutionFailures :: String -> [ResolutionFailure v Ann] -> Output v
TypeHasFreeVars :: Type v Ann -> Output v
TermAlreadyExists :: Split' -> Set Referent -> Output v
LabeledReferenceAmbiguous :: Int -> HashQualified Name -> Set LabeledDependency -> Output v
LabeledReferenceNotFound :: HashQualified Name -> Output v
DeleteNameAmbiguous :: Int -> HQSplit' -> Set Referent -> Set Reference -> Output v
TermAmbiguous :: HashQualified Name -> Set Referent -> Output v
HashAmbiguous :: ShortHash -> Set Referent -> Output v
BranchHashAmbiguous :: ShortBranchHash -> Set ShortBranchHash -> Output v
BadNamespace :: String -> String -> Output v
BranchNotFound :: Path' -> Output v
NameNotFound :: HQSplit' -> Output v
PatchNotFound :: Split' -> Output v
TypeNotFound :: HQSplit' -> Output v
TermNotFound :: HQSplit' -> Output v
TypeNotFound' :: ShortHash -> Output v
TermNotFound' :: ShortHash -> Output v
TypeTermMismatch :: HashQualified Name -> HashQualified Name -> Output v
SearchTermsNotFound :: [HashQualified Name] -> Output v
DeleteBranchConfirmation :: [(Path', (Names, [SearchResult' v Ann]))] -> Output v
DeleteEverythingConfirmation :: Output v
DeletedEverything :: Output v
ListNames :: IsGlobal -> Int -> [(Reference, Set (HashQualified Name))] -> [(Referent, Set (HashQualified Name))] -> Output v
ListOfDefinitions :: PrettyPrintEnv -> ListDetailed -> [SearchResult' v Ann] -> Output v
ListOfLinks :: PrettyPrintEnv -> [(HashQualified Name, Reference, Maybe (Type v Ann))] -> Output v
ListShallow :: PrettyPrintEnv -> [ShallowListEntry v Ann] -> Output v
ListOfPatches :: Set Name -> Output v
SlurpOutput :: Input -> PrettyPrintEnv -> SlurpResult v -> Output v
ParseErrors :: Text -> [Err v] -> Output v
TypeErrors :: Text -> PrettyPrintEnv -> [ErrorNote v Ann] -> Output v
CompilerBugs :: Text -> PrettyPrintEnv -> [CompilerBug v Ann] -> Output v
DisplayConflicts :: Relation Name Referent -> Relation Name Reference -> Output v
EvaluationFailure :: Error -> Output v
Evaluated :: SourceFileContents -> PrettyPrintEnv -> [(v, Term v ())] -> Map v (Ann, WatchKind, Term v (), IsCacheHit) -> Output v
Typechecked :: SourceName -> PrettyPrintEnv -> SlurpResult v -> TypecheckedUnisonFile v Ann -> Output v
DisplayRendered :: Maybe FilePath -> Pretty ColorText -> Output v
DisplayDefinitions :: Maybe FilePath -> PrettyPrintEnvDecl -> Map Reference (DisplayObject () (Decl v Ann)) -> Map Reference (DisplayObject (Type v Ann) (Term v Ann)) -> Output v
TestIncrementalOutputStart :: PrettyPrintEnv -> (Int, Int) -> Reference -> Term v Ann -> Output v
TestIncrementalOutputEnd :: PrettyPrintEnv -> (Int, Int) -> Reference -> Term v Ann -> Output v
TestResults :: TestReportStats -> PrettyPrintEnv -> ShowSuccesses -> ShowFailures -> [(Reference, Text)] -> [(Reference, Text)] -> Output v
CantUndo :: UndoFailureReason -> Output v
BustedBuiltins :: Set Reference -> Set Reference -> Output v
GitError :: GitError -> Output v
ShareError :: ShareError -> Output v
ConfiguredMetadataParseError :: Path' -> String -> Pretty ColorText -> Output v
NoConfiguredRemoteMapping :: PushPull -> Absolute -> Output v
ConfiguredRemoteMappingParseError :: PushPull -> Absolute -> Text -> String -> Output v
MetadataMissingType :: PrettyPrintEnv -> Referent -> Output v
TermMissingType :: Reference -> Output v
MetadataAmbiguous :: HashQualified Name -> PrettyPrintEnv -> [Referent] -> Output v
NothingToPatch :: PatchPath -> Path' -> Output v
PatchNeedsToBeConflictFree :: Output v
PatchInvolvesExternalDependents :: PrettyPrintEnv -> Set Reference -> Output v
WarnIncomingRootBranch :: ShortBranchHash -> Set ShortBranchHash -> Output v
StartOfCurrentPathHistory :: Output v
ShowReflog :: [ReflogEntry] -> Output v
PullAlreadyUpToDate :: ReadRemoteNamespace -> Path' -> Output v
PullSuccessful :: ReadRemoteNamespace -> Path' -> Output v

-- | Indicates a trivial merge where the destination was empty and was just
--   replaced.
MergeOverEmpty :: Path' -> Output v
MergeAlreadyUpToDate :: Path' -> Path' -> Output v
PreviewMergeAlreadyUpToDate :: Path' -> Path' -> Output v

-- | No conflicts or edits remain for the current patch.
NoConflictsOrEdits :: Output v
NotImplemented :: Output v
NoBranchWithHash :: ShortBranchHash -> Output v
ListDependencies :: Int -> LabeledDependency -> [(Name, Reference)] -> Set Reference -> Output v

-- | List dependents of a type or term.
ListDependents :: Int -> LabeledDependency -> [(Reference, Maybe Name)] -> Output v

-- | List all direct dependencies which don't have any names in the current
--   branch
ListNamespaceDependencies :: PrettyPrintEnv -> Absolute -> Map LabeledDependency (Set Name) -> Output v
DumpNumberedArgs :: NumberedArgs -> Output v
DumpBitBooster :: CausalHash -> Map CausalHash [CausalHash] -> Output v
DumpUnisonFileHashes :: Int -> [(Name, Id)] -> [(Name, Id)] -> [(Name, Id)] -> Output v
BadName :: String -> Output v
DefaultMetadataNotification :: Output v
CouldntLoadBranch :: CausalHash -> Output v
HelpMessage :: InputPattern -> Output v
NamespaceEmpty :: NonEmpty AbsBranchId -> Output v
NoOp :: Output v
RefusedToPush :: PushBehavior -> WriteRemotePath -> Output v

-- | <tt>GistCreated repo</tt> means a causal was just published to
--   <tt>repo</tt>.
GistCreated :: ReadRemoteNamespace -> Output v

-- | Directs the user to URI to begin an authorization flow.
InitiateAuthFlow :: URI -> Output v
UnknownCodeServer :: Text -> Output v
CredentialFailureMsg :: CredentialFailure -> Output v
PrintVersion :: Text -> Output v
IntegrityCheck :: IntegrityResult -> Output v
data NumberedOutput v
ShowDiffNamespace :: AbsBranchId -> AbsBranchId -> PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v
ShowDiffAfterUndo :: PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v
ShowDiffAfterDeleteDefinitions :: PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v
ShowDiffAfterDeleteBranch :: Absolute -> PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v
ShowDiffAfterModifyBranch :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v
ShowDiffAfterMerge :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v
ShowDiffAfterMergePropagate :: Path' -> Absolute -> Path' -> PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v
ShowDiffAfterMergePreview :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v
ShowDiffAfterPull :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v
ShowDiffAfterCreatePR :: ReadRemoteNamespace -> ReadRemoteNamespace -> PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v
ShowDiffAfterCreateAuthor :: NameSegment -> Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput v Ann -> NumberedOutput v

-- | Invariant: there's at least one conflict or edit in the TodoOutput.
TodoOutput :: PrettyPrintEnvDecl -> TodoOutput v Ann -> NumberedOutput v

-- | CantDeleteDefinitions ppe couldntDelete becauseTheseStillReferenceThem
CantDeleteDefinitions :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput v

-- | CantDeleteNamespace ppe couldntDelete becauseTheseStillReferenceThem
CantDeleteNamespace :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput v

-- | DeletedDespiteDependents ppe deletedThings
--   thingsWhichNowHaveUnnamedReferences
DeletedDespiteDependents :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput v

-- | size limit, history , how the history ends
History :: Maybe Int -> HashLength -> [(CausalHash, Diff)] -> HistoryTail -> NumberedOutput v
ListEdits :: Patch -> PrettyPrintEnv -> NumberedOutput v
type NumberedArgs = [String]
type ListDetailed = Bool
data HistoryTail
EndOfLog :: CausalHash -> HistoryTail
MergeTail :: CausalHash -> [CausalHash] -> HistoryTail
PageEnd :: CausalHash -> Int -> HistoryTail
data TestReportStats
CachedTests :: TotalCount -> CachedCount -> TestReportStats
NewlyComputed :: TestReportStats
data UndoFailureReason
CantUndoPastStart :: UndoFailureReason
CantUndoPastMerge :: UndoFailureReason
data ReflogEntry
ReflogEntry :: ShortBranchHash -> Text -> ReflogEntry
[$sel:hash:ReflogEntry] :: ReflogEntry -> ShortBranchHash
[$sel:reason:ReflogEntry] :: ReflogEntry -> Text
data ShareError
ShareErrorCheckAndSetPush :: CheckAndSetPushError -> ShareError
ShareErrorFastForwardPush :: FastForwardPushError -> ShareError
ShareErrorPull :: PullError -> ShareError
ShareErrorGetCausalHashByPath :: GetCausalHashByPathError -> ShareError
ShareErrorTransport :: CodeserverTransportError -> ShareError
isFailure :: Ord v => Output v -> Bool
isNumberedFailure :: NumberedOutput v -> Bool
instance GHC.Show.Show Unison.Codebase.Editor.Output.ReflogEntry
instance GHC.Show.Show Unison.Codebase.Editor.Output.HistoryTail
instance GHC.Show.Show Unison.Codebase.Editor.Output.TestReportStats
instance GHC.Show.Show Unison.Codebase.Editor.Output.UndoFailureReason

module Unison.Codebase.Editor.Command
data Command m i v a
[Eval] :: m a -> Command m i v a
[UI] :: Command m i v ()
[API] :: Command m i v ()
[DocsToHtml] :: Branch m -> Path -> FilePath -> Command m i v ()
[HQNameQuery] :: Maybe Path -> Branch m -> [HashQualified Name] -> Command m i v QueryResult
[LoadSearchResults] :: [SearchResult] -> Command m i v [SearchResult' v Ann]
[GetDefinitionsBySuffixes] :: Maybe Path -> Branch m -> IncludeCycles -> [HashQualified Name] -> Command m i v (DefinitionResults v)
[FindShallow] :: Absolute -> Command m i v [ShallowListEntry v Ann]
[ConfigLookup] :: Configured a => Text -> Command m i v (Maybe a)
[Input] :: Command m i v i
[Notify] :: Output v -> Command m i v ()
[NotifyNumbered] :: NumberedOutput v -> Command m i v NumberedArgs
[AddDefsToCodebase] :: TypecheckedUnisonFile v Ann -> Command m i v ()
[CodebaseHashLength] :: Command m i v Int
[TypeReferencesByShortHash] :: ShortHash -> Command m i v (Set Reference)
[TermReferencesByShortHash] :: ShortHash -> Command m i v (Set Reference)
[TermReferentsByShortHash] :: ShortHash -> Command m i v (Set Referent)
[BranchHashLength] :: Command m i v Int
[BranchHashesByPrefix] :: ShortBranchHash -> Command m i v (Set CausalHash)
[ParseType] :: NamesWithHistory -> LexedSource -> Command m i v (Either (Err v) (Type v Ann))
[LoadSource] :: SourceName -> Command m i v LoadSourceResult
[Typecheck] :: AmbientAbilities v -> NamesWithHistory -> SourceName -> LexedSource -> Command m i v (TypecheckingResult v)
[TypecheckFile] :: UnisonFile v Ann -> [Type v Ann] -> Command m i v (TypecheckingResult v)
[Evaluate] :: Bool -> PrettyPrintEnv -> TypecheckedUnisonFile v Ann -> Command m i v (Either Error (EvalResult v))
[Evaluate1] :: Bool -> PrettyPrintEnv -> UseCache -> Term v Ann -> Command m i v (Either Error (Term v Ann))
[PutWatch] :: WatchKind -> Id -> Term v Ann -> Command m i v ()
[LoadWatches] :: WatchKind -> Set Reference -> Command m i v [(Reference, Term v Ann)]
[LoadLocalRootBranch] :: Command m i v (Branch m)
[LoadLocalBranch] :: CausalHash -> Command m i v (Branch m)
[Merge] :: MergeMode -> Branch m -> Branch m -> Command m i v (Branch m)
[ViewRemoteGitBranch] :: ReadGitRemoteNamespace -> GitBranchBehavior -> (Branch m -> Free (Command m i v) r) -> Command m i v (Either GitError r)
[ImportRemoteGitBranch] :: ReadGitRemoteNamespace -> SyncMode -> Preprocessing m -> Command m i v (Either GitError (Branch m))
[SyncLocalRootBranch] :: Branch m -> Command m i v ()
[SyncRemoteGitBranch] :: WriteGitRepo -> PushGitBranchOpts -> (Branch m -> m (Either e (Branch m))) -> Command m i v (Either GitError (Either e (Branch m)))
[AppendToReflog] :: Text -> Branch m -> Branch m -> Command m i v ()
[LoadReflog] :: Command m i v [Entry CausalHash]
[LoadTerm] :: Id -> Command m i v (Maybe (Term v Ann))
[LoadTermComponentWithTypes] :: Hash -> Command m i v (Maybe [(Term v Ann, Type v Ann)])
[LoadType] :: Id -> Command m i v (Maybe (Decl v Ann))
[LoadDeclComponent] :: Hash -> Command m i v (Maybe [Decl v Ann])
[LoadTypeOfTerm] :: Reference -> Command m i v (Maybe (Type v Ann))
[PutTerm] :: Id -> Term v Ann -> Type v Ann -> Command m i v ()
[PutDecl] :: Id -> Decl v Ann -> Command m i v ()
[IsTerm] :: Reference -> Command m i v Bool
[IsType] :: Reference -> Command m i v Bool

-- | Get the immediate (not transitive) dependents of the given reference
--   This might include historical definitions not in any current path;
--   these should be filtered by the caller of this command if that's not
--   desired.
[GetDependents] :: Reference -> Command m i v (Set Reference)
[GetDependentsOfComponent] :: Hash -> Command m i v (Set Reference)
[GetTermsOfType] :: Type v Ann -> Command m i v (Set Referent)
[GetTermsMentioningType] :: Type v Ann -> Command m i v (Set Referent)
[Execute] :: PrettyPrintEnv -> TypecheckedUnisonFile v Ann -> [String] -> Command m i v (WatchResults v Ann)
[CreateAuthorInfo] :: Text -> Command m i v (AuthorInfo v Ann)
[RuntimeMain] :: Command m i v (Type v Ann)
[RuntimeTest] :: Command m i v (Type v Ann)
[ClearWatchCache] :: Command m i v ()
[AnalyzeCodebaseIntegrity] :: Command m i v IntegrityResult
[MakeStandalone] :: PrettyPrintEnv -> Reference -> String -> Command m i v (Maybe Error)

-- | Trigger an interactive fuzzy search over the provided options and
--   return all selected results.
[FuzzySelect] :: Options -> (a -> Text) -> [a] -> Command m i v (Maybe [a])

-- | This allows us to implement MonadUnliftIO for (Free (Command m i v)).
--   Ideally we will eventually remove the Command type entirely and won't
--   need this anymore.
[CmdUnliftIO] :: Command m i v (UnliftIO (Free (Command m i v)))
[UCMVersion] :: Command m i v UCMVersion
type AmbientAbilities v = [Type v Ann]
type LexedSource = (Text, [Token Lexeme])
type Source = Text
type SourceName = Text
type TypecheckingResult v = Result (Seq (Note v Ann)) (Either Names (TypecheckedUnisonFile v Ann))
data LoadSourceResult
InvalidSourceNameError :: LoadSourceResult
LoadError :: LoadSourceResult
LoadSuccess :: Text -> LoadSourceResult
type UseCache = Bool
type EvalResult v = ([(v, Term v ())], Map v (Ann, WatchKind, Id, Term v (), Term v (), IsCacheHit))
commandName :: Command m i v a -> String
lookupEvalResult :: Ord v => v -> EvalResult v -> Maybe (Term v ())
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Unison.Util.Free.Free (Unison.Codebase.Editor.Command.Command m i v))
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Unlift.MonadUnliftIO (Unison.Util.Free.Free (Unison.Codebase.Editor.Command.Command m i v))

module Unison.Codebase.Editor.Propagate
computeFrontier :: forall m. Monad m => (Reference -> m (Set Reference)) -> Patch -> (Reference -> Bool) -> m (Relation Reference Reference)
propagateAndApply :: forall m i v. (Applicative m, Var v) => Names -> Patch -> Branch0 m -> F m i v (Branch0 m)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Propagate.Edits v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Codebase.Editor.Propagate.Edits v)

module Unison.Codebase.Editor.HandleCommand
typecheck :: Monad m => [Type Symbol Ann] -> Codebase m Symbol Ann -> ParsingEnv -> SourceName -> LexedSource -> m (TypecheckingResult Symbol)
typecheck' :: Monad m => [Type Symbol Ann] -> Codebase m Symbol Ann -> UnisonFile Symbol Ann -> m (TypecheckingResult Symbol)
commandLine :: forall i a gen. DRG gen => Config -> IO i -> (Branch IO -> IO ()) -> Runtime Symbol -> Runtime Symbol -> (Output Symbol -> IO ()) -> (NumberedOutput Symbol -> IO NumberedArgs) -> (SourceName -> IO LoadSourceResult) -> Codebase IO Symbol Ann -> Maybe BaseUrl -> UCMVersion -> (Int -> IO gen) -> Free (Command IO i Symbol) a -> IO a

module Unison.Util.HTTP
addRequestMiddleware :: (Request -> IO Request) -> ManagerSettings -> ManagerSettings
setUserAgent :: Text -> ManagerSettings -> ManagerSettings
ucmUserAgent :: UCMVersion -> Text

module Unison.Auth.HTTPClient

-- | Returns a new http manager which applies the appropriate Authorization
--   header to any hosts our UCM is authenticated with.
newAuthenticatedHTTPClient :: MonadIO m => TokenProvider -> UCMVersion -> m AuthenticatedHttpClient

-- | Newtype to delineate HTTP Managers with access-token logic.
newtype AuthenticatedHttpClient
AuthenticatedHttpClient :: Manager -> AuthenticatedHttpClient

module Unison.Share.Sync

-- | Get the causal hash of a path hosted on Unison Share.
getCausalHashByPath :: AuthenticatedHttpClient -> BaseUrl -> Path -> IO (Either GetCausalHashByPathError (Maybe HashJWT))

-- | An error occurred when getting causal hash by path.
data GetCausalHashByPathError

-- | The user does not have permission to read this path.
GetCausalHashByPathErrorNoReadPermission :: Path -> GetCausalHashByPathError

-- | Perform a check-and-set push (initially of just a causal hash, but
--   ultimately all of its dependencies that the server is missing, too) to
--   Unison Share.
--   
--   This flavor of push takes the expected state of the server, and the
--   desired state we want to set; if our expectation is off, we won't
--   proceed with the push.
checkAndSetPush :: AuthenticatedHttpClient -> BaseUrl -> (forall a. (Connection -> IO a) -> IO a) -> Path -> Maybe Hash32 -> CausalHash -> UploadProgressCallbacks -> IO (Either (SyncError CheckAndSetPushError) ())

-- | Error used by the client when pushing code to Unison Share.
data CheckAndSetPushError
CheckAndSetPushErrorHashMismatch :: HashMismatch -> CheckAndSetPushError
CheckAndSetPushErrorNoWritePermission :: Path -> CheckAndSetPushError
CheckAndSetPushErrorServerMissingDependencies :: NESet Hash32 -> CheckAndSetPushError

-- | Perform a fast-forward push (initially of just a causal hash, but
--   ultimately all of its dependencies that the server is missing, too) to
--   Unison Share.
--   
--   This flavor of push provides the server with a chain of causal hashes
--   leading from its current state to our desired state.
fastForwardPush :: AuthenticatedHttpClient -> BaseUrl -> (forall a. (Connection -> IO a) -> IO a) -> Path -> CausalHash -> UploadProgressCallbacks -> IO (Either (SyncError FastForwardPushError) ())

-- | An error occurred while fast-forward pushing code to Unison Share.
data FastForwardPushError
FastForwardPushErrorNoHistory :: Path -> FastForwardPushError
FastForwardPushErrorNoReadPermission :: Path -> FastForwardPushError
FastForwardPushErrorNotFastForward :: Path -> FastForwardPushError
FastForwardPushErrorNoWritePermission :: Path -> FastForwardPushError
FastForwardPushErrorServerMissingDependencies :: NESet Hash32 -> FastForwardPushError
FastForwardPushInvalidParentage :: Hash32 -> Hash32 -> FastForwardPushError

-- | Upload progress callbacks.
data UploadProgressCallbacks
UploadProgressCallbacks :: (Int -> IO ()) -> (Int -> IO ()) -> UploadProgressCallbacks

-- | Callback that's given a number of entities we just uploaded.
[$sel:uploaded:UploadProgressCallbacks] :: UploadProgressCallbacks -> Int -> IO ()

-- | Callback that's given a number of entities we just realized we need to
--   upload later.
[$sel:toUpload:UploadProgressCallbacks] :: UploadProgressCallbacks -> Int -> IO ()
pull :: AuthenticatedHttpClient -> BaseUrl -> (forall a. (Connection -> IO a) -> IO a) -> Path -> DownloadProgressCallbacks -> IO (Either (SyncError PullError) CausalHash)

-- | Download progress callbacks.
data DownloadProgressCallbacks
DownloadProgressCallbacks :: (Int -> IO ()) -> (Int -> IO ()) -> DownloadProgressCallbacks

-- | Callback that's given a number of entities we just downloaded.
[$sel:downloaded:DownloadProgressCallbacks] :: DownloadProgressCallbacks -> Int -> IO ()

-- | Callback that's given a number of entities we just realized we need to
--   download later.
[$sel:toDownload:DownloadProgressCallbacks] :: DownloadProgressCallbacks -> Int -> IO ()

-- | An error occurred while pulling code from Unison Share.
data PullError

-- | An error occurred while resolving a repo+path to a causal hash.
PullErrorGetCausalHashByPath :: GetCausalHashByPathError -> PullError
PullErrorNoHistoryAtPath :: Path -> PullError

module Unison.CommandLine.OutputMessages
type Pretty = Pretty ColorText
shortenDirectory :: FilePath -> IO FilePath
renderFileName :: FilePath -> IO Pretty
notifyNumbered :: Var v => NumberedOutput v -> (Pretty, NumberedArgs)
showListEdits :: Patch -> PrettyPrintEnv -> (Pretty ColorText, NumberedArgs)
prettyURI :: URI -> Pretty
prettyReadRemoteNamespace :: ReadRemoteNamespace -> Pretty
prettyWriteRemotePath :: WriteRemotePath -> Pretty
notifyUser :: forall v. Var v => FilePath -> Output v -> IO Pretty
prettyFilePath :: FilePath -> Pretty
prettyPath' :: Path' -> Pretty
prettyBranchId :: AbsBranchId -> Pretty
prettyRelative :: Relative -> Pretty
prettyAbsolute :: Absolute -> Pretty
prettySBH :: IsString s => ShortBranchHash -> Pretty s
prettyCausalHash :: IsString s => CausalHash -> Pretty s
prettyBase32Hex :: IsString s => Base32Hex -> Pretty s
prettyBase32Hex# :: IsString s => Base32Hex -> Pretty s
prettyHash :: IsString s => Hash -> Pretty s
prettyHash32 :: IsString s => Hash32 -> Pretty s
formatMissingStuff :: (Show tm, Show typ) => [(HashQualified Name, tm)] -> [(HashQualified Name, typ)] -> Pretty
displayDefinitions' :: Var v => Ord a1 => PrettyPrintEnvDecl -> Map Reference (DisplayObject () (Decl v a1)) -> Map Reference (DisplayObject (Type v a1) (Term v a1)) -> Pretty
displayRendered :: Maybe FilePath -> Pretty -> IO Pretty
displayDefinitions :: Var v => Ord a1 => Maybe FilePath -> PrettyPrintEnvDecl -> Map Reference (DisplayObject () (Decl v a1)) -> Map Reference (DisplayObject (Type v a1) (Term v a1)) -> IO Pretty
displayTestResults :: Bool -> PrettyPrintEnv -> [(Reference, Text)] -> [(Reference, Text)] -> Pretty
unsafePrettyTermResultSig' :: Var v => PrettyPrintEnv -> TermResult' v a -> Pretty
unsafePrettyTermResultSigFull' :: Var v => PrettyPrintEnv -> TermResult' v a -> Pretty
prettyTypeResultHeader' :: Var v => TypeResult' v a -> Pretty
prettyTypeResultHeaderFull' :: Var v => TypeResult' v a -> Pretty
prettyDeclTriple :: Var v => (HashQualified Name, Reference, DisplayObject () (Decl v a)) -> Pretty
prettyDeclPair :: Var v => PrettyPrintEnv -> (Reference, DisplayObject () (Decl v a)) -> Pretty
renderNameConflicts :: PrettyPrintEnv -> Names -> Numbered Pretty
renderEditConflicts :: PrettyPrintEnv -> Patch -> Numbered Pretty
type Numbered = State (Int, Seq String)
addNumberedArg :: String -> Numbered Int
formatNum :: Int -> Pretty
runNumbered :: Numbered a -> (a, NumberedArgs)
todoOutput :: Var v => PrettyPrintEnvDecl -> TodoOutput v a -> (Pretty, NumberedArgs)
listOfDefinitions :: Var v => PrettyPrintEnv -> ListDetailed -> [SearchResult' v a] -> IO Pretty
listOfLinks :: Var v => PrettyPrintEnv -> [(HashQualified Name, Maybe (Type v a))] -> IO Pretty
data ShowNumbers
ShowNumbers :: ShowNumbers
HideNumbers :: ShowNumbers

-- | <tt>ppe</tt> is just for rendering type signatures `oldPath, newPath
--   :: Path.Absolute` are just for producing fully-qualified numbered args
showDiffNamespace :: forall v. Var v => ShowNumbers -> PrettyPrintEnv -> AbsBranchId -> AbsBranchId -> BranchDiffOutput v Ann -> (Pretty, NumberedArgs)
noResults :: Pretty
listOfDefinitions' :: Var v => PrettyPrintEnv -> ListDetailed -> [SearchResult' v a] -> Pretty
watchPrinter :: Var v => Text -> PrettyPrintEnv -> Ann -> WatchKind -> Term v () -> IsCacheHit -> Pretty
filestatusTip :: Pretty
prettyDiff :: Diff -> Pretty
prettyTermName :: PrettyPrintEnv -> Referent -> Pretty
prettyTypeName :: PrettyPrintEnv -> Reference -> Pretty
prettyReadGitRepo :: ReadGitRepo -> Pretty
prettyWriteGitRepo :: WriteGitRepo -> Pretty
isTestOk :: Term v Ann -> Bool

-- | Get the list of numbered args corresponding to an endangerment map,
--   which is used by a few outputs. See <a>endangeredDependentsTable</a>.
numberedArgsForEndangerments :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedArgs

-- | Format and render all dependents which are endangered by references
--   going extinct.
endangeredDependentsTable :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> Pretty ColorText

-- | Displays a full, non-truncated Branch.CausalHash to a string, e.g.
--   #abcdef
displayBranchHash :: CausalHash -> String

module Unison.CommandLine.DisplayValues
type Pretty = Pretty ColorText
displayTerm :: Monad m => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
type ElideUnit = Bool
displayTerm' :: Monad m => ElideUnit -> PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
displayPretty :: forall m. Monad m => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
displayDoc :: forall v m. (Var v, Monad m) => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term v ()))) -> (Referent -> m (Maybe (Type v ()))) -> (Term v () -> m (Maybe (Term v ()))) -> (Reference -> m (Maybe (Decl v ()))) -> Term v () -> m Pretty
termName :: PrettyPrintEnv -> Referent -> Pretty
typeName :: PrettyPrintEnv -> Reference -> Pretty

module Unison.Codebase.Editor.HandleInput.LoopState
type F m i v = Free (Command m i v)
data Env m v
Env :: AuthenticatedHttpClient -> Codebase m v Ann -> CredentialManager -> Env m v
[$sel:authHTTPClient:Env] :: Env m v -> AuthenticatedHttpClient
[$sel:codebase:Env] :: Env m v -> Codebase m v Ann
[$sel:credentialManager:Env] :: Env m v -> CredentialManager
newtype Action m i v a
Action :: MaybeT (ReaderT (Env m v) (StateT (LoopState m v) (F m i v))) a -> Action m i v a
[$sel:unAction:Action] :: Action m i v a -> MaybeT (ReaderT (Env m v) (StateT (LoopState m v) (F m i v))) a
runAction :: Env m v -> LoopState m v -> Action m i v a -> F m i v (Maybe a, LoopState m v)
liftF :: F m i v a -> Action m i v a

-- | A typeclass representing monads which can evaluate <a>Command</a>s.
class Monad n => MonadCommand n m v i | n -> m v i
eval :: MonadCommand n m v i => Command m v i a -> n a
data LoopState m v
LoopState :: Branch m -> Branch m -> NonEmpty Absolute -> Maybe (FilePath, SkipNextUpdate) -> Maybe (TypecheckedUnisonFile v Ann) -> Maybe Input -> NumberedArgs -> LoopState m v
[$sel:_root:LoopState] :: LoopState m v -> Branch m
[$sel:_lastSavedRoot:LoopState] :: LoopState m v -> Branch m
[$sel:_currentPathStack:LoopState] :: LoopState m v -> NonEmpty Absolute
[$sel:_latestFile:LoopState] :: LoopState m v -> Maybe (FilePath, SkipNextUpdate)
[$sel:_latestTypecheckedFile:LoopState] :: LoopState m v -> Maybe (TypecheckedUnisonFile v Ann)
[$sel:_lastInput:LoopState] :: LoopState m v -> Maybe Input
[$sel:_numberedArgs:LoopState] :: LoopState m v -> NumberedArgs
type Action' m v = Action m (Either Event Input) v
type SkipNextUpdate = Bool
type InputDescription = Text
root :: forall m_a3fYH v_a3fYI. Lens' (LoopState m_a3fYH v_a3fYI) (Branch m_a3fYH)
numberedArgs :: forall m_a3fYH v_a3fYI. Lens' (LoopState m_a3fYH v_a3fYI) NumberedArgs
latestTypecheckedFile :: forall m_a3fYH v_a3fYI v_a3gGH. Lens (LoopState m_a3fYH v_a3fYI) (LoopState m_a3fYH v_a3gGH) (Maybe (TypecheckedUnisonFile v_a3fYI Ann)) (Maybe (TypecheckedUnisonFile v_a3gGH Ann))
latestFile :: forall m_a3fYH v_a3fYI. Lens' (LoopState m_a3fYH v_a3fYI) (Maybe (FilePath, SkipNextUpdate))
lastSavedRoot :: forall m_a3fYH v_a3fYI. Lens' (LoopState m_a3fYH v_a3fYI) (Branch m_a3fYH)
lastInput :: forall m_a3fYH v_a3fYI. Lens' (LoopState m_a3fYH v_a3fYI) (Maybe Input)
currentPathStack :: forall m_a3fYH v_a3fYI. Lens' (LoopState m_a3fYH v_a3fYI) (NonEmpty Absolute)
currentPath :: Getter (LoopState m v) Absolute
loopState0 :: Branch m -> Absolute -> LoopState m v
respond :: MonadCommand n m i v => Output v -> n ()
respondNumbered :: NumberedOutput v -> Action m i v ()

-- | Get the codebase out of the environment.
askCodebase :: Action m i v (Codebase m v Ann)
instance Control.Monad.Fail.MonadFail (Unison.Codebase.Editor.HandleInput.LoopState.Action m i v)
instance Control.Monad.Reader.Class.MonadReader (Unison.Codebase.Editor.HandleInput.LoopState.Env m v) (Unison.Codebase.Editor.HandleInput.LoopState.Action m i v)
instance Control.Monad.State.Class.MonadState (Unison.Codebase.Editor.HandleInput.LoopState.LoopState m v) (Unison.Codebase.Editor.HandleInput.LoopState.Action m i v)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Unison.Codebase.Editor.HandleInput.LoopState.Action m i v)
instance GHC.Base.Monad (Unison.Codebase.Editor.HandleInput.LoopState.Action m i v)
instance GHC.Base.Alternative (Unison.Codebase.Editor.HandleInput.LoopState.Action m i v)
instance GHC.Base.Applicative (Unison.Codebase.Editor.HandleInput.LoopState.Action m i v)
instance GHC.Base.Functor (Unison.Codebase.Editor.HandleInput.LoopState.Action m i v)
instance Unison.Codebase.Editor.HandleInput.LoopState.MonadCommand (Unison.Codebase.Editor.HandleInput.LoopState.Action m i v) m i v
instance Unison.Codebase.Editor.HandleInput.LoopState.MonadCommand (Unison.Util.Free.Free (Unison.Codebase.Editor.Command.Command m i v)) m i v
instance Unison.Codebase.Editor.HandleInput.LoopState.MonadCommand n m i v => Unison.Codebase.Editor.HandleInput.LoopState.MonadCommand (Control.Monad.Trans.State.Lazy.StateT s n) m i v
instance Unison.Codebase.Editor.HandleInput.LoopState.MonadCommand n m i v => Unison.Codebase.Editor.HandleInput.LoopState.MonadCommand (Control.Monad.Trans.Maybe.MaybeT n) m i v
instance Unison.Codebase.Editor.HandleInput.LoopState.MonadCommand n m i v => Unison.Codebase.Editor.HandleInput.LoopState.MonadCommand (Control.Monad.Trans.Except.ExceptT e n) m i v
instance Unison.Codebase.Editor.HandleInput.LoopState.MonadCommand n m i v => Unison.Codebase.Editor.HandleInput.LoopState.MonadCommand (Control.Monad.Trans.Reader.ReaderT r n) m i v

module Unison.Codebase.Editor.HandleInput.NamespaceDependencies

-- | Check the dependencies of all types, terms, and metadata in the
--   current namespace, returns a map of dependencies which do not have a
--   name within the current namespace, alongside the names of all of that
--   thing's dependents.
--   
--   This is non-transitive, i.e. only the first layer of external
--   dependencies is returned.
--   
--   So if my namespace depends on .base.Bag.map; which depends on
--   base.Map.mapKeys, only .base.Bag.map is returned unless some other
--   definition inside my namespace depends on base.Map.mapKeys directly.
--   
--   Returns a Set of names rather than using the PPE since we already have
--   the correct names in scope on this branch, and also want to list ALL
--   names of dependents, including aliases.
namespaceDependencies :: forall m i v. Ord v => Branch0 m -> Action m i v (Map LabeledDependency (Set Name))

module Unison.Auth.OAuth

-- | Direct the user through an authentication flow with the given server
--   and store the credentials in the provided credential manager.
authenticateCodeserver :: forall m n i v. (MonadUnliftIO m, MonadCommand m n i v) => CredentialManager -> CodeserverURI -> m (Either CredentialFailure ())

module Unison.Codebase.Editor.HandleInput.AuthLogin
authLogin :: MonadUnliftIO m => CodeserverURI -> Action m i v ()

-- | Checks if the user has valid auth for the given codeserver, and runs
--   through an authentication flow if not.
ensureAuthenticatedWithCodeserver :: MonadUnliftIO m => CodeserverURI -> Action m i v ()

module Unison.Codebase.Editor.HandleInput
loop :: forall m. MonadUnliftIO m => Action m (Either Event Input) Symbol ()
parseSearchType :: (Monad m, Var v) => SrcLoc -> String -> Action' m v (Either (Output v) (Type v Ann))

module Unison.CommandLine.Main
main :: FilePath -> Welcome -> Absolute -> (Config, IO ()) -> [Either Event Input] -> Runtime Symbol -> Runtime Symbol -> Codebase IO Symbol Ann -> Maybe BaseUrl -> UCMVersion -> IO ()

module Unison.Codebase.TranscriptParser
data Stanza
Ucm :: Hidden -> ExpectingError -> [UcmLine] -> Stanza
Unison :: Hidden -> ExpectingError -> Maybe ScratchFileName -> Text -> Stanza
API :: [APIRequest] -> Stanza
UnprocessedFence :: FenceType -> Text -> Stanza
Unfenced :: Text -> Stanza
type FenceType = Text
type ExpectingError = Bool
data Hidden
data TranscriptError
TranscriptRunFailure :: Text -> TranscriptError
TranscriptParseError :: Text -> TranscriptError
data UcmLine
UcmCommand :: Absolute -> Text -> UcmLine
UcmComment :: Text -> UcmLine
withTranscriptRunner :: forall m r. MonadUnliftIO m => UCMVersion -> Maybe FilePath -> (TranscriptRunner -> m r) -> m r
parse :: String -> Text -> Either TranscriptError [Stanza]
parseFile :: FilePath -> IO (Either TranscriptError [Stanza])
instance GHC.Show.Show Unison.Codebase.TranscriptParser.Hidden
instance GHC.Classes.Eq Unison.Codebase.TranscriptParser.Hidden
instance GHC.Exception.Type.Exception Unison.Codebase.TranscriptParser.TranscriptError
instance GHC.Show.Show Unison.Codebase.TranscriptParser.TranscriptError
instance GHC.Show.Show Unison.Codebase.TranscriptParser.Stanza
instance GHC.Show.Show Unison.Codebase.TranscriptParser.APIRequest
instance GHC.Show.Show Unison.Codebase.TranscriptParser.UcmLine
