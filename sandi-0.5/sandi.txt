-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data encoding library
--   
--   Reasonably fast data encoding library.
@package sandi
@version 0.5


-- | Implemention of base 16 encoding (hex encoding) as specified in RFC
--   4648 (<a>http://tools.ietf.org/html/rfc4648</a>).
module Codec.Binary.Base16

-- | Encoding function.
--   
--   This function, unlike some other encoding functions in the library,
--   simply cannot fail. Double the length of the input string is allocated
--   for the encoded data, which is guaranteed to hold the result.
--   
--   <pre>
--   &gt;&gt;&gt; b16Enc $ Data.ByteString.pack [0x00]
--   "00"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; b16Enc $ Data.ByteString.Char8.pack "foobar"
--   "666F6F626172"
--   </pre>
b16Enc :: ByteString -> ByteString

-- | Decoding function.
--   
--   The returned value on success is <tt>Right (&lt;decoded part&gt;,
--   &lt;undecoded part&gt;)</tt> (the undecoded part is either a empty or
--   a single byte), and on failure it's <tt>Left (&lt;decoded part&gt;,
--   &lt;undecodable part&gt;)</tt>. Space equal to the length of the input
--   string is allocated, which is more than enough to hold the decoded
--   data.
--   
--   <pre>
--   &gt;&gt;&gt; b16Dec $ Data.ByteString.Char8.pack "00"
--   Right ("\NUL","")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; b16Dec $ Data.ByteString.Char8.pack "666F6F626172"
--   Right ("foobar","")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; b16Dec $ Data.ByteString.Char8.pack "666F6F62617"
--   Right ("fooba","7")
--   
--   &gt;&gt;&gt; b16Dec $ Data.ByteString.Char8.pack "666F6F62617g"
--   Left ("fooba","g")
--   </pre>
b16Dec :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | A synonym for <tt>b16_enc</tt>.
encode :: ByteString -> ByteString

-- | A synonum for <tt>b16_dec</tt>.
decode :: ByteString -> Either (ByteString, ByteString) ByteString


-- | Implemented as specified in RFC 4648
--   (<a>http://tools.ietf.org/html/rfc4648</a>).
--   
--   Base32 encoding works by expanding blocks of 5 bytes of data into
--   blocks of 8 bytes of data. Finally it also includes a well defined
--   ending of the encoded data to make sure the size of the final block of
--   encoded data is 8 bytes too.
module Codec.Binary.Base32

-- | Encoding function.
--   
--   This function encodes as large a portion of the input as possible and
--   returns the encoded part together with the remaining part. Enough
--   space is allocated for the encoding to make sure that the remaining
--   part is less than 5 bytes long, which means it can be passed to
--   <tt>b32_encode_final</tt> as is.
--   
--   <pre>
--   &gt;&gt;&gt; b32EncodePart $ Data.ByteString.Char8.pack "fooba"
--   ("MZXW6YTB","")
--   
--   &gt;&gt;&gt; b32EncodePart $ Data.ByteString.Char8.pack "foobar"
--   ("MZXW6YTB","r")
--   </pre>
b32EncodePart :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   The final block has to have a size less than 5.
--   
--   <pre>
--   &gt;&gt;&gt; b32EncodeFinal $ Data.ByteString.Char8.pack "r"
--   Just "OI======"
--   </pre>
--   
--   Trying to pass in too large a block result in failure:
--   
--   <pre>
--   &gt;&gt;&gt; b32EncodeFinal $ Data.ByteString.Char8.pack "fooba"
--   Nothing
--   </pre>
b32EncodeFinal :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   Decode as large a portion of the input as possible. Enough data is
--   allocated for the output to ensure that the remainder is less than 8
--   bytes in size. Success result in a <tt>Right</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; b32DecodePart $ Data.ByteString.Char8.pack "MZXW6YTB"
--   Right ("fooba","")
--   
--   &gt;&gt;&gt; b32DecodePart $ Data.ByteString.Char8.pack "MZXW6YTBOI======"
--   Right ("fooba","OI======")
--   </pre>
--   
--   Failures occur on bad input and result in a <tt>Left</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; b32DecodePart $ Data.ByteString.Char8.pack "M=XW6YTB"
--   Left ("","M=XW6YTB")
--   </pre>
b32DecodePart :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   The final block has to have a size of 0 or 8:
--   
--   <pre>
--   &gt;&gt;&gt; b32DecodeFinal $ Data.ByteString.Char8.pack "MZXW6YQ="
--   Just "foob"
--   
--   &gt;&gt;&gt; b32DecodeFinal $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; b32DecodeFinal $ Data.ByteString.Char8.pack "MZXW6Y="
--   Nothing
--   </pre>
--   
--   But it must be the encoding of a block that is less than 5 bytes:
--   
--   <pre>
--   &gt;&gt;&gt; b32DecodeFinal $ encode $ Data.ByteString.Char8.pack "fooba"
--   Nothing
--   </pre>
b32DecodeFinal :: ByteString -> Maybe ByteString

-- | Convenience function that combines <tt>b32_encode_part</tt> and
--   <tt>b32_encode_final</tt> to encode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "fooba"
--   "MZXW6YTB"
--   
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foobar"
--   "MZXW6YTBOI======"
--   </pre>
encode :: ByteString -> ByteString

-- | Convenience function that combines <tt>b32_decode_part</tt> and
--   <tt>b32_decode_final</tt> to decode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "MZXW6YTB"
--   Right "fooba"
--   
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "MZXW6YTBOI======"
--   Right "foobar"
--   </pre>
--   
--   Failures when decoding returns the decoded part and the remainder:
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "MZXW6YTBOI=0===="
--   Left ("fooba","OI=0====")
--   </pre>
decode :: ByteString -> Either (ByteString, ByteString) ByteString


-- | Implemented as specified in RFC 4648
--   (<a>http://tools.ietf.org/html/rfc4648</a>).
--   
--   This encoding is closely related to base 32 and so is its
--   implementation, so please refer to <a>Codec.Binary.Base32</a> for
--   further details.
module Codec.Binary.Base32Hex

-- | Encoding function.
--   
--   See <a>b32_encode_part</a>.
--   
--   <pre>
--   &gt;&gt;&gt; b32hEncodePart $ Data.ByteString.Char8.pack "fooba"
--   ("CPNMUOJ1","")
--   
--   &gt;&gt;&gt; b32hEncodePart $ Data.ByteString.Char8.pack "foobar"
--   ("CPNMUOJ1","r")
--   </pre>
b32hEncodePart :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   See <a>b32_encode_final</a>.
--   
--   <pre>
--   &gt;&gt;&gt; b32hEncodeFinal $ Data.ByteString.Char8.pack "r"
--   Just "E8======"
--   
--   &gt;&gt;&gt; b32hEncodeFinal $ Data.ByteString.Char8.pack "fooba"
--   Nothing
--   </pre>
b32hEncodeFinal :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   See <a>b32_decode_part</a>.
--   
--   <pre>
--   &gt;&gt;&gt; b32hDecodePart $ Data.ByteString.Char8.pack "CPNMUOJ1"
--   Right ("fooba","")
--   
--   &gt;&gt;&gt; b32hDecodePart $ Data.ByteString.Char8.pack "CPNMUOJ1E8======"
--   Right ("fooba","E8======")
--   
--   &gt;&gt;&gt; b32hDecodePart $ Data.ByteString.Char8.pack "C=NMUOJ1"
--   Left ("","C=NMUOJ1")
--   </pre>
b32hDecodePart :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   See <a>b32_decode_final</a>.
--   
--   <pre>
--   &gt;&gt;&gt; b32hDecodeFinal $ Data.ByteString.Char8.pack "CPNMUOG="
--   Just "foob"
--   
--   &gt;&gt;&gt; b32hDecodeFinal $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; b32hDecodeFinal $ Data.ByteString.Char8.pack "CPNMUO="
--   Nothing
--   
--   &gt;&gt;&gt; b32hDecodeFinal $ encode $ Data.ByteString.Char8.pack "fooba"
--   Nothing
--   </pre>
b32hDecodeFinal :: ByteString -> Maybe ByteString

-- | Convenience function that combines <tt>b32h_encode_part</tt> and
--   <tt>b32h_encode_final</tt> to encode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "fooba"
--   "CPNMUOJ1"
--   
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foobar"
--   "CPNMUOJ1E8======"
--   </pre>
encode :: ByteString -> ByteString

-- | Convenience function that combines <tt>b32h_decode_part</tt> and
--   <tt>b32h_decode_final</tt> to decode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "CPNMUOJ1"
--   Right "fooba"
--   
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "CPNMUOJ1E8======"
--   Right "foobar"
--   </pre>
--   
--   Failures when decoding returns the decoded part and the remainder:
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "CPNMUOJ1=8======"
--   Left ("fooba","=8======")
--   </pre>
decode :: ByteString -> Either (ByteString, ByteString) ByteString


-- | Implemented as specified in RFC 4648
--   (<a>http://tools.ietf.org/html/rfc4648</a>).
--   
--   Base64 encoding works by expanding blocks of 3 bytes of data into
--   blocks of 4 bytes of data. Finally it also includes a well defined
--   ending of the encoded data to make sure the size of the final block of
--   encoded data is 4 bytes too.
module Codec.Binary.Base64

-- | Encoding function.
--   
--   This function encodes as large a portion of the input as possible and
--   returns the encoded part together with the remaining part. Enough
--   space is allocated for the encoding to make sure that the remaining
--   part is less than 3 bytes long, which means it can be passed to
--   <tt>b64_encode_final</tt> as is.
--   
--   <pre>
--   &gt;&gt;&gt; b64EncodePart $ Data.ByteString.Char8.pack "foo"
--   ("Zm9v","")
--   
--   &gt;&gt;&gt; b64EncodePart $ Data.ByteString.Char8.pack "foob"
--   ("Zm9v","b")
--   </pre>
b64EncodePart :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   The final block has to have a size less than 3.
--   
--   <pre>
--   &gt;&gt;&gt; b64EncodeFinal $ Data.ByteString.Char8.pack "r"
--   Just "cg=="
--   </pre>
--   
--   Trying to pass in too large a block result in failure:
--   
--   <pre>
--   &gt;&gt;&gt; b64EncodeFinal $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
b64EncodeFinal :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   Decode as large a portion of the input as possible. Enough data is
--   allocated for the output to ensure that the remainder is less than 4
--   bytes in size. Success result in a <tt>Right</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; b64DecodePart $ Data.ByteString.Char8.pack "Zm9v"
--   Right ("foo","")
--   
--   &gt;&gt;&gt; b64DecodePart $ Data.ByteString.Char8.pack "Zm9vYmE="
--   Right ("foo","YmE=")
--   </pre>
--   
--   Failures occur on bad input and result in a <tt>Left</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; b64DecodePart $ Data.ByteString.Char8.pack "Z=9v"
--   Left ("","Z=9v")
--   </pre>
b64DecodePart :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   The final block has to have a size of 0 or 4:
--   
--   <pre>
--   &gt;&gt;&gt; b64DecodeFinal $ Data.ByteString.Char8.pack "Zm8="
--   Just "fo"
--   
--   &gt;&gt;&gt; b64DecodeFinal $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; b64DecodeFinal $ Data.ByteString.Char8.pack "Zm="
--   Nothing
--   </pre>
--   
--   But it must be the encoding of a block that is less than 3 bytes:
--   
--   <pre>
--   &gt;&gt;&gt; b64DecodeFinal $ encode $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
b64DecodeFinal :: ByteString -> Maybe ByteString

-- | Convenience function that combines <tt>b64_encode_part</tt> and
--   <tt>b64_encode_final</tt> to encode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foo"
--   "Zm9v"
--   
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foobar"
--   "Zm9vYmFy"
--   </pre>
encode :: ByteString -> ByteString

-- | Convenience function that combines <tt>b64_decode_part</tt> and
--   <tt>b64_decode_final</tt> to decode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "Zm9v"
--   Right "foo"
--   
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "Zm9vYmFy"
--   Right "foobar"
--   </pre>
--   
--   Failures when decoding returns the decoded part and the remainder:
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "Zm9vYm=y"
--   Left ("foo","Ym=y")
--   </pre>
decode :: ByteString -> Either (ByteString, ByteString) ByteString


-- | Implemented as specified in RFC 4648
--   (<a>http://tools.ietf.org/html/rfc4648</a>).
--   
--   The difference compared to vanilla Base64 encoding is just in two
--   characters. In Base64 the characters <tt>/+</tt> are used, and in
--   Base64Url they are replaced by <tt>_-</tt> respectively.
--   
--   Please refer to <a>Codec.Binary.Base64</a> for the details of all
--   functions in this module.
module Codec.Binary.Base64Url
b64uEncodePart :: ByteString -> (ByteString, ByteString)
b64uEncodeFinal :: ByteString -> Maybe ByteString
b64uDecodePart :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)
b64uDecodeFinal :: ByteString -> Maybe ByteString
encode :: ByteString -> ByteString
decode :: ByteString -> Either (ByteString, ByteString) ByteString


-- | Implemented as described at
--   <a>http://en.wikipedia.org/wiki/Ascii85</a>.
module Codec.Binary.Base85

-- | Encoding function.
--   
--   Encodes as large a part as possible of the indata.
--   
--   <pre>
--   &gt;&gt;&gt; b85EncodePart $ Data.ByteString.Char8.pack "foobar"
--   ("AoDTs","ar")
--   </pre>
--   
--   It supports special handling of both all-zero groups and all-space
--   groups.
--   
--   <pre>
--   &gt;&gt;&gt; b85EncodePart $ Data.ByteString.Char8.pack "    "
--   ("y", "")
--   
--   &gt;&gt;&gt; b85EncodePart $ Data.ByteString.Char8.pack "\0\0\0\0"
--   ("z", "")
--   </pre>
b85EncodePart :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   <pre>
--   &gt;&gt;&gt; b85EncodeFinal $ Data.ByteString.Char8.pack "ar"
--   Just "@&lt;)"
--   </pre>
b85EncodeFinal :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   Decode as large a portion of the input as possible.
--   
--   <pre>
--   &gt;&gt;&gt; b85DecodePart $ Data.ByteString.Char8.pack "AoDTs"
--   Right ("foob","")
--   
--   &gt;&gt;&gt; b85DecodePart $ Data.ByteString.Char8.pack "AoDTs@&lt;)"
--   Right ("foob","@&lt;)")
--   
--   &gt;&gt;&gt; b85DecodePart $ Data.ByteString.Char8.pack "@&lt;)"
--   Right ("","@&lt;)")
--   </pre>
--   
--   At least 512 bytes of data is allocated for the output, but because of
--   the special handling of all-zero and all-space groups it is possible
--   that the space won't be enough. (To be sure to always fit the output
--   one would have to allocate 5 times the length of the input. It seemed
--   a good trade-off to sometimes have to call the function more than once
--   instead.)
--   
--   <pre>
--   &gt;&gt;&gt; either snd snd $ b85DecodePart $ Data.ByteString.Char8.pack $ Prelude.take 129 $ repeat 'y'
--   "y"
--   </pre>
b85DecodePart :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   <pre>
--   &gt;&gt;&gt; b85DecodeFinal $ Data.ByteString.Char8.pack "@&lt;)"
--   Just "ar"
--   
--   &gt;&gt;&gt; b85DecodeFinal $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; b85DecodeFinal $ Data.ByteString.Char8.pack "AoDTs"
--   Nothing
--   </pre>
b85DecodeFinal :: ByteString -> Maybe ByteString

-- | Convenience function that combines <tt>b85_encode_part</tt> and
--   <tt>b85_encode_final</tt> to encode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; encode  $ Data.ByteString.Char8.pack "foob"
--   "AoDTs"
--   
--   &gt;&gt;&gt; encode  $ Data.ByteString.Char8.pack "foobar"
--   "AoDTs@&lt;)"
--   </pre>
encode :: ByteString -> ByteString

-- | Convenience function that combines <tt>b85_decode_part</tt> and
--   <tt>b85_decode_final</tt> to decode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; decode  $ Data.ByteString.Char8.pack "AoDTs"
--   "foob"
--   
--   &gt;&gt;&gt; encode  $ Data.ByteString.Char8.pack "AoDTs@&lt;)"
--   "foobar"
--   </pre>
decode :: ByteString -> Either (ByteString, ByteString) ByteString


-- | Implementation of Quoted-Printable based on RFC 2045
--   (<a>http://tools.ietf.org/html/rfc2045</a>).
module Codec.Binary.QuotedPrintable

-- | Encoding function.
--   
--   This function encodes <i>everything</i> that is passed in, it will not
--   try to guess the native line ending for your architecture. In other
--   words, if you are using this to encode text you need to split it into
--   separate lines before encoding.
--   
--   This function allocates enough space to hold twice the size of the
--   indata (or at least 512 bytes) and then encodes as much as possible of
--   the indata. That means there is a risk that the encoded data won't fit
--   and in that case the second part of the pair contains the remainder of
--   the indata.
--   
--   <pre>
--   &gt;&gt;&gt; qpEncode $ Data.ByteString.Char8.pack "="
--   ("=3D","")
--   
--   &gt;&gt;&gt; snd $ qpEncode $ Data.ByteString.Char8.pack $ Data.List.take 171 $ repeat '='
--   "="
--   </pre>
--   
--   All space (0x20) and tab (0x9) characters are encoded:
--   
--   <pre>
--   &gt;&gt;&gt; qpEncode $ Data.ByteString.Char8.pack " \t"
--   ("=20=09","")
--   </pre>
--   
--   Since the input is supposed to have been split prior to calling this
--   function all occurances of CR and LF are encoded.
--   
--   <pre>
--   &gt;&gt;&gt; qpEncode $ Data.ByteString.Char8.pack "\n\r\r\n\n\r"
--   ("=0A=0D=0D=0A=0A=0D","")
--   </pre>
--   
--   Soft line breaks are inserted as needed
--   
--   <pre>
--   &gt;&gt;&gt; qpEncode $ Data.ByteString.Char8.pack "========================="
--   ("=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=\r\n=3D","")
--   </pre>
qpEncode :: ByteString -> (ByteString, ByteString)

-- | Single line encoding function.
--   
--   Like <a>qpEncode</a>, but without inserting soft line breaks.
qpEncodeSL :: ByteString -> (ByteString, ByteString)

-- | Decoding function.
--   
--   <pre>
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "foobar"
--   Right "foobar"
--   
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "1=20+=201=20=3D=202"
--   Right "1 + 1 = 2"
--   </pre>
--   
--   The input data is allowed to use lowercase letters in the hexadecimal
--   representation of an octets value, even though the standard says that
--   only uppercase letters may be used:
--   
--   <pre>
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "=3D"
--   Right "="
--   
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "=3d"
--   Right "="
--   </pre>
--   
--   It also allows the input to encode _all_ octets in the hexadecimal
--   representation:
--   
--   <pre>
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "=20!"
--   Right (" !","")
--   
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "=20=21"
--   Right (" !","")
--   </pre>
--   
--   A <tt>Left</tt> value is only ever returned on decoding errors.
--   
--   <pre>
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "=2"
--   Right ("","=2")
--   
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "=2g"
--   Left ("","=2g")
--   </pre>
--   
--   Per the specification a CRLF pair is left in, but a single CR or LF is
--   an error.
--   
--   <pre>
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "\r\n"
--   Right ("\r\n","")
--   
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "\n"
--   Left ("","\n")
--   
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack "\r"
--   Left ("","\r")
--   </pre>
--   
--   the same goes for space and tab characters
--   
--   <pre>
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack " \t"
--   Right (" \t","")
--   </pre>
--   
--   The function deals properly with soft line breaks.
--   
--   <pre>
--   &gt;&gt;&gt; qpDecode $ Data.ByteString.Char8.pack " =\r\n"
--   Right (" ","")
--   </pre>
qpDecode :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Convenient function that calls <a>qpEncode</a> repeatedly until the
--   whole input data is encoded.
encode :: ByteString -> ByteString

-- | A synonym for <tt>qpDec</tt>.
decode :: ByteString -> Either (ByteString, ByteString) ByteString


-- | Uuencoding is notoriously badly specified. This implementation aims at
--   being compatible with the GNU Sharutils
--   (<a>http://www.gnu.org/software/sharutils/</a>).
--   
--   Just like Base64 encoding uuencoding expands blocks of 3 bytes into
--   blocks of 4 bytes. There is however no well defined ending to a piece
--   of encoded data, instead uuencoded data is commonly transferred
--   linewise where each line is prepended with the length of the data in
--   the line.
--   
--   This module currently only deals with the encoding. Chopping the
--   encoded data into lines, and unchopping lines into encoded data is
--   left as an exercise to the reader. (Patches are welcome.)
module Codec.Binary.Uu

-- | Encoding function.
--   
--   This function encodes as large a portion of the input as possible and
--   returns the encoded part together with the remaining part. Enough
--   space is allocated for the encoding to make sure that the remaining
--   part is less than 3 bytes long, which means it can be passed to
--   <tt>uu_encode_final</tt> as is.
--   
--   <pre>
--   &gt;&gt;&gt; uuEncodePart $ Data.ByteString.Char8.pack "foo"
--   ("9F]O","")
--   
--   &gt;&gt;&gt; uuEncodePart $ Data.ByteString.Char8.pack "foob"
--   ("9F]O","b")
--   </pre>
uuEncodePart :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   The final block has to have a size less than 3.
--   
--   <pre>
--   &gt;&gt;&gt; uuEncodeFinal $ Data.ByteString.Char8.pack "r"
--   Just "&lt;@"
--   </pre>
--   
--   Trying to pass in too large a block result in failure:
--   
--   <pre>
--   &gt;&gt;&gt; uuEncodeFinal $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
uuEncodeFinal :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   Decode as large a portion of the input as possible. Enough data is
--   allocated for the output to ensure that the remainder is less than 4
--   bytes in size. Success result in a <tt>Right</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; uuDecodePart $ Data.ByteString.Char8.pack "9F]O"
--   Right ("foo","")
--   
--   &gt;&gt;&gt; uuDecodePart $ Data.ByteString.Char8.pack "9F]O8F$"
--   Right ("foo","8F$")
--   </pre>
--   
--   Failures occur on bad input and result in a <tt>Left</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; uuDecodePart $ Data.ByteString.Char8.pack "9F 0"
--   Left ("","9F 0")
--   </pre>
uuDecodePart :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   The final block has to have a size of 0 or 4:
--   
--   <pre>
--   &gt;&gt;&gt; uuDecodeFinal $ Data.ByteString.Char8.pack "9F\\"
--   Just "fo"
--   
--   &gt;&gt;&gt; uuDecodeFinal $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; uuDecodeFinal $ Data.ByteString.Char8.pack "9F¬"
--   Nothing
--   </pre>
--   
--   But it must be the encoding of a block that is less than 3 bytes:
--   
--   <pre>
--   &gt;&gt;&gt; uuDecodeFinal $ encode $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
uuDecodeFinal :: ByteString -> Maybe ByteString

-- | Convenience function that combines <tt>uu_encode_part</tt> and
--   <tt>uu_encode_final</tt> to encode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foo"
--   "9F]O"
--   
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foobar"
--   "9F]O8F%R"
--   </pre>
encode :: ByteString -> ByteString

-- | Convenience function that combines <tt>uu_decode_part</tt> and
--   <tt>uu_decode_final</tt> to decode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "9F]O"
--   Right "foo"
--   
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "9F]O8F%R"
--   Right "foobar"
--   </pre>
--   
--   Failures when decoding returns the decoded part and the remainder:
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "9F]O8F¬R"
--   Left ("foo","8F\172R")
--   </pre>
decode :: ByteString -> Either (ByteString, ByteString) ByteString


-- | Xxencoding is obsolete but still included for completeness. Further
--   information on the encoding can be found at
--   <a>http://en.wikipedia.org/wiki/Xxencode</a>. It should be noted that
--   this implementation performs no padding.
--   
--   This encoding is very similar to uuencoding, therefore further
--   information regarding the functions can be found in the documentation
--   of <a>Codec.Binary.Uu</a>.
module Codec.Binary.Xx

-- | Encoding function.
--   
--   <pre>
--   &gt;&gt;&gt; xxEncodePart $ Data.ByteString.Char8.pack "foo"
--   ("Naxj","")
--   
--   &gt;&gt;&gt; xxEncodePart $ Data.ByteString.Char8.pack "foob"
--   ("Naxj","b")
--   </pre>
xxEncodePart :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   <pre>
--   &gt;&gt;&gt; xxEncodeFinal $ Data.ByteString.Char8.pack "r"
--   Just "QU"
--   
--   &gt;&gt;&gt; xxEncodeFinal $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
xxEncodeFinal :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   <pre>
--   &gt;&gt;&gt; xxDecodePart $ Data.ByteString.Char8.pack "Naxj"
--   Right ("foo","")
--   
--   &gt;&gt;&gt; xxDecodePart $ Data.ByteString.Char8.pack "NaxjMa3"
--   Right ("foo","Ma3")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; xxDecodePart $ Data.ByteString.Char8.pack "Na j"
--   Left ("","Na J")
--   </pre>
xxDecodePart :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   <pre>
--   &gt;&gt;&gt; xxDecodeFinal $ Data.ByteString.Char8.pack "Naw"
--   Just "fo"
--   
--   &gt;&gt;&gt; xxDecodeFinal $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; xxDecodeFinal $ Data.ByteString.Char8.pack "Na "
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; xxDecodeFinal $ encode $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
xxDecodeFinal :: ByteString -> Maybe ByteString
encode :: ByteString -> ByteString
decode :: ByteString -> Either (ByteString, ByteString) ByteString


-- | Implementation based on the specification found at
--   <a>http://yence.sourceforge.net/docs/protocol/version1_3_draft.html</a>.
module Codec.Binary.Yenc

-- | Encoding function.
--   
--   This function allocates enough space to hold 20% more than the size of
--   the indata (or at least 512 bytes) and then encodes as much as
--   possible of the indata. That means there is a risk that the encoded
--   data won't fit and in that case the second part of the pair contains
--   the remainder of the indata.
--   
--   <pre>
--   &gt;&gt;&gt; yEncode $ Data.ByteString.Char8.pack "foobar"
--   ("\144\153\153\140\139\156","")
--   
--   &gt;&gt;&gt; snd $ yEncode $ Data.ByteString.Char8.pack $ Data.List.take 257 $ repeat '\x13'
--   "\DC3"
--   </pre>
yEncode :: ByteString -> (ByteString, ByteString)

-- | Decoding function.
--   
--   <pre>
--   &gt;&gt;&gt; yDecode $ Data.ByteString.pack [144,153,153,140,139,156]
--   Right ("foobar","")
--   
--   &gt;&gt;&gt; yDecode $ Data.ByteString.Char8.pack "=}"
--   Right ("\DC3","")
--   </pre>
--   
--   A <tt>Left</tt> value is only ever returned on decoding errors which,
--   due to characteristics of the encoding, can never happen.
--   
--   <pre>
--   &gt;&gt;&gt; yDecode $ Data.ByteString.Char8.pack "="
--   Right ("","=")
--   </pre>
yDecode :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Convenient function that calls <tt>y_enc</tt> repeatedly until the
--   whole input data is encoded.
encode :: ByteString -> ByteString

-- | A synonym for <tt>y_dec</tt>.
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.QuotedPrintable
encode :: Monad m => ConduitT ByteString ByteString m ()
decode :: (Monad m, MonadThrow m) => ConduitT ByteString ByteString m ()


module Data.Conduit.Codec.Base85
encode :: Monad m => ConduitT ByteString ByteString m ()
decode :: (Monad m, MonadThrow m) => ConduitT ByteString ByteString m ()


module Data.Conduit.Codec.Base64Url
encode :: Monad m => ConduitT ByteString ByteString m ()
decode :: (Monad m, MonadThrow m) => ConduitT ByteString ByteString m ()


module Data.Conduit.Codec.Base64
encode :: Monad m => ConduitT ByteString ByteString m ()
decode :: (Monad m, MonadThrow m) => ConduitT ByteString ByteString m ()


module Data.Conduit.Codec.Base32Hex
encode :: Monad m => ConduitT ByteString ByteString m ()
decode :: (Monad m, MonadThrow m) => ConduitT ByteString ByteString m ()


module Data.Conduit.Codec.Base32
encode :: Monad m => ConduitT ByteString ByteString m ()
decode :: (Monad m, MonadThrow m) => ConduitT ByteString ByteString m ()


module Data.Conduit.Codec.Base16
encode :: Monad m => ConduitT ByteString ByteString m ()
decode :: (Monad m, MonadThrow m) => ConduitT ByteString ByteString m ()


module Data.Conduit.Codec.Uu
encode :: Monad m => ConduitT ByteString ByteString m ()
decode :: (Monad m, MonadThrow m) => ConduitT ByteString ByteString m ()


module Data.Conduit.Codec.Xx
encode :: Monad m => ConduitT ByteString ByteString m ()
decode :: (Monad m, MonadThrow m) => ConduitT ByteString ByteString m ()


module Data.Conduit.Codec.Yenc
encode :: Monad m => ConduitT ByteString ByteString m ()
decode :: (Monad m, MonadThrow m) => ConduitT ByteString ByteString m ()
